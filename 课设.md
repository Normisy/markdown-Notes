# OJ留档
## 1. k翻转链表
```cpp
class Solution {
public:
    /**
     * @param head: a ListNode
     * @param k: An integer
     * @return: a ListNode
     */
    ListNode* reverseKGroup(ListNode* head, int k) { //返回一次kreverse后的首结点
        //基准情况：后面没有k个数了
        ListNode* test = head;
        int t = k;
        while (t--) {
            if (test == nullptr)
                return head;
            test = test->next;
        }

        ListNode* prev = head;
        ListNode* now = (prev->next != nullptr) ? prev->next : nullptr;
        ListNode* will = (now != nullptr && now->next != nullptr) ? now->next : nullptr;

        int m = k;
        while (--m) {
            now->next = prev;
            prev = now;
            now = will;
            if (will == nullptr || will->next == nullptr)
                will = nullptr;
            else  will = will->next;
        }
        if (prev != nullptr)
            head->next = reverseKGroup(now, k);
        head = prev;

        return prev;
    }

 
};
```
比较简单，注意边界情况即可（prev、now、will的后两个可能为空，要加个判断）

## 2. 最大矩形
### a. 状态表示
状态表示：`f[i][j]` 
集合：前i行中，以坐标为(i, j)的值为1的元素的高`h[i]`为宽，以第i行中的一个或多个连续的值1元素为底边，所形成的矩形
属性：第i行所有的`f[i][j]`求max
```c
class Solution {

public:

    /**

     * @param matrix: a boolean 2D matrix

     * @return: an integer

     */

  

int area(const int& i, vector<vector<int>>& h, const int& y) {  //返回以第i行为底边的最大矩形面积

  

    vector<int> nums = h[i];

    nums.push_back(0);

    // int y = nums.size();

    stack<std::pair<int,int>> st; //宽-高

        st.push({0, 0});

  

        int ans{};

  

        for (auto const height : nums) {

            if (height >= st.top().second) {

                st.push({1, height});

            } else {

                int w = 0;

                while (st.top().second > height) {

                    w += st.top().first;

                    ans = std::max(ans, st.top().second * w);

                    st.pop();

                }

                st.push({w + 1, height});

            }

        }

  

        return ans;

}

  

    // vector<vector<int>> heightT(const int& x, const int& y, vector<vector<bool>> &matrix) {  //求(i, j)上连续的1值元素的累计高度，使用类似前缀和的方法，复杂度x*y

    //     // int x = matrix.size();

    //     // int y = matrix[0].size();

    //     vector<vector<int>> h(x, vector<int>(y, 0));   //h[i][j]表示(i, j)上连续的1值元素“柱长”（如果是1，则包括自己；如果是0，则为0）

    //     // for (int i{}; i < x; i++)

    //     //     for (int j{}; j < y; j++) {

    //     //         if (matrix[i][j] == 0) {

    //     //             h[i][j] = 0;

    //     //             continue;

    //     //         }

    //     //         else if (i-1 >= 0)

    //     //               h[i][j] = h[i-1][j]+1;

    //     //         else  h[i][j] = 1;

    //     //     }

    //         }

    //     }

  

    //     return h;

    // }

  

    int maximalRectangle(vector<vector<bool>> &matrix) {

        // write your code here

        if (matrix.empty()) return 0;

        int x = matrix.size();

        int y = matrix[0].size();

        vector<vector<int>> h(++x, vector<int>(y, 0));  //多开一行避免越界

        for (int i=1; i < x; i++) {

            for (int j=0; j < y; j++) {

                h[i][j] = matrix[i-1][j] ? h[i-1][j] + 1 : 0;

            }

        }

  

        int result = 0;

        // vector<vector<int>> h = heightT(x, y, matrix);

        for (int i = 1; i < x; i++) {

                result = max(result, area(i, h, y));

            }

        return result;

  

    }

};
```


## 3. 二叉树最近k个值
```c

class Solution {

public:

    /**

     * @param root: the given BST

     * @param target: the given target

     * @param k: the given k

     * @return: k values in the BST that are closest to the target

     *          we will sort your return value in output

     */

  

    void output(vector<int> &a, TreeNode* r, const double& t, int& v, double& mini) {  //获取搜索树的中序遍历单增序列，顺便记录最接近给定值t的那个索引位置

        if (r == nullptr)  return;

        output(a, r->left, t, v, mini);

        a.push_back(r->val);

        if (mini > abs(t - r->val)) {

            mini = min(mini, abs(t-r->val));

            v = a.size() - 1;  //最接近的索引

        }

        output(a, r->right, t, v, mini);

    }

  

    vector<int> findKclose(const vector<int>& a, int index, int k) {  

        vector<int> ans;  

        int l = 0, r = 0;  //长度为k的窗口在a上滑动

        int base = a[index];

        if (index >= k-1) {

            r = index;

            l = index - k+1;

        }

        else {

            l = 0;

            r = k-1;

        }              

  

    if(r+1 <= a.size()-1 && (base - a[l]) > (a[r+1] - base)) {

        l++;

        r++;

    }

  

        while (l < index && r+1 < a.size()-1 && r > index && (base - a[l]) > (a[r+1] - base)) {

            l++;

            r++;

        }

        for (int i = l; i <= r; i++) {

            ans.push_back(a[i]);

        }

        return ans;

    }

  

    vector<int> closestKValues(TreeNode *root, double target, int k) {

        // write your code here

        vector<int> nums;

        int v = 0;

        double mini = numeric_limits<double>::max();

        output(nums, root, target, v, mini);

        return findKclose(nums, v, k);

    }

};
```

## 4. 拓扑排序
```c
class Solution {

public:

    /**

     * @param numCourses: a total of n courses

     * @param prerequisites: a list of prerequisite pairs

     * @return: the course order

     */

    vector<int> findOrder(int numCourses, vector<vector<int>> &prerequisites) {

        // write your code here

        vector<int> idegree(numCourses, 0);

        vector<vector<int>> graph(numCourses);

        vector<int> order;

        queue<int> ans;

  

        for (int i = 0; i < prerequisites.size(); i++) {

            idegree[prerequisites[i][0]] += 1;

            graph[prerequisites[i][1]].push_back(prerequisites[i][0]);

        }

  

        for (int i = 0; i < numCourses; i++) {

            if (idegree[i] == 0)  ans.push(i);

        }

  

        while (!ans.empty()) {

            int k = ans.front();

            ans.pop();

            order.push_back(k);

            for (auto j : graph[k]) {

                idegree[j]--;

                if (idegree[j] == 0)

                    ans.push(j);

  

            }

  

        }

  

        vector<int> nul;

        if (order.size() != numCourses)  return nul;

        else return order;

  
  

    }

};
```
# 1. Astar拼图
拼图游戏的规则在于：一个n\*n的图像被分割为n^2块，其中一块为空，这块空区域的上下左右位置的四块拼图能够选取任意一块移动到这个位置，然后原位置为空
其实就相当于：目标拼图与空位置拼图进行了一次交换，使得目标拼图为空，空位置拼图为目标拼图，这个通过swap方法完成即可
并且只有空拼图的上下左右四个位置的拼图能够与空拼图进行交换

将整个拼图的状态视为一个结点，以3\*3拼图为例，我们的目标结点是：
$$ \begin{bmatrix}
1 & 2 & 3\\
4 & 5 & 6\\
7 & 8 & N
\end{bmatrix}$$
其中N代表空拼图

而初始结点可能是：
$$ \begin{bmatrix}
1 & 6 & 3\\
4 & N & 8\\
7 & 5 & 2
\end{bmatrix}$$
所以，这个初始结点经过第一步移动，可能变为下面四个状态结点：
$$ \begin{bmatrix} 
1 & N & 3\\
4 & 6 & 8\\
7 & 5 & 2\end{bmatrix}, \begin{bmatrix} 
1 & 6 & 3\\
N & 4 & 8\\
7 & 5 & 2\end{bmatrix},
\begin{bmatrix} 
1 & 6 & 3\\
4 & 5 & 8\\
7 & N & 2\end{bmatrix},
\begin{bmatrix} 
1 & 6 & 3\\
4 & 8 & N\\
7 & 5 & 2\end{bmatrix}$$
这就是一步后的状态

很显然，从一个状态移动到另一个状态的移动代价G只需要1步swap，所以我们不妨定义为G=1
接下来，我们需要定义状态与目标之间的距离度量（估算成本）H
采取曼哈顿方法进行距离估算
目标状态中，对于编号为k（$1\leq k \leq 8$）的拼图，其位置记为$(x_p, y_p)=((k-1)\%n,\lfloor (k-1)/n\rfloor)$
遍历当前状态中的每块拼图，对于每个点(x, y, k)，计算该点与目标状态中的同编号k的点的坐标的曼哈顿距离：$|x - x_p| + |y - y_p|$
总的估算成本就是：$H =\sum_{i=1}^{n-1}(|x_i - x_{p_i}| + |y_i - y_{p_i}|)$
F值直接把G和H进行相加即可

定义完成之后，算法的步骤就很简单了：
定义一个openList和closeList，前者存放待检查的状态结点，后者存放完全无需检查的状态结点
设起点为A
- 从起点A开始，先将起点A加入openList
- 随后，从openList中取出一个F值最小的结点N，放到closeList中，代表已经走过，将其父节点设置为当前状态结点
- 检查该结点的相邻结点：将拼图状态中，那块空拼图上下左右相邻四块拼图中任选一个与之交换后形成的状态，这些都是可走的
	- 如果在closeList中，跳过它
	- 计算其G、H、F的值
	- 如果不在openList中，加入openList，
	- 如果已经在openList中，我们检查从起点到达这个已经在openList中的状态是否具有更小的G值（也就是，先从当前状态到达F值最小的状态，然后从F值最小的状态到达这个已经在openList中的状态的G值G1，是否小于当前状态直接到达这个在openList中的状态的G值G2，G2也就是原来的这个结点的G）
		- 如果G1 > G2，那么不作任何处理
		- 如果G1 < G2，那么用G1取代原来的G（等于G2），更新该结点的G和F值，把该结点的父结点设置为这个F值最小的结点N
- 全部检查完成后，每个结点的F值被确保更新为最小状态，再从openList取出新的结点，直到取出的结点是目标节点

如何评判一个状态和另一个状态的相同性和不同性？采用哈希的方式，先将状态中的二维数组进行遍历，展平为字符串，然后使用`std::hash`将字符串转换为哈希值，虽然会有冲突的可能，但因为数组维度小，冲突可能性不高，这里还是直接使用哈希值进行评判：哈希值相等，那么认为两个状态相同

需要定义的类：
拼图类：状态结点，是一个二维n\*n 的图块数组，一个string成员用来记录将二维数组中每个图块的编号按照顺序排列生成的序列，另外一个size_t或int成员记录该string的哈希值，
一个拼图类指针，指向它的父节点
然后有int成员G、H、F，其中H值是预估成本，通过把每个图块的d值相加获得；G值是移动成本， 初始为0，随着每次从openList取出结点而更新，F值就是G+H值。H值在初始化拼图类的时候生成，G和F值在每次行动时被更新

openList采用小根堆的形式，根据F值排序
closeList使用队列，方便输出拼图过程

# 2. Merkle Tree实现文件同步至磁盘

基本思想：

- 文件的变化检测：
对于一个文件，检测其是否发生了更新的依据是该文件的修改时间戳或相对路径是否发生了改变。在文件的同步过程中，修改事件戳或相对路径的变化说明这个文件需要被同步，为了集中体现这种变化，我们将文件的时间戳和相对路径组织为一整个字符串，对这个字符串使用哈希转换为值，这个值发生改变就说明文件发生了变动

- 文件夹的组织：
对于文件的同步，我们希望能够仅仅对发生变化的文件进行同步，而不是一股脑将整个文件夹下的文件或目录进行覆盖，因此我们需要一个具有一定顺序的数据结构来表示整个文件夹
Merkle Tree的思想是：一棵树就是一个文件夹，树中的一个叶节点代表该目录下一个真实的文件或子文件夹，每个节点存储的数据域是一个哈希值：对于叶节点，该哈希值是文件或文件夹的哈希值；对于非叶节点，该哈希值是由其子节点的字符串组织而成的一个总字符串哈希形成的哈希值；一个文件夹的哈希值就是这棵树的根节点的哈希值

这样的组织形式的好处在于：很好地表示了文件夹之间的嵌套关系，当一个文件发生改变时，从该文件的子节点到整个总文件夹的根节点的路径上的节点哈希值都会发生变化，可以非常敏感地检测到文件的更新，同时只需要沿着哈希值发生变化的节点一直往下搜索，就可以找到每个发生变化的文件了


但是这样的
树的结构：
树的节点由一个哈希值，一个指向第一个孩子的节点指针，指向下一个兄弟的节点指针和一个指向父节点的指针组成






在这个基础上，进行文件夹中文件的定期同步：文件新增、删减以及更新。是MerkleTree类中的一个接收MerkleTree* other参数对象的方法，other是待同步的文件夹，this是这棵树，也就是发生了改变的文件夹。
下面的思路有没有问题：
- 总的叶节点数没有改变：对于两棵树，从它们的根节点开始遍历，从上往下比对两颗树的节点：如果节点的哈希值hash不同，那么将走到这个节点的移动（左或者右）记录下来，然后检查这个节点的子结点的哈希值是否与另一棵树一致；如果节点的哈希值一致，那么就跳过这个节点以及其下方的整棵子树，直到找到所有发生更新的叶节点（文件）；

- 总的叶节点数增加：作为参数的这棵树的叶子节点数会比当前的树的节点数更多（而且都会是偶数），那么增加的层数k=(this->leafNum - other->leafNum)/4再向上取整，而且原来的文件（叶子节点）一定靠左，新增的文件一定靠右，所以我们只需要从根节点开始，往左边走k次，就走到原来的根节点位置了，从这里开始检查文件的更新；而文件的新增则找根节点的右子树，把其中的所有叶节点对应的文件同步到other文件夹中即可；

- 总的叶节点数减少：由于删减的

# 3. 红黑树实现英语词典软件

目标：使用红黑树存储英语单词，使其满足：单词的新增、删除、搜索匹配、根据所给定的前k个字母查找出最符合的所有单词的模糊搜索匹配

本题最关键的一步在于将单词存储入红黑树时，单词之间的比较策略。最直观的比较策略是按照单词的首字母的字典顺序大小作为单词节点的大小，可是如果采取这种策略，在给定前k个字母的模糊搜索时，只能检索到所有首字母等于给定的第1个字母的单词，而无法进行更后面k-1个字母的匹配，浪费信息量
作为前缀匹配的一个典型数据结构，我们可以观察一下trie树的设计思路：在trie树中，除根节点外的每个节点存储一个字母，每个从根节点到叶节点的路径上的所有节点存储的字母组合就是一个单词，每一个节点的子结点中，一个字母最多只能存在于一个节点中。

显然，对于大量的单词，trie树的度可能达到26，这会严重占用存储空间，尽管在前缀匹配上有着很高的性能，但是空间的开销是不能接受的。
借鉴trie树的思想，我们将目光放在度为2的红黑搜索树上，它进行搜索的原则是根据所定义的大小准则，小于当前节点值的放在该节点的左孩子上，大于当前节点值的放在右孩子上，并且它的前序遍历序列是所有节点值的递增排序，我们让红黑树每个节点存储一个单词。

这也正是单词之间的比较策略会是本道题的核心所在的原因。我们希望设计一个比较策略，它满足：对于两个不同单词，它们的值必定不同；对于两个前i个字母相同的单词，它们的值相近；对于两个第一个不同字母出现在第i个位置上的单词，它们的值随着i越小而变得差异越大，极端情况是第一个字母不同的单词之间的值截然不同

设计思路：给定一个上界质数值max，以及小于它的所有质数所组成的集合，在这个集合中从max开始沿着某一减量序列，取得n个质数值$a_1, a_2, \cdots , a_n$（n为单词的长度），作为第i个位置上的权重。然后对于长度为n的单词$[w_1w_2\cdots w_n]$，定义其大小为$W = \sum\limits_{i=1}^{n} a_i\times w_i$
这样构造出来的哈希函数的碰撞概率已经很小了，但为了进一步的安全措施，对于可能出现的$W_i == W_j$的单词，我们为节点新增一个指针域same，让后出现的单词所建立的节点与从树里搜索到的W值与其相同的单词节点相互勾连形成链表（拉链法），以避免恶意碰撞
（为了记录的方便，我们还维护一个sameNum用于记录链表中节点的总个数，以及一个布尔值isSame记录一个节点是否是某个树节点下的链表节点）

比较策略就按照W值的大小来进行大于、小于、等于的比较即可

通过这种方式，我们为每个单词都定义了一个节点值，并且保证了单词的唯一性，同时，单词值的差异性随着前缀字母的不同而增大，符合了我们的要求

单词的搜索：对于给定的单词，首先计算其哈希值，然后在树中寻找这个哈希值，如果没找到这个值，说明搜索失败；如果找到了这个值，但经过比对发现单词和给定单词不同，那么再沿着same指针域搜索，如果找到了给定单词的节点，将这个单词节点的元数据（包括词性，释义等）输出，并且将其加入一个长为10的队列（搜索的历史记录）

单词的删除：首先根据给定单词的哈希值找到这个节点，如果是链表中的节点，那么直接进行链表的删除即可；如果是same指针非空的树节点，那么将该节点的same链表下的第一个节点（树节点相当于是链表的头节点，这里指的是头节点后一个节点）的数据与其交换swap，然后删除尾部节点即可；如果是same指针为空的节点，按照红黑树的树节点删除方法直接删除它即可

单词的添加：将所输入的单词及元数据读取，创建一个节点，然后用它的哈希值在树中进行搜索，找到插入位置：如果没有哈希值相同的节点，插入树中，根据红黑树的性质进行平衡化或否；如果有哈希值相同的节点，利用头插法将其插入该树节点的链表中

单词的模糊搜索：
首先将前缀K的哈希值进行计算，设前缀长度为k
然后利用和“二叉树最近k个值”一题类似的思路，首先前序遍历整个二叉树，获得一个递增序列节点指针数组，然后记录值最接近给定前缀的哈希值的索引，从这个索引开始，利用两个迭代器，一个向前，一个向后移动，每到一个节点，检查它的前n个字母组成的子字符串是否等于给定前缀K，如果等于，就放入结果vector中；如果不等于，就把迭代器停在这个位置。
再检查其same指针域，如果非空，那么沿着链表节点也进行相同的搜索，如果搜到了也放进结果中，直到到达链表末尾。
以此类推，当两个迭代器都停止后，结果vector中就是所有相近的单词节点了

