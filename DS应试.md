
# C1. 线性表

顺序存储的线性表在中间插入或删除之后，目标位置后面的所有位置上的元素需要相应前移或后移，不需要整个数组进行重造拷贝
插入一个元素平均需要移动的元素个数是n/2


## 1.1 逆置操作（代码）

### 1.1.1 整体逆置

整体逆置中，带有头结点的链表逆置比较简单，从头结点开始，维护r和r->next，使用头插法将当前结点**插入头节点后面，头节点的`next`结点的前面**
```c
Node* current = head->next;
Node* next = NULL;
while(current != NULL) {
	next = current->next;
	current->next = (current == head->next) ? NULL : head->next;
	head->next = current;  //插入到原链表的head到head->next之间
	current = next;
}
```

不带头结点的链表逆置需要三个指针：
```c
if (L == NULL) return;
Node* goal;
Node* rear = L;
while (rear->next != NULL) {
	goal = rear->next;
	rear->next = goal->next;
	goal->next = L;
	L = goal;
}
```

### 1.1.2 部分逆置和分组逆置

部分逆置：给定一个链表中间结点的结点指针，将其前半或后半的所有元素进行逆置
对于后半元素，类似于含头结点链表的逆置，使用头插法，把后面的元素插入到索引结点和索引节点的`next`结点之间
设索引结点的指针为d，则有
```c
Node* current = d->next;
Node* next = NULL;
while(current != NULL) {
	next = current->next;
	current->next = (current == d->next) ? NULL : head->next;
	d->next = current;  //就是把head换成了d
	current = next;
}
```

对于前半元素，我们取索引结点的前一个元素（有`prev->next = d`）
把`prev`作为头节点，从前往后把元素插入到`prev`的后面，`d`前面一个结点的前面

分组逆置的非递归写法
每次控制一个左边界结点指针p，作为头插法的头，把后面的k-1个元素插入到`p`和原`p->next`之间，在循环内每次控制左边界结点指针移动：
```c
Node* p = L;//左边界指针
Node* raer = L->next;  //原p->next指针
for (int i = 1; i < k; i++) {  //每轮执行k-1次
	if (rear->next != nullptr) {
		Node* goal = rear->next;
		rear->next = goal->next;
		goal->next = p->next;
		p->next = goal;  //头插法
	}
	
	if (i == k-1) {
		i = 0;
		p = rear;  //每次更新左边界，rear是每组的最后一个结点
		rear = rear->next;
		if (rear == nullptr)  //如果每组后面没有结点了，就停止
			break;
	}
}
```


## 1.2 先找值，后操作

### 1.2.1 无序链表中删除所有（绝对值）相等元素

题目一般会给出“链表的结点个数n远大于链表元素的值”的条件，此时开一个大小为n+1的下标**范围为0到n的辅助数组val**，初始化为全0，val代表值或值的绝对值
当检测到一个值k时，将val\[k]=1，如果val\[k]已经为1，那么就把这个结点删除

### 1.2.2 无序链表找出第k大（小）的元素

`for (int i = 1; i <= k; i++)`，使用这样的循环，循环内使用寻找最大值的方法（双指针算法更新max指针），当`i != k`时，把本次找到的`max`指针元素置为0，因为这不是第k大的元素，不需要考虑它们；如果`i == k`，因为把表中比它大的元素全置0了，所以每次搜索最大值得到的max指针指向的元素就是第i大的元素，`i==k`时找到的就是第k大的元素，把它返回就行

### 1.2.3 无序链表统计表内最值的个数

维护一个`count`，按照求链表最大值结点指针的方法，当另一个指针遍历到的`ptr->data == max->data`，那么`count++`；如果`ptr->data > max->data`，那么更新`max`，并且把`count`重置回1；否则`ptr = ptr->next`移动指针


### 1.2.4 双指针问题
#### 找出两个链表中的公共结点

使用两个指针a和b分别从两个链表的首结点开始移动，比较两个指针指向结点的值：若一个指针A指向结点的值小于另一个指针B，该指针A就向前移动一个单位
当两个结点的大小相等，将其中任意一个指向的结点删除，并且
```c
Node* common(Linklist A, Linklist B) {
	if (A == NULL || B == NULL) return NULL;
	Linklist C = new Linklist();
	C->next = NULL; Node* rear = C;
	Node* a = A, *b = B;
	while (a != NULL && b != NULL) {
		if(a->next->data == b->next->data) {
			Node* goal = a->next;
			a->next = goal->next;  //把a链表中的这个结点分离，并且把a向前移动
			b = b->next;//移动b指针
			rear->next = goal;
			rear = goal;  //把从a中分离的结点插入到C链表中，尾插法
			
		}
		else if (a->next->data < b->next->data) a = a->next;
		else                                    b = b->next;
	}
	return C;
} 
```

#### 合并链表

- 两个链表中元素递增：两个指针指向两个递增链表，当一个**指针A小于另一个指针B**的值，将这个结点分离到另一个新链表C中，使用头插法或尾插法插入到链表里面，这个过程中**让A前进一个单位**
  合并完成的链表的单调性，通过插入链表采用**头插法**（插入到head和head->next之间，形成**递减序列**），还是尾插法（插入到最后一个元素后面，形成递增序列）来进行控制

- 两个链表中元素递减：和递增差不多，让两个指针中值比较大的那个前进，把结点连接到链表C中，头插法形成递减序列，尾插法形成递增序列
尾插法：类似于1.2.4的代码，维护一个`rear`指针，指向最新插入尾部的一个结点，每次插入让`rear->next = goal, rear = goal`即可

- 两个链表一个递增一个递减：对于单链表，必须逆置一个链表变成双递增或双递减；对于双链表或数组，将遍历方向反过来即可

### 1.2.5 快慢指针问题

#### 快速找到链表中点

从链表的第一个有效结点开始（头指针head->next），初始时两个指针`fast`和`slow`都指向该有效结点，快指针一次移动两个单位，慢指针一次只移动一个单位
这样移动下来，当`fast`指针为空时，`slow`指针**恰好在奇数个结点链表的中间结点，偶数个结点链表的中间两个结点的靠左结点**上
```c
while(fast != NULL && fast->next != NULL) {
	fast = fast->next->next;
	if (fast == NULL)  break;
	slow = slow->next;
}
slow = slow->next;  //如果要求找到偶数结点的靠右结点，那么还需要前进一步
```

#### 快速寻找链表的倒数第k个结点

`fast`指针和`slow`指针之间间隔k个结点，然后让两个指针一起移动，每次都是一个单位，当`fast->next == NULL`时，代表`fast`指向的就是链表的最后一个结点，此时`slow`指向的就是链表倒数第k个结点了
```c
while (fast->next != NULL) {
	fast = fast->next;
	count++;
	if (count == k)  break;
}  
if (count != k)  return -1;  //链表没有k个结点
 //先移动快指针k次，形成快慢指针之间k个间隔差

while(fast->next != NULL) {
	fast = fast->next;
	slow = slow->next;
}
```



# C2. 矩阵
## 2.1 矩阵的内存存储

记住：
二维数组`a[m][n]`表示有m个n维向量的数组，因此，**前面一个参数m代表矩阵的行号最大值（列向量的长度），后面一个参数n代表矩阵的列号最大值（行向量的长度）**

而元素`O[i][j]`表示矩阵中第i行，第j列的元素（i和j从0开始数）

所以，对于矩阵的**行优先存储：按照行号依次将行向量存储到连续内存中**
元素`O[i][j]`前面有i个行向量（因为是从0开始数的），而它这一行的前面有j个元素
因此：
$$ 内存地址Loc(i,j) = Loc(0,0)+(i*n+j)*M,\quad M是一个元素所占的内存大小$$

对于矩阵的**列优先存储：按照列号依次将列向量存储到连续内存中**
元素`O[i][j]`前面有j个列向量，它这一列前面有i个元素，因此：
$$ 内存地址Loc(i,j) = Loc(0,0)+(j*m+i)*M,\quad M是一个元素所占的内存大小$$


## 2.2 稀疏矩阵的快速转置

稀疏矩阵中，每一个非零元素都使用`(row, col, value)`三元组表示，按照**行优先（元素按`row`递增顺序排列）** 的顺序存储在表格A中

对于这样一个矩阵A，我们希望进行转置：将行和列进行交换。最简单的做法是通过扫描整个矩阵，`b[col][row]=a[row][col]`，直接交换，但是对于稀疏矩阵来说零元素太多，开销较大

快速转置的思想是：因为稀疏矩阵的表格存储中相同行号的三元组排列在一起，不同行号之间递增，因此我们只需要额外获得：每一列（每个不同行号的列）中非零元素的个数，以及其开始存储位置（在表格A中的位置），就能确定每一列的所有元素在A中的位置了

因此，建立辅助数组`rowsize`，使`rowsize[i]`表示行号为`i`的（也就是第`i`列）元素的个数；另一个辅助数组`rowstart`，使`rowstart[i]`表示第`i`列元素在表格A中的起始索引（第一个元素的存放位置）

有了这两个辅助数组后，因为转置后A的列元素变为B的行元素，所以B按照`col`递增的顺序，在`rowsize`和`rowstart`数组中找到`col`索引的元素，按照元素的索引在A中找到相应元素，放进三元组表格B中，完成转置即可

# C3. 栈和队列

## 3.1 使用栈将（中缀）表达式转为后缀表达式

**对于每一个数值，直接将其输入到后缀表达式中；对于每一个运算，将其加入操作栈，进行下面的判断**：
- 如果栈为空，或栈顶是左括号 `(`，则直接入栈。
- 如果==**栈顶==运算符优先级==小于==当前运算符**，则当前运算符**入栈**。
- 如果==**栈顶==运算符优先级==大于==或等于当前运算符**，**将栈顶运算符弹出并输出**，继续比较，直到栈顶优先级低于当前运算符，再将当前运算符入栈
- 遇到右括号`)`，将栈顶元素持续输出，直到遇到左括号

## 3.2 双栈模拟队列

使用两个栈`stack1`和`stack2`，前者按照输入的顺序存储元素，后者按照输入相反的顺序存储元素，因为栈先进后出，把原输入顺序颠倒过来，按照栈的性质输出，就是先进先出，即队列的性质

因此，入队时，只需要把元素直接加入`stack1`即可，而出队时，则需要：
- 若`stack2`为空，先把元素从`stack1`弹出，并弹入`stack2`，再从`stack2`中弹出栈顶元素
- 若`stack2`不空，直接弹出栈顶元素即可
这样就满足队列先进先出的要求了
**出队开销大，入队开销小**

## 3.3 双队列模拟栈

使用两个队列`queue1`和`queue2`，`queue1`用于按输入顺序存储元素。因为队列先进先出，我们需要构建一个元素顺序和输入顺序相反的队列，才能确保先进后出的栈性质

因此，通过下面的方式完成：
入栈：
- 将新元素插入 `queue2`。
- 将 `queue1` 中的**所有元素依次出队并插入**到 `queue2`，**使得新元素成为 `queue2` 的队首**。
- **交换 `queue1` 和 `queue2` 的角色**。

出栈：
- 直接从`queue1`中出队一个元素即可

可以看到`queue2`实际上就是一个临时存储元素的队列
**入栈开销大，出栈开销小**


## 3.4 循环队列

普通的数组实现队列，通过修改头指针索引和尾指针索引的改变进行出队和入队，但是这会导致数组中一些位置被标记为删除却没有完全释放，会导致假溢出情况。对其采用“出队列时把后面的元素向前移动一格”或者“入队列时若发生假溢出，将每个元素向前移动”这样的优化，都会导致时间开销O(n)

因此，提出**循环队列：数组的首尾通过逻辑连接形成一个==环形结构==。队列的尾部可以连接到数组的头部，从而实现空间的循环利用**

其实现方法是：使用指针`front`和`rear`:
`front`指向**队列中第一个元素的下一个位置（首前指针）** ，`rear`指向队列中的最后一个元素
两个指针的计算采用取模：初始时，`front = rear = 0`

设队列顺时针为增长方向，那么front就是在第一个元素按逆时针向后移动一个位置的位置，设整个数组长为`Maxsize`，索引为0到`Maxsize - 1`（队长小于数组长）

入队操作在尾部进行：将尾指针向增长方向（顺时针）移动一个位置，如果`rear`原本就等于`Maxsize-1`，也就是数组的最后一个位置，那么应该回到数组的第一个位置`0`，因此有：

$$ rear = (rear + 1)\mod Maxsize$$


同理，出队操作在首前进行：`front`所指向的位置向增长方向（顺时针）移动一个距离，如果是数组的0位置，那么会跳转到数组的`Maxsize-1`位置，依然取模即可：
$$ front = (front+1)\mod Maxsize$$


循环队列的队满情况，因为这种实现**保持`front`指针所指向的位置是一个空位置，不存储任何元素**，所以我们简单地通过：
$$ (rear + 1)\mod Maxsize == front$$
就可以知道队满
而队空的情况则是$rear == front$

当我们**不牺牲`front`这个位置的空间**，那么对于**循环队列的队空和队满情况，都会有`rear == front`**，因此我们需要**设立一个标志`bool isFull`来区分`rear==front`时是什么情况**
这个**标志位随着入队和出队操作更新**：
初始时，`isFull = false`
入队前，若`isFull = true`，那么入队失败；若入队后计算得到的尾指针`rear == front`，那么令`isFull = true`
出队时，必定有`isFull = false`，因此**每次出队都把`isFull`设置为`false`**

那么队空就是`rear = front && !isFull`，队满就是`isFull`

## 3.5 栈实现递归

核心思想：每次循环，栈存储处理对象的状态——我们沿着递归顺序，向栈中存储

# C4. 树

## 4.1 二叉树的数学性质

1. 包含n（n>0）个元素的二叉树边数为n-1

2. **一棵非空二叉树的第i层上，至多有$2^{i-1}$个结点**

3. 深度为k的二叉树至少有k个结点，至多有$2^{k}-1$个结点

4. 一棵非空二叉树，设其叶节点个数为$n_0$，度为2的结点个数为$n_2$，那么有$n_0=n_2+1$

5. **完全二叉树**除了最后一层之外，**到前面第i层为止，所有的结点数为$2^i-1$**

性质4的推导是通过**结点的总个数$n=2n_2+n_1+1=n_0+n_1+n_2$这个恒等式得到的**，类似的做法也可以推广到其他度的树中：

已知一棵度为3的树中，$n_3=2,n_2=1$，求$n_0$
根据总结点数=分支数=所有度的结点之和，有
$$ \begin{align}
n_3+n_2+n_1+n_0 &= 3n_3+2n_2+n_1\\
n_0+2+n_1&=3\times 2+2\times1+n_1\\
n_0&=6+2-2\\
&=6
\end{align}$$
满二叉树：高度为h，且有$2^h-1$个结点的二叉树

完全二叉树：高度为h，有n个节点的二叉树，当且仅当其每一个节点都与高度为h的满二叉树中编号从1至n的节点一一对应

6. 具有n个结点的**完全二叉树**的深度为$\log_2(n+1)$，这也是包含n个结点的二叉树的最小深度

7. 将一个具有n个结点的完全二叉树自顶向下，自左向右将节点从1到n编号，那么有下列性质：
   1. 若`i=1`，则为根节点，没有双亲；若`i>1`，那么其双亲结点编号为$\lfloor \frac{i}{2} \rfloor$
   2. 若`2i > n`，则该结点**没有左孩子**；否则，其左孩子编号为`2i`
   3. 若`2i+1 > n`，则该结点**没有右孩子**；否则，其右孩子编号为`2i+1`
   4. 若i为奇数，则其左兄弟编号为`i-1`（`i != i`）
   5. 若i为偶数，则其右兄弟编号为`i+1`（`i != n`）
   6. 编号为i的结点所在层数为$\lfloor \log_2i\rfloor +1$

因此，**完全二叉树适合使用数组来顺序存储，但一般的二叉树会产生很多无用空间，并不适合顺序存储**


## 4.2 二叉树的链式存储

![[Pasted image 20241217104303.png]]

称为二叉链表

性质：
- 含有n个结点的二叉链表中，共有n+1个空指针（指针域有2n个，分支有n-1个，那么空指针域就有2n-(n-1)=n+1个）

三叉链表：每个结点增加一个指向双亲的指针parent，使得查找双亲也很方便
![[Pasted image 20241217105740.png]]

## 4.3 二叉树的遍历

- 前序遍历序列：根-左-右，序列第一个元素必定是整棵树的根节点，后面的n-1个元素中，首先是左子树：根结点的左孩子，以及以它为根的子树；然后是右子树：根结点的右孩子，以及以它为根的子树。以此类推

- 中序遍历序列：左-根-右，序列中间的元素是整棵树的根结点，它左边的所有元素是左子树，这个子序列又是一个左子树-根-右子树的结构；同理，右边的所有元素是右子树，该子序列依然是左-根-右结构

- 后序遍历序列：左-右-根，实际上就是前序遍历序列略微相反，先是左子树序列：以左孩子为根的子树元素-左孩子-右子树序列-右孩子-根，这个顺序

- **已知前+中或中+后，可以唯一确定一棵子树；只知道前+后，则不可确定**

1）根据前序遍历的定义：前序序列的第一个元素必为二叉树的根节点；
      根据中序遍历的定义：中序序列的根节点恰为左右子树的中序序列的分界点；根节点前的子序列为左子树的中序序列；根节点后的子序列为右子树的中序序列；
（2）根据左子树的中序序列的节点个数，在前序序列中找出左子树的前序序列，剩下的即为右子树的前序序列；
（3）然后用相同的办法分别找出左、右子树的根及其左右子树的前序序列和中序序列；
是一个递归的过程


确定前序遍历序列， 找有多少种二叉树的形态的过程，就是找有多少个不同的中序序列的过程
对于一棵二叉树，**中序遍历**的特点是：

- 首先访问左子树，
- 然后访问根节点，
- 最后访问右子树。

而通过栈来模拟中序遍历的过程，实际上就是找到所有**栈的合法进栈和出栈序列**。

1. 每个节点必须先“进栈”，然后才能“出栈”。
2. 出栈的顺序（中序遍历）必须是合法的栈操作

栈的操作：
- 每个节点从编号1到n，必须按照前序遍历的顺序进入栈中。
- 每次可以选择“进栈”或者“出栈”：
    - **进栈**：按照前序遍历顺序，将下一个节点压入栈。
    - **出栈**：栈非空时，弹出栈顶元素，加入到中序遍历的结果中

总的数量是**卡特兰数：**
对于n个节点的二叉树，满足以下递推关系的卡特兰数 CnC_nCn​ 给出二叉树的数量：

$$C_n = \frac{1}{n+1} \cdot \binom{2n}{n} = \frac{(2n)!}{(n+1)! \cdot n!}$$

其中：
- Cn​表示n个节点的不同二叉树的个数。
- 也等价于n个节点的进栈和出栈的合法序列数量。

## 4.4 树与森林

### 4.4.1 树的存储表示
- 孩子表示法：用一组连续的存储空间（一维数组）存储树中的各结点，同时在每个结点中附设一个指示器，**指示其双亲结点在数组中的序号**
  查找双亲结点效率高，查找孩子结点效率低
  可以改进为：每个结点**额外记录其第一个孩子结点以及第一个兄弟结点的序号**

- 将孩子表示法改进为使用**多重链表**的形式：
  每个结点可能有零或多个孩子结点，因此链表中，每个结点应该有一个数据域储存自身的数据，以及多个指针域，指向孩子结点，指针域个数等于结点的度数，当结点之间度数差异不大时，可以使其值为树的度数（所有结点度数的最大值）来静态存储；本质上是邻接链表
  该方法查找孩子结点的复杂度为O(d)，d为结点度数，效率较高；但是查找父结点效率不佳，O(N)

- 双亲-孩子表示法：用**一维数组**顺序存储树中的各结点，将各结点的**孩子结点分别组成单链表**，**数组中的各个结点有一个数据域存储该结点的双亲结点在一维数组中的索引**；本质上还是邻接链表

- 孩子-兄弟表示法：链表中的每个结点有一个信息域和两个指针域，其中指针域指向**第一个孩子结点和下一个兄弟结点**
  在这样表示的树中遍历，就相当于层序遍历：沿着兄弟结点指针域遍历，就是找这一层中从这个结点开始的所有兄弟结点；沿着孩子结点指针域遍历，就是往深度增加的单一方向搜索
  **从根节点的指针域的孩子域往下搜索，随后沿兄弟域搜索，就是找特定层数的所有结点了**
  优点：查找孩子节点的时间复杂度O(d)
	其中，d为树的度, n为树中结点个数
	 缺点：查找父节点的时间复杂度O(n)


### 4.4.2 树转换为二叉树

给定一棵树，可以找到**唯一的一棵二叉树与之对应**。
![[Pasted image 20241217114708.png]]
使用**孩子-兄弟表示法**：
1)凡是兄弟就用线连接起来
2)对每个非叶子结点，除其最左孩子外，删去该结点与其他孩子结点的连线（只找每个结点的最左边第一个孩子）
3)以根结点为轴心，顺时针旋转450

### 4.4.3 森林转换为二叉树

把森林的每棵树的每个结点，按照层号依次排序，层号相同的视为兄弟，然后使用孩子兄弟表示法转换为二叉树即可

## 4.5 树的先根和后根次序遍历

也就是对于每个结点，先遍历所有的孩子，再遍历这个结点本身（后根）；或是先遍历结点本身，再遍历所有孩子（先根）

## 4.6 结论


# C5. 堆

完全二叉树适合使用静态数组存储，因此基于完全二叉树的堆也是使用一维静态数组存储的
二叉树的特性7：
7. 将一个具有n个结点的完全二叉树自顶向下，自左向右将节点从1到n编号，那么有下列性质：
   1. 若`i=1`，则为根节点，没有双亲；若`i>1`，那么其双亲结点编号为$\lfloor \frac{i}{2} \rfloor$
   2. 若`2i > n`，则该结点**没有左孩子**；否则，其左孩子编号为`2i`
   3. 若`2i+1 > n`，则该结点**没有右孩子**；否则，其右孩子编号为`2i+1`
   4. 若i为奇数，则其左兄弟编号为`i-1`（`i != i`）
   5. 若i为偶数，则其右兄弟编号为`i+1`（`i != n`）
   6. 编号为i的结点所在层数为$\lfloor \log_2i\rfloor +1$

堆的含义可以理解为：在完全二叉树中**任何非终端节点的值均不大于（或小于）其左、右孩子节点的值**。

## 5.1 向上调整和向下调整

现在我们来看维护规则的处理。在二叉堆中：
- 如果**子节点键值大于父节点的键值**，那么这个子节点就需要**向上调整**，即**将子节点的键值与父节点的键值交换**，直到满足父节点比子节点键值大为止

- 如果**父节点的键值小于子节点的键值**，那么这个父节点就需要**向下调整**，也就是**将父节点和两个子节点中键值更大的那个进行交换**，直到都满足二叉堆的键值为止


上移和下调操作都是$\log_2 N$的数量级别的

## 5.2 堆的插入

插入堆时，我们往数组的后一个位置插入，也就是在完全二叉树的最后一层中从左往右的方向插入一个结点
插入的结点可能破坏堆的结构
- 最小堆中，新插入的结点可能会出现结点小于其双亲结点的情况，因此**向上调整**：
  如果节点i的值小于其双亲节点(i-1)/2的值，则交换两节点，并使i指向其双亲节点，继续向上调整，直到i=0（i为根节点）或者节点i的值大于其双亲节点的值为止

## 5.3 堆的删除

从堆中**删除根节点**，也会导致堆的结构改变，因此需要进行调整
从最小堆中删除具有最小值的元素：
 （1）将最小堆的**堆顶元素（即根节点）删去**；
 （2）把堆的**最后一个元素节点移到堆顶**；
 （3）堆的当前元素个数减1；
 （4）调用siftDown( )函数,从堆顶**向下调整**成堆。

# C6. 哈夫曼树

## 6.1 编码树

顶点到左节点的边记为0，到右节点的边记为1，每个叶结点按照根节点到它的路径进行编码

## 6.2 带权路径长度

节点的带权路径长度：从该节点到树根之间的**路径长度**与**节点上权**的**乘积**

二叉树的带权路径长度（**WPL**）：树中**所有叶子节点的带权路径长度之和**

**具有最小带权路径长度的二叉树**，称为哈夫曼树，也叫做最优二叉树

哈夫曼树的特性：
	**权值越大**的叶节点离根**越近**；
	**权值越小**的叶节点离根**越远**

构造方法：
在F中选取根节点的权值**最小和次小的两棵二叉树**作为左右子树构造一棵新的二叉树。这棵新的二叉树的根节点的**权值为其左右子树根节点权值之和**
在集合F中删除作为左右子树的两棵二叉树，并将新建的二叉树加入到集合F中
以此类推，直到只剩下一棵二叉树

## 6.3 前缀编码

较短的编码中，每条编码都**不会是较长编码的前缀**（**任意一个字符的编码都不是另一个字符的编码的前缀**）

利用二叉树和哈夫曼编码方法，就可以构造出“频率越高的元素编码越短”的哈夫曼前缀编码

# C7. 搜索和散列

**平均搜索长度**ASL (Average Search Length)：
设搜索第 i 个元素的概率为 pi（pi之和为1）， 搜索到第 i 个元素**所需比较次数**为 ci, 则搜索成功的平均搜索长度
$$ ASL_{succ}=\sum\limits_{i=1}^{n}p_i\cdot c_i$$
## 7.1 散列（哈希）

进行搜索时，最理想的方法是根据关键字值，**直接找到记录的存储地址**，而不需要把待查关键字与候选记录集合的某些记录进行逐个的比较

散列的主要思想就是**根据记录的关键字值确定其存储地址**：以关键字值K为自变量，通过一定的函数关系Hash(K)（**散列函数**）计算出**对应的函数值——记录的存储地址**，将记录的关键字和属性数据一起存入到此存储地址中

检索时，用同样的方法计算地址，然后对应到相应的单元中取出要找的记录

散列的冲突：**把不同的关键字映射到同一个散列地址上**
冲突现象是**不可避免**的，但仍希望找到尽可能产生均匀映射的散列函数，从而尽可能降低发生冲突的概率；
当冲突发生时，还必须有相应的解决冲突的方法

### 7.1.1 常用的散列函数

除留余数法：
$$ hash(key)=key\mod D$$
其中D是选取的超参数值

【一般选取方法】设散列表中允许的地址数为 m， 取一个**不大于 m，但最接近于或等于 m 的质数D，且质数D不是接近2的幂**

散列函数作用后的地址范围为0到D

平方取中法：
一般取散列地址为2的某次幂，先计算出关键字key的平方值key2，然后取key2值的中间若干位作为其散列地址，即
$$  hash(key)=“key^2的中间几位”$$

所取的位数取决于散列表的表长：表长$10^k$时，取k位
**平方取中法最接近于随机化**

### 7.1.2 解决冲突的方法

#### 1. 闭散列方法

把发生冲突的关键字**存储在表的另一个位置**中
【基本思想】在发生冲突时，按照某种方法继续**探测基本表中的其他存储单元**，直到**找到空位置**为止

首先，计算出它的直接散列地址H（k），
 若该单元已被其他数据元素占用，继续查看地址为H（k）+d1的单元
 若也被占用，再继续查看地址为H（k）+d2的单元，
 如此下去，当发现某个单元为空时，将关键字为K的数据元素存放到该单元中

$$ H_i(k)=(H(k)+d_i)\mod m,\quad m为散列表的表长$$
![[Pasted image 20241217134955.png]]



#### 2. 开散列方法

把发生冲突的关键字存储在**散列表主表之外**

设基本散列表为A\[m]，
      将所有具有**相同散列地址**的**数据元素放在同一单链表中**，
      散列表中的第i个元素A\[i]存放**散列地址为i的数据元素组成的单链表的头指针**

### 7.1.3 衡量散列方法的指标

#### 搜索成功的平均次数

代表着搜索到**表中已有元素**的平均查找次数，也就是**按照哈希值搜索每个元素，从开始搜索到找到这个元素，所需要的比较次数**
![[Pasted image 20241217135800.png]]
**分母是元素的个数，Ci是每次搜索到表中给定元素所需要的比较次数**

#### 搜索不成功的比较次数

**基于整个表长（在除留余数法中就是那个参数D）**，对**表中的每一个位置**进行检查：如果**这个位置为空，那么检查结束**；如果**这个位置上有值，那么向后探测，直到找到空位置为止**

这个过程中的比较次数之和，**除以整个表长**，就是搜索不成功的比较次数
以上面的例子来看：
![[Pasted image 20241217140141.png]]

**对于二次探测等探测方法，虽然有效值的分布不同，但是搜索都还是按照线性探测一个个往后找的方法进行，找到最后一个位置后，下一次搜索跳回整个表格的第一个位置**


## 7.2 搜索结构

静态搜索表：搜索结构在**插入和删除**等操作的**前后不发生改变**
动态搜索表：搜索结构在执行**插入和删除**等操作的前后将**自动进行调整，结构可能发生变化**

静态查找
    仅作查询和检索操作的查找表，常用方法：
  顺序查找：无序表、有序表
  折半查找：有序表
  分块查找：索引顺序表
 动态查找
  在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已存在的某个数据元素。
 哈希查找
  又叫散列查找，利用哈希函数进行查找的过程

### 7.2.1 平均搜索长度ASL

**平均搜索长度**ASL (Average Search Length)：
设搜索第 i 个元素的概率为 pi（pi之和为1）， 搜索到第 i 个元素**所需比较次数**为 ci, 则搜索成功的平均搜索长度
$$ ASL_{succ}=\sum\limits_{i=1}^{n}p_i\cdot c_i$$
和哈希表中的ASL一样去理解：
搜索成功时的ASL：分子是对于每个元素，在该搜索结构中能找到它所需的比较次数；分母是元素个数

搜索不成功时的ASL：分子是对于搜索结构中的**每个空位置**，从**起始位置出发**，直到**寻找到这个空位置所需的比较次数**；分母是所遍历的搜索结构的长度(位置的个数)（一般是有值的结点个数+1，1代表空位置结点）

### 7.2.2 顺序搜索

设数据表中有 n 个元素，搜索第 i 个元素的概率为 pi，搜索到第 i 个元素所需比较次数为 ci，则搜索成功的平均搜索长度
![[Pasted image 20241217142834.png]]



有序顺序表（判定树）
![[Pasted image 20241217143016.png]]


# C8. 搜索树

## 8.1 二叉搜索树BST

每个结点都有一个作为搜索依据的关键码(key)，所有结点的关键码互不相同，都是唯一的
左子树（如果非空）上所有结点的关键码都小于根结点的关键码。
右子树（如果非空）上所有结点的关键码都大于根结点的关键码。
左子树和右子树也是二叉搜索树

**BST的中序遍历序列是所有结点的单增序列**

### 8.1.1 删除

- 最值结点：对于最小结点的删除，我们知道它肯定在最左边，我们**只需要一直向结点的左儿子移动，直到遇到左儿子为空的结点，然后将最值结点的父节点的左儿子替换为最值结点的右儿子，再删去最值结点即可**

- 叶子结点：直接删掉即可，将父结点的相应指针域置为0

- 当该结点只有左子树或右子树：将它的唯一一个儿子**与它的父节点相连（连在该结点原来所在的那一侧）**，删除该结点即可；如果是根节点，直接让儿子作为根结点即可

- 同时有两个子树（左儿子和右儿子）：找到**该结点右子树中的最小节点，或左子树的最大结点**，然后将这个结点的键值与我们想删除的结点键值互换，然后使用删除单孩子结点的方式删除掉它即可

可以看到，删除度2结点的操作具有不平衡性，这也是BST容易退化，出现极端情况性能退化的原因

## 8.2 AVL平衡搜索树

### 8.2.1 平衡因子

每个结点的平衡因子就是该结点**右子树**的高度**减去左子树的高度**所得的高度差
**当平衡因子的绝对值大于1时，就发生了不平衡，需要旋转使其平衡**

从发生不平衡的结点开始，沿着回溯的路径取下面两层的结点，这三个结点进行平衡化旋转

如果这三个节点处于**一条直线**上，则采用**单旋转**进行平衡化。
如果这三个节点处于**一条折线**上，则采用**双旋转**进行平衡化
![[Pasted image 20241217153615.png]]
### 8.2.2 左旋和右旋

左旋：发生失衡的结点的**平衡因子为-2**，**将该结点旋转到它==右孩子==的==左孩子==位置，如果它下一层的结点已经有了左孩子，那么让这个左孩子变成发生失衡结点旋转后的右孩子**
（冲突左孩变右孩）

右旋：发生失衡的结点的**平衡因子为2**，**将该结点变为它==左孩子==的==右孩子==位置，如果已经有了右孩子，那么让这个孩子变成转下来的结点的左孩子***、
（冲突右孩变左孩）

记忆：左旋-2变右孩左，右旋+2变左孩右


### 8.2.2 单旋转情况
#### LL（记忆：向左直线）
插入结点在 C 的**左子树的左子树**上，使 C 的平衡因子从 -1 增加 至 **-2**
而其左孩子的平衡因子是-1，此时三个点形成了**一条向左的线段**
**失衡结点与其左孩子的平衡因子都小于0**

此时进行**右旋：把失衡结点变成其左孩子的右孩子**

![[Pasted image 20241217154102.png]]
#### RR（记忆：向右直线）

插入结点在 C 的**左子树的左子树**上，使 C 的平衡因子从 1 增加 至 **2**
而其右孩子的平衡因子是1，此时三个点形成了**一条向右的线段**
**失衡结点与其右孩子的平衡因子都大于0**

此时进行**左旋：把失衡节点变为其右孩子的左孩子**
![[Pasted image 20241217154236.png]]

### 8.2.3 双旋转情况

#### LR（记忆：三个点连线先往左后往右）
若在 C 的左子树的右子树上插入结点，使 C 的平衡因子从 -1 增加 至 -2
也就是说**失衡结点平衡因子-2，左孩子平衡因子为1**

此时**先对失衡结点的左孩子使用左旋，然后再整体右旋**：
![[Pasted image 20241217155036.png]]

第一步使用左旋后，就变成了LL的情况了

#### RL（记忆：三个点连线先往右后往左）
C的平衡因子为2，但其右孩子的平衡因子为-1
**失衡结点平衡因子2，右孩子平衡因子-1**

此时**先对右孩子使用右旋，然后整体左旋**
![[Pasted image 20241217155324.png]]
第一步使用右旋后，就变成RR的情况了

# C9. 排序

## 4.2 选择排序
第一个基本排序思想很简单：**在第i次迭代中，我们在数组剩下的项中找到最小的，然后把它和剩下的项中的第一项进行交换**

## 4.3 插入排序
插入排序依然是进行索引i从左到右的扫描，不同的是在第i次迭代中，**确保i当前与左侧的项是递增的**，每次从i开始往左前进，设迭代器为j，对于不满足递增关系的a\[j]，我们将a\[j]移动至其左边一个的位置

## 4.3 希尔排序
希尔排序的出发点是**插入排序效率低下的原因是每个元素每次只向前移动一个位置**，我们每次如果将元素进行若干次排序（**称为对数组的h-排序，任意间隔为 h 的==元素对==之间已经按照升序（或降序）排列**），那么算法就能进行优化
我们称**一个具有h个交叉的有序子 另一个问题是对于希尔排序，应该使用何种递减序列？ 序列的递减方式是一个研究了很久的课题，我们只能提出一个性能不错的，但不知道它是否是最好的
我们采用$3x+1$的增量序列：首先找到一个范围内的满足该形式的最大增量，这里我们取最大增量$h_{max}\leq \frac{N}{3}$，让h从1开始，通过`h = 3*h + 1`达到最接近$h_{max}$的位置：


快速排序广泛用于多种系统中作为默认的排序算法，它也是一种递归算法，和归并排序不同，它的基本思想是在排序后进行递归，而归并排序是在排序之前递归
快速排序也基于分治思想，我们先介绍一种**随机快速排序**：它首先**对整个数组进行洗牌**，这一步后面再说；
然后进行数组a的分割：任意选择一个值K，将其移动到位置j，K也就是$a[j]$的值，保证它：
- 在j的左侧没有比$a[j]$更大的数
- 在j的右侧没有比$a[j]$更小的数
依据j位置上的点进行区间的一分为二，对于两个区间也进行这样的选点->排序工作（**后续不需要洗牌**），最后递归排序完成整个数组的排序
因为我们对整个数组先进行了一步洗牌，那么**随机取的值K只需要取第一个位置上的值就可以**了
有些实现中，在下面的交换过程随着每次找到小于等于选定值的数时，维护一个**分割位置++** 的操作，用于确定最后的值K应该在的位置（为小于等于K的元素空出空间）


判断一个序列经过某种排序第N趟后是什么样子：
- 起泡排序：前N个是所有元素中最小的，且后N个是所有元素中最大的
- 插入：第一一趟前两个有序，第二趟前三个有序，第N趟前N+1个有序
- 选择：前N个是最小的
- 归并：第一趟两两之间有序；第二趟四四之间有序，以此类推
- 快排：相邻两个子部分集合之间大小关系一定（右边集合每个元素比左边集合大）

