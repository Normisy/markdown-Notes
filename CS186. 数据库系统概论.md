
数据库就是数据的集合，由**数据库管理系统DBMS**作为上层管理软件进行管理，这些组件可以是紧密耦合或松散联系的。
最常见的数据库系统是**关系型数据库系统RDBMS**，包括Oracle或MySQL等产品，通常支持SQL作为数据描述和操作的标准语言
关系型数据库通常支持所谓的**事务一致性ACID**，这是一种**描述数据库如何保证数据在应用程序开发者可以理解的方式下保持一致性的方法**；并且支持持久性写入和恢复机制

类似于Hadoop、Spark、Flink和NoSQL这样的系统也在发展中，它们和本课程前期的知识内容实际上没有太大关联，是对其他核心技术的不同包装和部署方式，这在课程后期也会学到
许多公司将其数据库转移到公共云平台上，而不是传统的本地部署，其中NoSQL的比例要远远高于关系型数据库，云计算正在以很快的速度颠覆传统的数据库系统

值得注意的是，一种数据库管理系统并不能覆盖所有的业务场景，我们需要为实际问题选择一个合适的软件和系统，例如时间序列数据DBMS和图DBMS等特殊用途数据库管理系统

数据库系统日新月异，我们需要理解的是它们的可重用理念和组件，然后将其构建组合为不同类型的系统，或使用现有的软件工具，包括使用SQL语言进行**声明式编程：只需说明你想要什么，不必说明如何获取它们**、相关算法和架构等

本课程使用的开源数据库系统是PostgreSQL，并且使用java实现各种算法和协议等

# Chapter 1. SQL

SQL的一个特性是它是一种声明式语言，用户将需要的内容输入，但无需在意是如何进行获取和计算的，**将计算的决定权全部交给数据库系统**。所以它是一种非常高层次的语言，使用它进行查询是很简单的
SQL的目的并不是成为一个完整全面的编程语言，它并不适合用来编写算法的实现等工作，而是更倾向于以一种操作和查询数据的方式被使用
它另一个特定是**可扩展性：你可以在SQL查询中使用传统的编程语言，例如Python和C**

## 1.1 相关术语

- 数据库：它是一组**被命名的关系**，通常被绘制成一个具有多张“表格”的“罐子”
- 关系：相当于“表格”，它包含两个部分：
  - 模式：是对关系的描述，有时也称为关系的元数据（类似于表格最上面一栏的名称）
  - 实例：当前满足模式的数据库中的实际数据
- 属性：有时也称为**关系表格的列或字段**，是一列拥有模式和实例的数据
- 元组：有时也称为**记录或行**，是表格中的一行数据

需要注意的是：
- 在关系表格中，**模式是固定的：尽管它可以被改变，但是通常不会经常被改变**（可以增加或删除一列数据，但并不常见）
- 模式具有**唯一的属性名称**，每一列都有**不同的名称**，并且**所有列的数据类型都是原子的：它们是不可再分割的数据类型**，因此不能是集合或列表类型，**列名也不可以相同**
- 实例，即**在任何给定时间实际存在于表格中的数据**，会经常发生改变（我们经常插入或删除行）
- 在SQL的关系模型中，一个关系包含一个**行的多集：是一个可以包含重复相等的行的集合**

## 1.2 SQL语言

SQL实际上包含两个子语言，
- 第一个语言被称为**DDL：数据定义语言**，它用于**操作模式、定义模式和修改模式**
- 第二个语言是**DML：数据操作语言**，它用于操作实例，即数据库中的实际数据，包括查询、插入、删除和更新这些数据

关系数据库管理系统RDBMS负责高效地评估SQL：对于语言中的声明性语句，RDBMS选择并运行对应的算法，但任何给定时刻的算法选择不影响查询结果（数据库使用多种方式实现输入的查询，必须得到相同且正确的答案）

### 1.2.1 DDL

下面介绍用于创建数据库的DDL语言
#### 创建
一个创建表格的例子如下：
```sql
CREATE TABLE Sailors (
	sid INTEGER,
	sname CHAR(20),
	rating INTEGER,
	age FLOAT
)
```
这里在`CREATE TABLE` 关键字后写出表名，括号内列出每一个属性的名字及其类型
特别注意的是`sname`的类型，它是一个宽度为20的字符型，也就是最高可容纳20个字符的字符串

#### 指定主键
在列名和类型列表之后，往往需要使用`PRIMARY KEY`指定一个主键：
```sql
CREATE TABLE Sailors (
	sid INTEGER,
	sname CHAR(20),
	rating INTEGER,
	age FLOAT,
	PRIMARY KEY (sid)
);
```
主键可以是一列，或一组列，它为关系提供了唯一的查找键，在上面这种情况下，我们可以认为水手表中的sid列是整个表的唯一查找键，通过它可以定位特定的行。因此，**主键列中不能有重复的值，主键列组中不能有两个各分量完全相同的集合**

```sql
CREATE TABLE Reserves (
	sid INTEGER,
	bid INTEGER,
	day DATE,
	PRIMARY KEY (sid, bid, day)
);
```

#### 指定外键
可以将外键视为模式中的指针：
```sql
CREATE TABLE Reserves (
	sid INTEGER,
	bid INTEGER,
	day DATE,
	PRIMARY KEY (sid, bid, day), 
	FOREIGN KEY (sid)
		REFERENCES Sailors
);
```
这里我们说`Resevers`拥有一个外键`sid`，这一列成为一个指向（REFERENCES）`Sailors`表的指针，如果在`Reverses`的`sid`列中有一个值，那么**这个值是对`Sailors`表的主键中的一个值的引用**

在插入数据时，如果尝试在 `Reserves` 表中插入一个 `sid`，而这个 `sid` 不在 `Sailors` 表的主键列中存在，数据库系统会**拒绝这次插入**。
通过这种方式，确保了`Reverses`表中的每一条记录都会关联到一个有效的`Sailors`表中的记录，确保了数据的一致性

当然，一个表格内可以指定多个属性为不同其他表格的外键
```sql
CREATE TABLE Reserves (
	sid INTEGER,
	bid INTEGER,
	day DATE,
	PRIMARY KEY (sid, bid, day), 
	FOREIGN KEY (sid)
		REFERENCES Sailors,
	FOREIGN KEY (bid)
		REFERENCES Boats
);
```

### 1.2.2 基本单表的查询模式

一般地，SQL中的基本单表的查询模式如下，它执行获取表中所有满足查询谓词的元组
这是SQL中执行的最简单的查询类型：
```sql
SELECT [DISTINCT] <column expression list>
	FROM <single table>
[WHERE <predicate>]
```
其中，方括号都是可选项：
- `<single table>`是希望从中获取元组的指定的单表的名字 
- `<column expression list>`定义了从你指定的表中输出的元组中，取它们的哪些列或列经过表达式得到的结果
- `WHERE` 关键字用于筛选行：将所有满足谓词`<predicate>`的行筛选出来。谓词是一个评估真假的真值函数
- 加上关键字`DISTINCT`后，该关键字指定了在将输出发送给客户端之前（屏幕或浏览器等），应该**在得到输出之前移除重复的行**

```sql
SELECT DISTINCT S.name, S.gpa
	FROM students S
WHERE S.dept = 'CS'
```
这个例子获取了一个名字-绩点对，其中`FROM students S`是为学生表起的别名，相当于使用了`AS`关键字，用S这个名字代替student

除了去重以外，我们还可以在输出时对结果进行排序：
```sql
SELECT DISTINCT S.name, S.gpa, S.age*2 AS a2
	FROM students S
WHERE S.dept = 'CS'
ORDER BY S.gpa, S.name, a2;
```
这里我们希望获取`S.age`乘以2后得到的结果，并把这个结果在输出中命名为`a2`

并且，`ORDER BY S.gpa, S.name, a2;` 指定了在输出时按照gpa, name, a2顺序排序，排序顺序是字典序：首先按照gpa的字典序进行排序，对于gpa相同的条目，按照name的字典序进行排序，如果gpa和name都相同，那么按照a2的字典序排序
可见`ORDER BY`所依据的列不只是原表中的某一列，还可以是我们在查询过程中进行计算得到的列

我们还可以在排序依赖项后面增加限制`DESC`（降序排列）和`ASC`（升序排列），默认是ASC
```SQL
SELECT DISTINCT S.name, S.gpa, S.age*2 AS a2
	FROM students S
WHERE S.dept = 'CS'
ORDER BY S.gpa DESC, S.name ASC, a2;
```

我们还可以限制输出为一定数量的行，通过`LIMIT`关键字实现：
```SQL
SELECT DISTINCT S.name, S.gpa, S.age*2 AS a2
	FROM students S
WHERE S.dept = 'CS'
ORDER BY S.gpa DESC, S.name ASC, a2;
LIMIT 3;
```
这代表只取全部结果的前三行进行输出
将它与`ORDER BY`一同使用，即可获得按照某列排序的前n行记录。事实上，只有它们结合起来使用才有意义，因为SQL是一种多集语义，如果不指定`ORDER BY`的话，得到的集合内部并没有特定的顺序，此时使用`LIMIT`只能获得随机的n行

#### 计算表的聚合

聚合函数接受一批元组（实际上是一列中的一批值），输出这批值经过聚合函数计算之后的结果
例如，`AVG`就是一个聚合函数，用于计算一列中的平均值：
```sql
SELECT [DISTINCT] AVG(S.gpa)
FROM Student S
WHERE S.dept = 'CS'
```
其中`DISTINCT`关键词可选，用于去重。这里就是选择学生中计算机系学生的gpa栏目的平均值
这段代码输出的是单独的一行一列单元格，即平均gpa

此外，sql还提供了`SUM`求和、`COUNT`计数、`MAX`最大值、`MIN`最小值等其他的简单聚合函数，也允许你定义自己的聚合函数

#### 分组

通常，我们会希望对表格进行划分，变成多个组，每个组内的数据对象具有一定共性
分组操作通过关键词`GROUP BY`进行：
```sql
SELECT [DISTINCT] AVG(S.gpa), S.dept
FROM Students S
GROUP BY S.dept
```
此处，`GROUP BY`说明按照`S.dept`的值分组，将dept值相同的学生分到同一组内，对每个组内的学生计算聚合值，把平均值和dept值一起输出，用于标识不同组别的输出值

#### 过滤输出

在输出时，我们可能会希望结果满足一定要求才进行输出，以略掉不感兴趣的部分，这样的选择功能通过关键字`HAVING`实现：
```SQL
SELECT [DISTINCT] AVG(S.gpa), S.dept
FROM Students S
GROUP BY S.dept
HAVING COUNT(*) > 2
```
`HAVING`的过滤在分组之后，
这里`COUNT(*)`是一个聚合函数，注意SQL是支持正则表达式的，这里代表对任何列进行计数（不限制列名），计算每一个列的行数（所拥有的学生记录条数）
因此`HAVING`谓词的作用就是筛选并保留那些学生记录数量大于2的组别

**`HAVING`只适用于聚合查询，只根据聚合结果，对分组得到的各个组别进行过滤（只在`GROUP BY`后起作用）；**
**普通的逐行过滤（只对单行作用，而不对整个组作用）应该使用`WHERE`子句**

总结上面的各个语句：
```sql
SELECT S.dept, AVG(S.gpa), COUNT(*) 
FROM Students S   ''' 学生表 '''
WHERE S.gender = 'F'  '''where子句在group聚合之前'''
GROUP BY S.dept
HAVING COUNT(*) >= 2  '''having子句在group之后'''
ORDER BY S.dept
```
这里我们希望了解女性学生的系别、gpa平均值和数量，然后在得到的表格之上作按系别的分组，筛选出人数大于2的组别，按照系别名的字典序进行排列输出

#### DISTINCT关键字

`DISTINCT`关键字可以被用在两个不同的位置：

聚合函数内：
```SQL
SELECT COUNT(DISTINCT S.name)
...
```
此时，我们在进行`COUNT`计数之前，会将所有名称的重复项给移除，然后再进行计数

`SELECT`后，聚合函数之外：
```SQL
SELECT DISTINCT COUNT(S.name)
...
```
此时，`COUNT` 只返回它未经过去重之后计数得到的结果，只是一个一行一列的值，并不存在重复项，因此依然还是得到那个值
聚合查询中没有重复项，所以在聚合外的`DISTINCT`关键字没起到作用


#### 一个不合法使用`GROUP BY`的例子

```SQL
SELECT S.name, AVG(S.gpa)
FROM Students S
GROUP BY S.dept
```
这段代码是错误的，原因在于第一行的`S.name`中
对于`GROUP`，它的作用在于对原始数据进行分组；在分组之后，返回值的计算就**基于按照子句后的数据列分好的组别，而不是单行记录了**
此时，**任何不在`GROUP BY`之后的数据列名都不可以作为被查询的对象，因为组内会有多个不同的值，无法确定返回哪个**，除非将这个数据列经过聚合函数计算得到一个唯一的值

因此，在上述代码中，用户请求的值除了聚合计算的平均值之外，还有`S.name`，问题在于对于一个组，其中的多个记录都有自己的name, `GROUP BY`得到的每个组别内各自并不包含一个统一的值，同时这个name又不作为聚合函数的输入而计算出每个组的对应值，因此是不合法的

### 1.2.3 针对多表的查询模式

对于多个表格的查询，也称为连接查询Join Queries，它的基本模式如下：
```sql
SELECT [DISTINCT] <column expression list>
FROM <table1 [AS t1], ... , tableN [AS tN]>  '''列出多个表格'''
[WHERE <predicate>]  '''单行过滤'''
[GROUP BY <column list>
[HAVING <predicate] ]   '''聚合以及聚合过滤'''
[ORDER BY <column list>]  '''排序'''
```
现在，`FROM`子句后是一个可能包含多个表的列表，我们的查询涉及了多个表格

对于多个表格，`FROM`计算得到的实际上是它们之间的笛卡尔积，这是一个包含了所有表格之间可能的组合的庞大的关系表格
对于两个表格的笛卡尔积，其计算实际上就是把表格间每一行的对应情况都列出来：

表格A：

| sid | sname | rating |
| --- | ----- | ------ |
| 1   | P     | 11     |
| 2   | D     | 12     |

表格B：

| sid | day   |
| --- | ----- |
| 1   | 9/10  |
| 2   | 10/11 |
| 3   | 10/21 |

表格$A\times B$：

| sid | sname | rating | sid | day   |
| --- | ----- | ------ | --- | ----- |
| 1   | P     | 11     | 1   | 9/10  |
| 1   | P     | 11     | 2   | 10/11 |
| 1   | P     | 11     | 3   | 10/21 |
| 2   | D     | 12     | 1   | 9/10  |
| 2   | D     | 12     | 2   | 10/11 |
| 2   | D     | 12     | 3   | 10/21 |

在笛卡尔积中，两个表格的不同行之间所有不同的组合关系被列出，形成了一个巨大的表格，它包含了两个表格所有可能的元组组合
虽然这种方式比较低效，实际实现中会使用更高效的实现方式，但这种形式是理解该查询的最直观形式

例如，下面的查询：
```sql
SELECT Sailors.sid, Sailors.sname, Reserve.bid
FROM Sailors, Reserve
WHERE Sailors.sid = Reserve.sid
```
该表达式中，`From Sailors, Reserve`一行表明是从`Sailors`表和`Reserve`表形成的笛卡尔积表中获取数据的
根据`WHERE Sailors.sid = Reserve.sid`，在形成的笛卡尔积表格中选取那些两表格元组组合中满足sid=bid的元组，形成表格，然后输出这些组合表格中的特定列`Sailors.sid, Sailors.sname, Reserve.bid`

注意，由于两个表都有sid这个属性，我们往往会使用`范围变量.属性名`的方式指明确切的对象，不过如果一个属性只存在`From`所列出的表格中的其中一个中，可以不需要使用范围变量（表名）进行约束

别名通过`原名 AS 别名`语句进行确定
我们还可以将表格与自身进行连接，计算笛卡尔积
下面这个例子展示了一个有趣的写法：
```SQL
SELECT x.name, x.age, 
	y.name AS sname2,
	y.age AS age2
FROM Sailors AS x, Sailors AS y
WHERE x.age > y.age
```
这里我们**将表格与自身连接**，形成一个表示同表格的对比分析的表格，将表格的每行与该表格的所有行组合
在总表格中，选取那些x别名水手表格年龄项大于y表格年龄项的元组输出，只输出两表格的name和age列

### 1.2.4 指定算术表达式与字符串函数

我们可以输出获得对属性列的值进行算术表达式后的结果：
```sql
SELECT S.age-5 AS age1, 2*S.age AS age2
FROM Saliors AS S
WHERE S.name = 'poptype'
```
这里输出表格的列项值是导入表格的列项经过算术运算后的结果

也可以在WHERE子句中进行这样的算术表达式：
```sql
...
WHERE 2*S1.rating = S2.rating-1
```
在任何地方都可以进行这样的算术运算
你甚至可以将它作为计算器使用：
```sql
SELECT
	log(1000) AS three,
	exp(ln(2)) as two,
	cos(0) AS one
```
该查询是合法的，不需要导入表，而是输出计算结果。log、ln、exp、cos等数学表达式都是SQL中内置的

关于字符串的函数也是支持的，例如字符串比较就可以通过`LIKE`关键字+无正则表达式字符串或 `~`算术符号+正则表达式进行：
```sql
SELECT S.sname
FROM Sailors AS S
WHERE S.name LIKE 'B_%'
```
这种情况下不允许使用正则表达式

而`~`的版本：
```sql
SELECT S.sname
FROM Sailors AS S
WHERE S.name ～ 'bA.*'
```
字符串格式是允许使用正则表达式的，可以使用其语法来表示通配、匹配等等功能

### 1.2.5 使用布尔逻辑与集合运算

我们可以在WHERE子句中通过使用布尔逻辑组合多个谓词，进行更准确的判断；或是求两个查询的交集、并集等结果时，也有关键字来处理两段查询的结果并进行

在WHERE子句使用布尔逻辑：
```SQL
SELECT R.sid
FROM Boats B, Reserves R
WHERE R.bid = B.bid AND (B.color = 'red' OR B.color = 'green')
```
布尔逻辑`AND`, `OR`, `NOT`就是我们常用的与或非了

该查询还能用更有趣的形式编写：
```SQL 
SELECT R.sid
FROM Boats B, Reserves R
WHERE R.bid=B.bid AND B.color='red'

UNION ALL

SELECT R.sid
FROM Boats B, Reserves R
WHERE R.bid=B.bid AND B.color='green'
```
其中，上下两段查询的结果分别得到两表bid相等的同时颜色为红色和绿色的结果
然后，使用`UNION`关键字，它代表：将之前的查询结果和接下来会得到的查询结果取并集，输出最终的并集查询结果

同理，如果将逻辑改为取交集：
```SQL 
SELECT R.sid
FROM Boats B, Reserves R
WHERE R.bid=B.bid AND B.color='red'

INTERSECT 

SELECT R.sid
FROM Boats B, Reserves R
WHERE R.bid=B.bid AND B.color='green'
```
使用`INTERSECT`关键字指定
注意，这种情况下的`WHERE`子句形式的查询不可以写成：
```sql
...
WHERE R.bid = B.bid AND (B.color = 'red' AND B.color = 'green')
```
因为`B.color = 'red' AND B.color = 'green'`代表元组的color列值又是red又是green，显然不可能

另外，还有差集运算符`EXCEPT`用于计算两集合的差集
假设集合为R={A, A, B, B, C, D}, S={A, A, B, C, E}
则经过差集运算 `R EXCEPT S`得到的集合为{D}
相当于是`R - R INTERSECT S`，注意集合中的重复元素是被忽略的，没有重复项，关系与之是一致的
### 1.2.6 集合语义

之前我们对集合操作符的介绍都只是简述，下面阐述其细节
根据我们在数学上学到的集合语义与数据库语义，我们所处理的集合中的元素实际上是关系中的元组，整个关系形成一个集合
因为**在非多集的集合语义下**，我们可以认为**我们会忽视关系中的重复项：没有两个一模一样的元组会出现在关系中**

在1.2.5中介绍并集时使用了`UNION ALL`，这里的`ALL`关键字是用于**处理多集语义的**
多集语义：对于每个元组，存在与之完全相同的副本，为每个元组计数它们，获取副本数量（基数）
例如：R={A, A, A, A, B, B, C, D} = {A(4), B(2), C(1), D(1)}
这种记法用于形象地表示元素及其基数

在集合运算符`UNION`, `INTERSECT`和`EXCEPT`后面加入`ALL`关键字，进行它们对多集语义下的集合处理：
设R={A(4), B(2), C(1), D(1)},  S={A(2), B(3), C(1), E(1)}
`R UNION S`：{A(4+2), B(2+3), C(1+1), D(1+0), E(0+1)}

`R INTERSECT S`：{A(min(4, 2)), B(min(2, 3)), C(min(1, 1)), D(min(1, 0)), E(min(0, 1))}
是一个取各基数的最小值作为元素基数的操作

`R EXCEPT S`：{A(4-2), B(2-3), C(1-1), D(1-0), E(0-1)}={A(2), B(0), C(0), D(1). E(0)}
且对于小于0的数，均只取0

### 1.2.7 查询块

#### 子查询块与集合检查
在集合处理中，我们有了查询块的概念：前面获得的查询结果集合与后面获得的查询结果集合作集合运算，但是这个过程是隐式的
事实上，我们还可以显式地进行查询块的表示：使用'`()`'括号括起的部分就是一个**子查询块，表示一个查询所获得的元组集合**。例如：
```SQL
SELECT S.sname
FROM Student AS S
WHERE S.sid IN
	(SELECT R.sid
	FROM Reserves R
	WHERE R.bid = 102)
```
这里使用子查询来表示元组的集合，获取了R表中所有bid等于102的元组集合
使用`IN`或`NOT IN`来进行查询集合之间的比较，是一种判断关键字，代表元组在或不在接下来的集合中，它们要求**其右侧的子查询必须返回一个 *单一列* 的结果集**，也就是在其右侧的子查询块中只能`SELECT`一个表项（列）
这里
```sql
WHERE S.sid IN
	(SELECT R.sid
	FROM Reserves R
	WHERE R.bid = 102)
```
表示的是：对由`FROM`导出的表格中的每一个元组，检查其`sid`是否在下面的`SELECT R.sid FROM Reserves R ...`所导出的`sid`元组集合中，如果在，那么将其加入查询结果中
该查询的含义是：检查student表中每个学生的sid是否在reserve表中bid值为102的预定人员号sid列中，如果在，将该学生的名字输出出来，用于获取特定船的预定者名单

#### 内外层表格关联查询
另外一个使用查询块的返回结果的例子使用到了`EXISTS`关键字，它有点类似于优化的笛卡尔积连接查询：
```SQL
SELECT S.name
FROM Sailors S
WHERE EXISTS
	(SELECT *
	 FROM Reserves R
	 WHERE R.bid=102 AND S.sid=R.sid)
```
`EXISTS`关键字用于**将外层查询引入的表的每一个元组组合上内层引入的表的每一个元组，进行内层查询WHERE子句的检测**（“组合”的语义类似于笛卡尔积，但是优势在于不需要计算庞大的笛卡尔积，而是可以进行截断）

具体来说，`EXISTS`关键字对于外层查询中的每一行记录（元组），都会 **运行一次子查询**`WHERE R.bid=102 AND S.sid=R.sid`以检测在R表中，是否具有满足该条件的元组
如果**存在至少一个满足条件的元组**，返回true，此时会将此外层查询元组的S.name属性加入输出集合中，最终输出所有EXISTS检查为TRUE的元组的S.name

它和`JOIN`查询其实很像：
```sql
SELECT S.name
FROM Sailors S, Reserves R
WHERE R.bid = 102 AND S.sid = R.sid

```
这里将S表和R表通过隐式的`JOIN`即笛卡尔积连接起来，然后对连接的表执行查询，返回满足条件的S.name
区别在于：
- `JOIN`查询会有**重复现象**：对于每个在 `Reserves` 表中有多个符合条件的预约记录的船员，会 **返回多条记录**。例如，如果船员 `S1` 预约了图书 `102` 三次，`JOIN` 查询会返回 `S1` 三次，每次都会返回不同的记录
- **EXISTS性能更好**：当子查询中有 **索引** 时，`EXISTS`会在找到第一条匹配记录后立即停止搜索，因为**它只关心是否存在，找到一个就说明存在了，无需继续寻找**。而`JOIN`的查询生成庞大的笛卡尔积表格，存在重复问题，性能更慢

同理，存在`NOT EXISTS`，它和`EXISTS`的语义是相反的：如果存在，返回`FALSE`；不存在时才返回`TRUE`

值得注意的是，EXISTS或NOT EXISTS右侧的子查询中的`SELECT ...`子句的作用仅仅是**生成一个符合条件的记录集**，用来判断是否存在符合条件的记录，因此它**选择返回什么都不重要，重要的是“进行了记录的返回”这个操作**，常用的优化是直接将其写称`SELECT *`或`SELECT 1`

可以使用
```
for(auto i : A)
	for(auto j : B)
		for(auto k : C)
```
这样的思想来理解`EXISTS`关键字

#### 更多集合运算
另外介绍一些集合运算符`ANY`和`ALL`
下面是一个使用`ANY`的例子：
```SQL
SELECT *
FROM Sailors S
WHERE S.rating > ANY
	(SELECT S2.rating
	 FROM Sailors S2
	 WHERE S2.name='Popeye')
```
这个查询的作用是**找到那些rating属性值大于名字为'Popeye'的水手的rating属性值的水手信息**

`ANY` 关键字用于与子查询一起进行比较：`ANY`的语义是**代表子查询中的至少一个元组**
因此，对于`S.rating > ANY(...)`，只要外层查询的值大于子查询返回的 **任意一个** 值，就返回TRUE
`ANY` 后面的子查询**只能返回一列值**，而不能返回多列值。其语法要求是子查询的结果必须是一个 **单列的集合**，因为 `ANY` 用来将外层查询的值与子查询结果中的 **单列值** 进行比较

而`ALL`关键字的用法与`ANY`完全相同，只是语义不同：`ALL`的语义是**代表子查询中的所有元组**
因此，如果`S.rating > ALL(..)`，则代表外层元组必须大于子查询获得的元组集合中的每一个元组（因为是单列元组，可以直接进行比较）才返回true

### 1.2.8 关系除法

下面的复杂查询被称为关系除法：
```SQL
SELECT S.sname
FROM Saliors S
WHERE NOT EXISTS
		(SELECT B.bid  ''' 实际上不关心船只的bid,改成SELECT 1也行'''
		 FROM Boats B
		 WHERE NOT EXISTS 
			 (SELECT R.bid
			  WHERE R.bid = B.bid AND R.sid = S.sid))
```
使用了两个嵌套的子查询，外层where子句的语义是：找出那些没有反例可以证明他们没有预定某艘船的水手，即：对于一个水手来说，如果你能指出一艘他没有预定到的船，就返回false，**如果他预定了所有的船，才返回true**

看看sql语句的工作：
- 最外层引入水手表，返回水手的名字，在where语句中使用not exist，含义是对于水手元组，选择**不存在于那些满足反例条件的集合中**的元组，而反例条件根据语义，我们希望是**对于该水手，可以被指出一艘船没有被他预定到**
- 因此，第一层子查询引入了船表，该层子查询将船表的每一个元组组合上外层水手的每一个元组，进行该子查询中的WHERE部分检查，而其中又嵌套了一层NOT EXISTS
- 最后一层子查询引入了预定表，结合预定表+船表+水手表的每一个元组，检查条件为`WHERE R.bid = B.bid AND R.sid = S.sid`，也就是水手在预定表上预定了该船，而`NOT EXISTS`将该条件取反：水手在预定表上没有预定该船时取TRUE

然后总体来看，从内往外：
```SQL
...
		(SELECT B.bid 
		 FROM Boats B
		 WHERE NOT EXISTS 
			 (SELECT R.bid
			  WHERE R.bid = B.bid AND R.sid = S.sid))
```
含义是找到那些能够取得不符合`R.bid = B.bid AND R.sid = S.sid`条件的反例的元组，构成一个集合S

```SQL
SELECT S.sname
FROM Saliors S
WHERE NOT EXISTS (...)
```
然后取不在集合S中的元组，输出水手的名字
“不在集合S"即代表：找不到不符合`R.bid = B.bid AND R.sid = S.sid`条件的反例，即所有船都被该水手预定了

绕了这么一大圈，本质上的其工作和：
**遍历水手表，对于每个水手，遍历船表，对于每艘船，遍历预定表，如果每艘船在预定表上都被当前遍历的水手预定了，把水手的名字输出**
是一样的。
但是直接这么做显然是三层遍历，效率太低了，于是使用`NOT EXISTS`进行**排除法优化**：
<u>“如果每艘船在预定表上都被当前遍历的水手预定了”的水手被选中</u> $\Rightarrow$ <u>那些“能被找到没有预定的船的水手”一定不被选中，于是直接在原集合上排除这些水手即可</u>

这就是所谓的“关系除法”，意思是“排除法”

### 1.2.9 最值元组查询argmax

当我们希望找到一组元组中，某个属性值最大或最小的那个元组，根据SQL提供的**MAX聚合函数**，我们会想到以下两种写法：

写法1：
```SQL
SELECT MAX(S.rating)
FROM Sailors S
```
该写法并没有告诉我们元组具体是哪个，它只是找到最大的rating属性值，然后将该值输出而已，不符合我们的argmax应有的功能

写法2：
```sql
SELECT S.*, MAX(S.rating)
FROM Sailors S
```
这种写法甚至不合法，我们的想法是把最大值放置在得到最大值的元组旁边，但是这是错误的实现
由于`MAX`是一个聚合函数，它计算的是这个元组集合中的最大值，而因为我们没有`GROUP BY`操作，所以集合是整个Sailors表，计算出的最大值是整个表的最大值，整个表有且仅有这么一个值

因此，SQL 不知道如何将 `S.*`（即所有列）与聚合函数 `MAX(S.rating)` 结合使用，因为它需要知道如何将结果按某些列进行分组

请记住：
在对列表进行具有聚合函数的查询时
- 每个列引用（例如S.rating）要么嵌套在聚合函数中；
- 要么作为`GROUP BY`子句的一部分来标识分组，用来对结果按这些列引用的值进行分组
- 如果希望一个聚合函数能用在`SELECT`语句后，需要在最后用`GROUP BY`声明按照什么列进行分组，这样SQL才能知道应该怎么将列和聚合函数结合

---
考虑引入子查询的写法
写法3：
```SQL
SELECT *
FROM Sailors S
WHERE S.rating >= ALL
	(SELECT S2.rating
	 FROM Sailors S2)
```
语句的理解很简单，`ALL`代表子查询集合内的全部单列元组，选取那些rating值大于等于整个表所有元组rating值的元组，进行输出
这是合法且正确的argmax查询

写法4：
```SQL
SELECT *
FROM Sailors S
WHERE S.rating =
	(SELECT MAX(S2.rating)
	 FROM Sailors S2)
```
该查询使用子查询获取最大值`MAX(S2.rating)`，返回单个值，找到rating值等于该最大值的元组进行输出
这也是正确的实现，我们可以认为写法3和4达到的效果是一致的

进一步地，看到下面的写法
写法5：
```sql
SELECT *
FROM Sailors S
ORDER BY rating DESC
LIMIT 1
```
也就是将整个表按照依rating值降序的方式重新排列（`ORDER BY .. DESC`)，然后将重排后的表格的第一行，也就是最大rating值所在的元组进行输出（`LIMIT n`将输出限制在前n行）
这个虽然也能求最大rating值元组，但是它把输出限制为了单一行。我们知道，可能存在多个元组具有相同的最大rating值，写法3和4都可以把这些并列最大结果输出，但是写法5只能在这些并列结果中随机输出一个（因为ORDER BY对于并列元素的排列是随机的）

### 1.2.10 不同类型的连接操作

我们在对于`FROM`关键字的描述中已经初步地了解了表的连接：笛卡尔积+WHERE筛选
在数据库概论中，我们学过连接，包括自然连接，等值连接等等特殊的连接，其定义是：**从两个输入关系所形成的笛卡尔积中选取属性间满足一定条件的元组**
下面更加详细地进行介绍SQL中的实现
#### 内连接
对于我们之前写的：
```SQL
...
FROM Sailors S, Reservers R
WHERE S.sid = R.sid
...
```
实际上就是一种隐式的内连接，它的显式写法应使用`INNER JOIN`关键字，中缀地表示连接过程：
```SQL
...
FROM Saliors S INNER JOIN Reserves R
ON S.sid = R.sid
WHERE
...
```
另外一个不同点是`ON S.sid = R.sid`，它将原来表述中`WHERE`后面的谓词的一部分转移到ON关键字后了
在 SQL 中，`ON` 关键字用于 **指定连接条件**，即 **如何将两个表连接在一起**。
具体来说，`ON` 关键字后面跟的是**连接的条件：当满足连接条件时，将这两个表的元组连接在一起，加入输出结果，否则忽略**
其实就是“两个输入关系所形成的笛卡尔积中选取属性间满足一定条件的元组”中的“一定条件”了

这种写法是为了和后面的更多连接模式进行统一，这是最普通的连接形式，如果只使用`JOIN`关键字，调用的就是该连接形式

#### 自然连接
定义：连接条件默认是对于两个表格（关系）中的**具有相同名字的列A和B**，当**其值符合A=B时进行连接**
因此，自然连接不需要ON语句规定谓词，其行为是默认的，只需要使用`NATURAL JOIN`规定连接形式即可
```SQL
SELECT S.sid, S.name, R.bid
FROM Sailors S NATURAL JOIN Reserves R
WHERE
...
```
一般来说，自然连接不是好的选择，因为随着对于表中列的增删改，自然连接可能会失效，且这种失效比较难预测，因此一般尽可能避免使用它

#### 外连接
自然连接容易失效的原因是一个表格M中的某些元组的同名列属性值在另一个表格N的同名属性中可能不存在值相等的其他元组，此时整个元组会被删除
因此，我们考虑保留这些悬浮元组，相应地另一个元组的各个值全部记为NULL
根据M 连接 N的顺序，存在留M去N和留N去M两种情况，分为左外连接和右外连接，以及留M留N的全外连接情况

外连接需要使用ON指明连接条件，这说明它可以适用于更加广泛的情况
##### 左外连接
保留双目运算符`LEFT OUTER JOIN`左侧表中没有在右侧表中有相等同名属性的行（或左侧表中不符合ON后谓词情况的行），组合而成的表格中将这样的元组中对应右侧表相应属性的位置置为空值NULL
```SQL
SELECT S.sid, S.name, R.bid
FROM Sailors S LEFT OUTER JOIN Reserves R
ON s.sid = r.sid  '''需要用ON明确谓词‘’‘
```

##### 右外连接
保留双目运算符`RIGHT OUTER JOIN`右侧表中没有在左侧表中有相等同名属性的行（或左侧表中不符合ON后谓词情况的行），组合而成的表格中将这样的元组中对应左侧表相应属性的位置置为空值NULL
```sql
SELECT R.sid, B.bid, B.bname
FROM Reserves R RIGHT OUTER JOIN Boat B
ON r,bid = b.bid
```

##### 全外连接
保留运算符`FULL OUTER JOIN`两侧表中所有的行，如果有不满足连接条件的行，也保留，连接而成的元组中另外一个表的部分置为空
```SQL
SELECT R.sid, B.bid, B.bname
FROM Reserves R FULL OUTER JOIN Boat B
ON R.bid = b.bid
```

### 1.2.11 视图

视图可以视为“被给予名字的查询”，就像是编程语言中的宏或函数
视图的语法很简单
1. 首先声明`CREATE VIEW name`，其中name是赋予视图的名字
2. 然后下一行使用`AS`关键字，接一段`SELECT`开头的查询
例如：
```SQL
CREATE VIEW Redcount
AS SELECT B.bid, COUNT(*) AS scount  
'''注意，COUNT为聚合函数，可以放在这里是因为后面有GROUP BY 进行了分组'''
FROM Boats B, Reserve R
WHERE R.bid = B.bid AND B.color = 'red'
GROUP BY B.bid
```

视图的作用是在建立复杂查询时可以将其划分为小的查询来复用；同时，视图用于保证表的安全性：访问控制，用户只可以看到他们被允许看到的数据，且不允许对底层数据进行修改

请注意：每次引用视图时，它们都是实时评估的：它们不会被持久化入存储中，而是将当前底层数据表的一个快照输出出来，当底层表发生变动，视图也会相应变动

使用视图的例子如下：
```SQL
SELECT * FROM Redcount  '''Redcount就是我们上面定义的那个视图名'''

SELECT B.bname, R.scount
FROM Redcount R, Boats B
WHERE R.bid = B.bid
AND scount < 40
```

视图建立后是需要进行删除的，有时候我们对一个视图的使用时间很短，可能仅仅在一个查询中使用，此时使用临时的视图即可：
```SQL
SELECT bname, scount
FROM Boats B, 
(SELECT B.bid, COUNT(*)
		FROM Boats B, Reserves R
		WHERE R.bid = B.bid AND B.color = 'red'
		GROUP BY B.bid) AS Reds(bid, scount)
WHERE Reds.bid = B.bid AND scount < 40
```
我们只是在`FROM`子句中临时定义了视图`Reds`，而不是声明并定义它
注意，这里`(...) AS name(A, B, ...)`中的`(A, B, ...)`代表为每一列声明别名

相同功能的另一种写法使用到了`WITH`关键字，它的作用很类似于编程语言中的函数声明：
```SQL
WITH Reds(bid, scount) AS
(SELECT B.bid, COUNT(*)
 FROM Boats B, Reserve R
 WHERE R.bid = B.bid AND B.color = 'red'
 GROUP BY B.bid)

SELECT bname, scount
FROM Boats B, Reds
WHERE Reds.bid = B.bid AND scount < 40
```
这样的方式也称为公用表表达式CTE，用于定义之后会使用的视图

语法类似于：
```SQL
WITH name([column names list]) AS 
([query])
```

**对于多个视图的声明，只需要使用一次`WITH`即可**：
```SQL
WITH Reds(bid, scount) AS
(SELECT B.bid, COUNT(*)
 FROM Boats B, Reserve R
 WHERE R.bid = B.bid AND B.color = 'red'
 GROUP BY B.bid)

AnotherReds AD
(SELECT bname, scount
 FROM Boats B, Reds
 WHERE Reds.bid = B.bid AND scount < 40)

SELECT * FROM AnotherReds
```
注意顺序，**距离`WITH`远的视图定义时可以引用定义距离`WITH`近的视图，可重复使用**

使用视图机制，我们计算原始表中按年龄分组后每个组rating值的各自的最大值：
```SQL
WITH MaxRating(age, maxrating) AS
(SELECT age, MAX(rating)
 FROM Sailors
 GROUP BY age)

SELECT S.*
FROM Sailors S, MaxRating M
WHERE S.age = m.age AND S.rating = M.maxrating
```

视图的删除通过`DROP`关键字
```sql
DROP VIEW viewName
```


对于许多SQL来说，它们并不能够完全发现我们查询中可能存在的每个错误，因此需要构建能够测试查询中可能出现的异常情况的测试数据，以推理出查询中可能的问题

### 1.2.12 SQL中的空值

有时候我们并不知道在一个元组的某些字段中应该填入什么内容，此时SQL为我们提供的null值就代表了这种“未知”
**每种数据类型在字段中都可以被填入null值**，由于类型系统中存在的null值，我们的查询可能会因此稍微更加复杂：**需要考虑null值如何与WHERE或ON等语句中的谓词交互**

根据定义，下面的布尔表达式求值全部为NULL：
- A > NULL 或 A <= NULL 或 A = NULL 或其他比较
当WHERE表达式求值为NULL时，将其视为FALSE

而检查一个表项是否为空，使用`IS NULL`或`IS NOT NULL`，检测该位置是否为空后返回布尔值

更一般地，当我们使用`AND`,`OR`,`NOT`与NULL组合时，只有以下情况结果不是NULL：
- `AND`运算的两个参数中，一个为FALSE，而另一个为NULL时，返回FALSE
- `OR`运算的两个参数中，一个为TRUE，而另一个为NULL时，返回TRUE

当聚合函数中带有null值时，该null值会被直接忽略，不参与聚合函数的计算，例如SUM聚合函数不把NULL值加入。
特别注意，`COUNT(特定列)`不会把该列属性为空的行加入最终的计数中
但是`COUNT(*)`因为是针对所有行的全部列的计数，无论该行该位置为空或否，都会进行计数

### 1.2.13 临时复习使用：数据定义与修改

#### 数据定义

| 语句关键词 | 创建            | 删除          | 修改          |
| ----- | ------------- | ----------- | ----------- |
| 模式    | CREATE SCHEMA | DROP SCHEMA | --          |
| 表     | CREATE TABLE  | DROP TABLE  | ALTER TABLE |
| 视图    | CREATE VIEW   | DROP VIEW   | --          |
| 索引    | CREATE INDEX  | DROP INDEX  | ALTER INDEX |

其中表和视图都已经学过了，特别强调模式与索引，以及表和索引的修改操作

##### 模式
在 SQL 中，`SCHEMA` 是一种 **数据库对象** 的容器，用于组织和管理数据库中的对象（如表、视图、索引、存储过程等）。`CREATE SCHEMA` 语句用于在数据库中创建一个新的 **模式**，它为数据库对象提供了一个逻辑结构或命名空间，以便进行分组和管理。
类似于编程语言中的命名空间，**模式中可以有表、视图、索引等等各种对象，是一个独立的容器，用于区分不同功能部分的不同对象**。
不同模式中的对象可以重名，同一模式中的则不可以。因为在多模式环境下使用这些对象需要指明命名空间，直接定位该模式下的该名字所指向的对象

例如，创建一个模式sales，模式中有两个表：
```SQL
CREATE SCHEMA sales
    AUTHORIZATION admin_user
    CREATE TABLE customers (
        id INT PRIMARY KEY,
        name VARCHAR(100)
    )
    CREATE TABLE orders (
        id INT PRIMARY KEY,
        customer_id INT,
        amount DECIMAL
    );

```

`AUTHORIZATION`关键字用于在创建一个新的 **模式** 时，指定 **该模式的所有者**，即谁对这个模式及其包含的对象（如表、视图等）具有管理权限。

删除模式的语句如下：
```SQL
DROP SCHEMA schemaname [CASCADE/RESTRICT]
```
- CASCADE代表删除表及其全部对象
- RESTRICT代表如果表有下属的对象，拒绝删除
不过MYSQL不支持后面的选项关键字，默认就是删除表及其对象

##### 定义表
定义表的方式也比较简单，之前已经展示过了，其正式的定义模式如下：
```SQL
CREATE TABLE tablename (
<列名> <数据类型><数据长度> [<列级完整性约束条件>], 
<列名> <数据类型><数据长度> [<列级完整性约束条件>], 
...,
[<表级完整性约束条件>]
)
```

数据类型包括CHAR, INT, SMALLINT, VARCHAR等等，数据长度就是阿拉伯数字

列级完整性约束条件的位置可以填以下关键字：
- `NULL`：初始化为空值
- `NOT NULL`：规定该列的值不能为空
- `DEFAULT`：规定该列取默认值
- `UNIQUE`：规定该列取值不能重复
- `CHECK(condition)`：其中condition是一个检查逻辑表达式，约束该列的取值经过逻辑表达式计算后为真，用于限制坏数据的插入。逻辑表达式中的变量除了本列的列名之外，还可以用其他已有列的列名，因此可以单独定义一个列变量作为检查另外一个已有列的插入值是否合法的检查列
- `PRIMARY KEY`：用于声明本列为主码
- `FOREIGN KEY`：声明本列为引用其他表的外码：`[FOREIGN KEY(<本外码列的列名>)] REFERENCE <外表表名>(<引用的外表列名>)`，其中前面的`FOREIGN KEY...`部分是可选的，只在在表级完整性约束处定义时使用

而表级完整性约束就是“对整个表的所有列的约束”，在上述关键字中，只有以下关键字或情况不可使用：
- `NOT NULL` 和 `DEFAULT`

而以下情况只能在表级完整性约束中使用：
- 主码是多列的组合，此时需要在最后面的表级完整性约束位置声明：`PRIMARY KEY(列名1, 列名2, ...)`
- `CHECK`检查中的condition需要检查多个列的取值组合，例如列a+列b值在一定范围内，此时需要在这里定义，前面加上关键字`CONSTRAINT`可以为该约束命名，例如`CONSTRAINT rule CHECK(condtion)`就定义列一个rule约束
- 该位置也可以定义外码，不过此时原来可选的`[FOREIGN KEY(<本表中外码列的列名，可以是多个>)]` 部分就必须加上了

`CONSTRAINT` 关键字用于**指定完整性约束**的名称，可以在 `CREATE TABLE` 语句中为约束定义一个名字，也可以在 `DROP CONSTRAINT` 语句中引用这个名称来删除特定的约束。

##### 修改表

表的修改使用`ALTER TABLE`关键字
```SQL
ALTER TABLE tablename <更改选项>
```
其中，更改选项可以是以下几种：
- `ADD [COLOMN] <新列名> <数据类型><数据长度> [<列完整性约束>]`：增加新列，COLOMN为关键字代表列对象
- `ADD <表级完整性约束>`：为整个表新增完整性约束
- `DROP [COLOMN] <要删除的列名> [CASCADE/RESTRICT]`：删除对应列
- `DROP CONSTRAINT <完整性约束名> [CASCADE/RESTRICT]`：删除完整性约束名所指向的约束
- `ALTER COLUMN <已有列的列名> <数据类型>`：修改表中已有列的数据类型

##### 索引
**索引**是一种数据结构，它可以帮助加速对数据库表的查询操作。索引通常是基于表中的一个或多个列创建的，它类似于书籍中的目录，允许数据库引擎在查询时更加高效地定位所需的数据。
```SQL
CREATE [UNIQUE][CLUSTER] INDEX indexname
ON <表名> (<列名1>[次序1]， <列名2>[次序2]， ...)
```
次序就是DESC降序或ASC升序
索引建立在该表的一个或多个列上
- UNIQUE代表此索引每个值只指向唯一的数据记录
- CLUSTER代表聚簇索引

#### 数据更新

定义了表等对象之后，就需要对表进行更新，增删改
##### 插入元组
```SQL
INSERT 
INTO <插入目标表名>[(<属性列1名>, <属性列2名>, ...)]
VALUES (<常量1>, <常量2>, ...)
```
将新的元组插入目标表中，属性列名的列表可以省略，因为定位了表就能定位有什么属性列，INTO提供的值的数量和类型必须与表的属性列匹配

也可以插入子查询得到的结果：
```SQL
INSERT 
INTO <插入目标表名>[(<属性列1名>, <属性列2名>, ...)]
	子查询（INSERT ... FROM...)
```
也会检查是否符合完整性规则

##### 修改元组
```SQL
UPDATE <目标表名>
SET <列名1>=<表达式1>, <列名2>=<表达式2>, ...
[WHERE condition]
```
where检查是可选的，对于满足条件的元组才进行修改。不加该判断则默认所有元组进行修改
表达式可以是常量值，也可以是带有列名的变量值
修改时也会检查是否满足完整性约束

##### 删除元组
```SQL
DELETE
FROM <表名>
[WHERE condition]
```
将符合where条件的元组从表中删去，不使用where则默认全部删除

#### 将分组结果用于条件判断
WHERE子句中不可以使用聚合函数的结果来进行判断，例如`WHERE MAX(a.rating) > 40`是错误的写法！
正确的写法应该使用`HAVING`关键字，**HAVING关键字放在GROUP BY后面，ORDER BY 前面**：
```SQL
SELECT Sno, AVG(Grade)
...
GROUP BY S.sdepy
HAVING AVG(Grade) >= 70
ORDER BY Grade DESC[/ ASC升序]
```

# Chapter 2. 