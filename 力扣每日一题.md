# 1. 滑动窗口
![[Pasted image 20241104205013.png]]
## 初始思路：
首先看暴力解法：for循环遍历数组中的每个元素，每到一个位置，从该位置往后面扩展窗口
例如，在`nums[0]`处，将窗口的长度由1扩展到n，逐个遍历，记录和大于`target`的子情况的长度，然后继续`nums[1]`，`nums[2]`……，显然复杂度过高，每次遍历还有另外一层遍历进行求和和扩展窗口长度，平方级别复杂度

考虑优化：对于窗口队列，因为是求长度最小的子数组，数组元素均为正整数，所以当我们遇到第一个和大于`target`的窗口后，这就是最小的子数组了，本次循环可以跳过
当我们在前面的一次循环遍历到窗口长度最大却仍然没有到达`target`，说明后面的循环没必要看了，不可能大于`target`了

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
           int hh = 0, tt = 0;
           int sum = 0, ans = 9999999;
           while (hh <= tt) {
            while (sum < target && tt < nums.size()) 
                sum += nums[tt++];
                
            if (sum >= target) { 
                ans = std::min(ans, tt-hh); 
                sum -= nums[hh++];
            }
            else break;
           }
           return (ans == 9999999) ? 0 : ans;
    }
};
```
