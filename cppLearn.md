C++易忘总结

1.想要求俩int相除，输出双浮点数类型的结果，可以使用类型转换static_cast

int i=5,j=3;

double result=static_cast\<double\>(j)/i;

//别忘记括号

也可以直接不需要，直接除，但是要注意左值的容量

static_cast\<Type\>
**\[用于静态类型转化，它把后面的数转换到Type的容纳上限]{.mark}**，如果Type上限比这个数小，**\[则从高位开始舍弃前面的位]{.mark}**。这对于自定义数据类型与默认类型都是成立的。

而对于默认类型，也可以使用类似于int(z)或(int)z的形式进行类型转换，但是对于自定义类型，它可能会出问题，所以建议一律使用静态转化。

2.指向常量的指针

const double pi=11;

const double\*v1=&pi;

只能指向常量对象，并且不可通过指针修改对象的值

常量指针

int v1=1;

int\*const v2=&v1;

不变的是指针本身的值即它所存储的地址，而不是变量的值，**\[换句话说就是指向的对象不能被改变，但是可以通过指针修改这个对象的值]{.mark}**

3.顶层const与底层const

顶层const表示**\[任意的对象是常量]{.mark}**，可以适用于\[任何数据类型]{.mark}（常量指针）

而底层const跟引用和指针有关，**\[关注对象所指向的内容是否可以修改]{.mark}**（指向常量的指针）

关键字constexpr
用于检测变量的值(被赋予的值)是否是常量表达式，并且把变量置为顶层const

4.C风格字符串以一个空字符\'\\0\'结尾，**[通常用字符数组const char\*
str=\"\"来定义]{.mark}**
这样在后面就会多出一个空字符，使用字符数组的名字时用的是[指向其开头元素的指针]{.mark}，而且C风格字符串有不可修改性，所以其指针和const
char\*的性质很像，有时候可以互换。

5.Cpp中左值是具有标识符，可以被引用，具有[具体可识别的内存位置]{.mark}的值，通常放赋值操作符左边进行赋值，右值则是一个[临时值]{.mark}，表示具体数据或数值，但不可被直接获取内存位置

++i返回的是个左值 i++则返回右值 递减运算符同理

6.使用普通[传引用参数]{.mark}为形参的函数会改变传入实参的值，如果不想改变它的话就尽量使用[常量引用]{.mark}const
int&v1等等

7.for while
先执行循环条件再执行块内语句，dowhile则是先执行块再循环条件，**[因此不能在dowhile的while里声明变量]{.mark}**

8.函数内部或代码块内部声明的局部变量，动态分配的内存（new），自定义类的成员中声明的变量不会被默认初始化，此时如果调用会产生一个未定义的值，而全局变量（在函数或块外）和静态局部变量（定义时加了static）则会被默认初始化

9.类型initializer_list要使用同名的头文件后才能用，initializer_list\<数据类型\>
名称
它是一个模板类，[提供了一个固定大小的类似数组的轻量级容器]{.mark}，***它里面的元素类型必须相同或者可被隐式转化为同一类型***。initializer_list是个[临时对象]{.mark}，起到传值的作用，可用于初始化容器、作为函数与构造函数的参数等。

10.几种易混类型声明写法的总结

（1）**定义含有指针的数组：int\*name\[n\]其中n要是[常量表达式]{.mark}，不能是可被改动的**

**定义指向数组的指针：int(\*ptr)\[n\]，[赋值时和给指针赋值一样加上&取地址符]{.underline}**

**同理定义数组的引用int(&arr)\[n\]**

**定义指向数组的指针，这个数组由指针组成：int\*(\*ptr)\[n\]**

**声明一个返回数组指针的函数**

**法1.int(\*name(形参列表))\[n\]，记得数组维度在外面**

**法2.尾置返回类型 先在函数返回类型那里用auto代替，再用箭头运算符**

**auto func(形参列表)-\>int(\*)\[n\]
记得解引用运算符要加括号，不然还是含有指针的数组**

11.两个指向同一数组的指针相减的结果类型名叫ptrdiff_t，是一种[带符号类型]{.mark}，表示两指针所指元素在数组中位置之差，**若两个指针指向同一数组，则可以直接对两个指针进行比较或加减，对这样的指针加减一个整数值也能得到一个指针，表示指向元素在数组中的位置序号（从0开始到尾元素后一位置）**

12.**调用一个[返回引用的函数]{.mark}得到的是[左值]{.mark}，可以像使用其他左值一样使用其返回结果，调用其他返回类型的函数得到的都是[右值]{.mark}**

13. continue语句用于循环中间部分的作用：**立刻终止本次迭代，并且开始下一次迭代**，比方说如果每输入一个值开始一次迭代，continue语句在某次迭代中间，那么这次迭代立刻终止，并进行下一个输入的值的迭代

    **而break则是立刻终止break所在的这个循环**，这意味着如果是循环套循环的话外面的循环不会终止，只会终止里面的那个。除此之外break还会终止switch语句，依然是只终止离他最近的那个

    特别要注意的是switch case语句，其用法是：

    switch(ch)
    //先对switch括号里的ch进行求值，用求值结果与case标签值比较

    { case v1:
    //这里v1必须是个[整型常量表达式]{.mark}，用其值进行比较，可以是字符，字符串，数等等，注意字符加单引号，字符串加双引号，**并且case的值不能相同！**

    //进行处理

    break;
    /\***break语句终止switch的执行，如果此时外层有循环，break[不会终止外层的循环]{.mark}，而是终止此次switch然后进入下一次迭代。**

    如果不加break的话它会直接进入下一个case并执行直到碰到break或switch语句结束，因为switch语句的流程就是匹配case并从该标签开始往后执行所有case分支，如果想只对一种情况操作，必须加break
    \*/

    case v2:

    \...//后面省略

    default:
    //如果没有任何一个case可以匹配switch，那么进入default（可选的，也可以不设置default标签）

    \...//省略操作}；

    关于switch还有一个注意事项是，因为它会跳过那些不匹配的case,如果被跳过的代码中含有变量的定义怎么办？答案是：**[不允许跨过变量的初始化语句跳转到该变量作用域内的另一个位置，这对所有场景生效]{.mark}**。打个比方

    switch(ch){

    case true : int jval;
    //这个变量只声明而未被初始化（见第70条有哪些类型不会被默认初始化），因此这个是正确的

    int ival=0; string
    file_name;//都错误，前者显式初始化，后者隐式初始化

    break:

    case false:

    jval=11; //正确，这是赋值而不是初始化 };

    因为上面这里变量的声明在大括号内，其作用范围在整个switch语句的括号内，所以ival和file_name都违反了上面的规则，因此错误。不能在没有初始化或没有赋值的时候使用变量。

    **如果我们真的需要在某个分支定义并初始化一个自己的变量，[必须加大括号]{.mark}**，如

    case true:

    { int ival=0; //...} break;
    //这样就是正确的了，因为ival作用域不再是switch括号了，后面的case都在其作用域之外

14.在内层作用域中声明名字的话会自动隐藏外层作用域声明的同名实体，也就是说内层只能用内层的，不能用外层的，重载函数时同理，在内层只能用内层的重载函数。**所以函数声明最好别置于局部作用域内**

15.为函数设置默认实参时，**一旦某个形参有了默认值，那它后面所有的形参都必须有默认值（注意，他前面的形参可以没有！）**并且**默认实参只能填补函数调用缺少的尾部实参**，换句话说就是如果想给顺序排列且有默认实参的三个形参a,b,c中的b赋其他值，不能单独只改变b，必须把a也赋值了，但是如果想改a，就只需要在括号里输入那一个想改的值就行
void function( int a=2,int b=3,int c=4);

function(1):只改变a； function(1,5)只改变a和b

function( ,6)或function( , ,8)都不正确

16.在给定的作用域中**一个形参只能被赋予一次默认实参**，函数的后续声明只能给没有默认实参的形参增加默认实参，而不能改变已有的默认实参，不然算重复声明

增加默认实参只需要后续声明里给括号里面没有默认实参的对象赋值即可，注意已有默认实参的对象不要给它赋值

**局部变量不能作为默认实参**，除此之外只要表达式类型可以转变成形参所需类型，这个表达式就可以作为默认实参或实参

17.不允许两个函数除了返回类型不同以外其他所有要素都相同，如果这样做了则第二个函数的声明是错误的

18.**不要返回局部对象的引用或者局部临时量**

如函数最后直接

return \"empty\"; 是错误的

return {\"empty\"}; 是正确的

19.**和数组一样，当我们使用已声明的函数的名字时用的其实是指向函数的指针**，其声明方法为把函数声明中函数的名字改为（\*指针名），初始化时要明确用赋值运算符决定选用的函数名，并且和这个函数精确匹配

声明一个返回指向函数的指针的函数

**返回类型(\*函数名（指针指向函数的返回类型）)（形参列表）**；

更简单的

**auto f1(返回类型)=\>返回类型 （＊）（形参列表）；**

也可使用**decltype(目标函数)＊指针名（形参列表）；**的方式声明

20.编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体，**所以成员函数体可以随便使用类里面的其他成员**，**不需要在意声明的顺序**

21.在类的外部定义类的成员函数，需要使用作用域运算符：：

具体声明方法为

返回类型 类名：：函数名（形参列表）const{

\...\...}

其中const加不加看你定义的是不是[常量成员函数]{.mark}，

**①常量对象(通过const声明的类对象)只能调用它的常量成员函数，而不能调用普通成员函数；**

**②普通对象既可以调用常量成员函数，也可以调用普通成员函数；**

**③普通成员函数可以访问本类的常量成员函数；**

**④常量成员函数不能访问本类的普通成员函数；**

**⑤如果常量成员函数与普通成员函数同名，即构成了重载成员函数，那么，常量对象调用常量成员函数，普通对象调用普通成员函数。**

22.在使用类的成员函数时，比如

total.combine(trans);

这里调用total的成员函数，实参是trans，**实际上是先把trans的地址绑定在一个[隐式参数]{.mark}this上**，假设combine函数是这么写的

Sales_data& Sales_data::combine(const Sales_data &rhs)

{

units_sold+=rhs.units_sold;

revenue+=rhs.revenue;

return\*this

}

这里函数返回类型是Sales_data&即地址，units_sold和revenue都是类成员，**调用对象total的该成员函数且在以trans为实参时先把total地址绑到this上，再把rhs绑到trans上**，**函数里面赋值运算符左侧的运算对象都是total中的类成员，并且把左侧的运算对象作为左值返回，因此才需要让函数的返回类型是地址**，(因为左侧是Sales_data的对象，所以返回
Sales_data&)**并且在return语句中对this解引用**，返回其指向的对象total的引用

this相当于是[常量指针（只指向相应的对象）]{.mark}，在定义成员函数时在形参列表右加const可使其变成指向常量的常量指针，并且注意所有命名时不可使用this为名字

在调用成员函数时实际上会让this指向调用它的那个对象（上面的total），作为函数的一个实参提供所需信息。

23.**IO类型**是[不能被拷贝的类型]{.mark}，**只能通过引用来进行传递**，比如

ostream &Fun(ostream &os)

这个函数返回输出流，接收输出流

24.构造函数：**每个类都定义了它的对象被初始化的方式，这种初始化过程是通过一个或几个成员函数实现的，这些函数叫[构造函数]{.mark}**。**构造函数没有返回类型**，不同构造函数之间必须在参数数量或类型上有所区别（和普通函数一样）构造函数不能被声明为const的，当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得常量属性，**因此构造函数在构造const对象时可以向其写值**

当类没有声明任何构造函数时，编译器才会自动生成默认构造函数（不需要任何实参），但是如果声明了，那需要全部声明一遍，否则其他的没有默认构造函数了

这时如果忘记=default的话会出问题

25.构造函数在类中的声明

**类名 （形参列表）：成员名1（初始值），成员名2（初始值） {}**

//更多成员名及初始值以此类推，初始值也可以用大括号括起来代替括号，后面的大括号是构造函数的[空函数体]{.mark}，**成员的初始值可以根据输入的实参计算得到，即用形参表示**，如果没有对应形参，则采用类内初始值，**一般来说还是显式给成员初始化比较好**

当我们需要默认的行为 在构造函数参数列表后加=default即可，如

类名（）=default；

这就是个默认构造函数

而且**构造函数没有自己的名字，而是采用类名**，所以在类外构造时也应该用
[类名::类名]{.mark} 的方式声明

不同构造函数必须在参数类型或数量上有所区别

26.访问说明符public和private，**前者之后的成员在整个程序内可以被访问，定义类的接口**

**后者之后的成员可以被类的成员函数访问，但是不可以被程序中用到这个类的代码访问，细节被隐藏了。**

使用class和struct定义类大体是相同的，唯一的区别是他们的默认访问权限不同

如果使用[struct]{.mark}，那么[定义在第一个访问说明符之前]{.mark}的成员是[public]{.mark}的

如果使用[class]{.mark}，则这些成员是[private]{.mark}的

27.定义类相关的非成员函数，这些函数并不属于类本身，但是概念上说是属于类的接口的

定义这些函数的方式和定义其他函数一样，**但是一般要和类的声明（不是定义！）放在同一个[头文件]{.mark}内**，这样使用任何部分的接口都只需要引入一个文件

**如果想让这些非类内的函数访问private中的成员，只需要在类里面重复一遍函数的声明，并在开头加上friend关键字，如**

friend Sales_data add(形参列表)；即可

**上面友元的声明只能在类定义内部**，友元函数的声明没有限制，[并且友元具体位置不限且不受它所在区域访问控制级别的约束]{.underline}

对于类，**想把类声明成另一个类的友元**，方法则是在类内声明：

friend class(或struct) 类名

**这样它就可以访问另一个类里包括非公有成员的所有成员了**，注意友元之间[没有传递性]{.mark}。

友元的声明作用只是影响访问权限，而不是普通意义上的声明，**也就是说你可以在没有声明函数或类时声明友元**，但没真正声明函数或类的话是用不了函数或类的

28.**希望让数据成员可以被修改**，比如记录成员函数调用的次数时，只需在声明之前加[mutable]{.mark}关键字，把它变成[可变数据成员]{.mark}即可

29.如果类含有一个const成员函数，比如返回的是常量引用（**返回\*this，返回类型是const**），**那么调用这个函数后就不能使用其他成员函数对类的成员进行修改了**，因为返回过来的是个常量引用，把被调用对象变成常量了

30.**函数的形参列表根据其形参列表中的引用/指针有没有底层const可以进行重载**

如int fuctA(Account&);

和int fuctA(const Account&);

[是两个不同的重载函数]{.mark}，编译器可以根据实参是否是常量来推断调用哪个函数，因为非常量可以转换为const，**所以这俩函数都可以作用于非常量对象**，如果是指针的话则可以作用于指向非常量对象的指针，不过优先级比较低，有形参为非常量对象的函数则优先这个函数

31.当我们使用函数的名字时，该函数自动转化为指针，**并且我们可以直接通过指针调用该函数，不需要解引用**，要加也无所谓

Pf=function

bool b1=Pf(\"hello\")

32.就像可以把函数的声明与定义分开，先声明后定义一样，**我们也可以仅仅声明类而暂时不去定义它**：

class A;
这叫做[前向声明]{.mark}，这时候A就是个[不完全类型]{.mark}，**此时你只可以定义指向这种类型的指针，或者声明（不能定义）以不完全类型为参数或返回类型的函数**

同时要注意当类全部完成以后类才算是被定义，**所以一个类的成员类型不能是它自己**！！

但！是！一旦一个类的名字出现后，它就被认为是声明过了，**所以类允许包含指向它自身类型的引用或指针**

33.在定义友元的时候完全可以**只让某个类的某个成员函数作为友元**，此时要用到作用域运算符

**friend void window_mgr::clear(形参列表)**

这里就只把window的成员函数clear(返回类型为void)定义为了友元

当一个名字第一次出现在一个友元的声明中，我们隐式地假定该名字在作用域内可见，然而友元本身不一定真的声明在该作用域内

换而言之，**你可以随意地声明友元，但当你想调用该友元函数的时候，一定要在调用之前定义该函数，就算是在类内定义，也得在类的外部进行声明使得该函数可见。**

34.一个类就是一个作用域，在类作用域之外，普通的数据和函数成员只能由对象、引用或指针使用点运算符来访问，如果想访问的是[类定义的类类型成员]{.mark}(**类里含有类型为另一个自定义类的成员、指向它的指针、返回其他自定义类型的函数)，则用::**

35.一般来说，内层作用域可以重新定义外层作用域中的名字，因为外层名字会被隐藏，然而在类中，如果成员使用了外层作用域中某个名字，并且这个名字代表一种类型（另外一个自定义类型或者使用typedef别名）**那么类在内层作用域不可以重新定义这个名字**。

36.如果在内层作用域里想要**使用被隐藏掉的外层作用域参数**（同名的情况下会被隐藏）或者其他类中的public参数，可以使用类名::名字

直接获取，如果是外层作用域则不需要类名，直接::名字 获取即可

37.我们知道当构造函数只有一个参数时，输入其中的实参类型如果可以隐式转换成形参类型，那就会将其隐式转换，如果想避免这种[隐式转换]{.mark}，提高代码的可读性和安全性时，需要**在构造函数之前**加上[explicit]{.mark}关键字**使其被禁止隐式转换**，如

explicit func(int x);

**注意explicit只允许出现在[类内的构造函数声明]{.mark}处**！并且只能用于直接初始化，**不能用于拷贝初始化**！

**注意这个抑制的是隐式转换，但我们仍然可以对其使用显式转换进行类型转换**，对传入实参用static_cast\<\>即可

38.我们在写函数时，**要注意返回的参数在函数返回时是否还存在：只有返回后还持续在外部作用域存在的参数才可以被返回**，比如说

const string & findMaxWrong ( const vector \< string \>& arr )

{

string maxValue = arr \[0\];

for ( inti =1; i \< arr . size ();1++)

if ( maxValue \< arr \[ i \])

maxValue = arr \[ i \];

return maxValue ;

}

这里面的返回参数maxValue是个[局部变量]{.mark}，如果不对其进行复制直接返回，在某些编译器中可能会因为maxValue在返回时不复存在而引发错误

与之相反，如果把maxValue作为索引返回arr\[maxValue\]，由于arr在函数外部持续存在，返回时不会消失，于是这样的返回就不会引发错误

39.vector或数组读入一行序列，序列元素是字符或者数，不同元素之间用空格隔开的方法：

先定义一个string line,再使用getline函数

下面以输入字符数不定的字符串为例

int main()

{

string line;

cin \>\> line;

getline(cin, line);

vector\<string\> elements;

istringstream iss(line);

string element;

while (iss \>\> element)

{

elements.push_back(element);

reverse(elements.begin(), elements.end());

}

\...\...;

}

这里关键在于iss，创建了一个字符串流对象iss（如果line是整数那就是整数流对象），并且使用\>\>运算符从流中提取string添加到vector中，后面用reverse函数把vector元素正过来

注意这里想使用iss的话要#include\<sstream\>

用getline要#include\<string\>(不要h)

用vector则是#include\<vector\>

40.定义一个返回this对象的成员函数的步骤（类内）：

类类型& 函数名（形参列表）

{ //对类类型成员进行改变

return\*this;

}

这样就可以通过调用这个对象的成员函数来改变这个对象的成员了

41.委托构造函数：使用它所属类的其他构造函数执行它自己初始化过程，把自己的一些或全部指责委托给其他构造函数

用法：

类名（委托构造函数的形参列表）：类名（实参）{ }

后面的类名（实参）就是被委托的构造函数被赋予了实参

42.编译器只会自动地执行一步类型转换，比如

把"line_line"转换为string，再把这个临时的string转化为自定义类XX，这样就是错误的

可以直接进行一步显式转换

XX（"line_line"）

对于无法通过类类型转换进行读入的，可以直接从istream读入XX，如果要用到XX就可以

cin\>\>xxx;

item.combine(cin);，这里设xxx是XX类型的

43.范围for语句

for(declaration:expression)

statement

中expression表示的必须是一个序列，共同特点是拥有能返回迭代器的begin和end成员，包括初始值列表，数组，str,vector,list等等。declaration定义一个循环变量，序列中每个元素都能转换成该变量的类型，（可以直接用auto），如果要对序列元素执行写操作则必须声明成引用类型！

44.聚合类：当一个类满足：a.所有成员都是public的，b.没有定义任何构造函数，c.没有类内初始值，d.没有基类，也没有virtual函数，我们就说它是聚合的（聚合类）比如

struct Data{

int ival;

string s;};

可以通过Data vall={0,\"anna\"};
这样列表初始化的方式初始化聚合类的数据成员，初始值的顺序必须与声明的顺序一致，默认初始化的方式和前面的数组元素一样，靠后的被默认初始化。

这样显式初始化只适合所有成员都是public的类对象，且修改很麻烦

45.字面值常量类

除了算数类型，引用和指针外，某些类也是字面值类型，可以作为constexpr函数的参数和返回值。和其他类不同，字面值类型的类可能含有constexpr函数成员，这些成员必须符合constexpr函数的所有要求，是隐式const的

数据成员都是字面值类型的聚合类是字面值常量类，除此之外，满足以下要求的非聚合类的类也是字面值常量类：

a.数据成员都必须是字面值类型，b.类至少含有一个constexpr构造函数，c.如果一个数据成员含有类内初始值，那么内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数；d.类必须使用析构函数的默认定义，它负责销毁类的对象

Constexpr构造函数

构造函数不能是const的，但字面值常量类的构造函数可以是constexpr函数，且必须至少提供一个。constexpr构造函数可以声明成＝default，否则constexpr构造函数体一般来说应该是空的，声明方法例如：

constexpr Debug(bool b=true)：hw(b),io(b),other(b){ }

（这里hw,io,other都在类内声明了）

必须初始化所有数据成员，初始值constexpr构造函数用于生成constexpr对象以及可以输入constexpr函数的参数或其返回类型。

46.C++的条件运算符

(condition)?expr1:expr2;相当于简单的ifelse，condition返回真（不等于0）执行expr1,返回假执行expr2

逻辑运算符：

逻辑非：! ；逻辑与：&& ；逻辑或：\|\|

运算顺序依次递减

47.类的静态成员：有的时候需要类的一些成员和类本身相关，而不是和类的各个对象保持关联，并且在这些成员改变时其他用到它的对象使用它们的新值，这时候应该声明静态成员，方法：在声明之前加上关键字static使其与类关联在一起（可以是成员或者成员函数），这样的成员可以是public或private的，声明以后这些成员被所有这种类的对象共享，类似的，静态成员函数不与任何对象绑定在一起，不包含this指针且不能声明为const的，也不能在函数里面使用this指针（同时适用于this的显式使用和隐式使用）

使用类的静态成员

使用作用域运算符直接访问静态成员：

double r;

r=Account::rate();

也可以通过ac1.rate();

或ac2-\>rate();的方式从类对象里获取，类的成员函数不用作用域运算符就可以直接使用静态成员

在类的外部定义（不是声明）静态成员时，不能重复static关键字（因为你已经在类内用static声明了），直接在成员名前用类名::即可

因为静态成员不属于类的任何一个对象，所以它们不是由构造函数初始化的，我们必须在类的外部定义和初始化每个静态成员并在类内用static声明

类似于全局变量，静态数据成员定义在任何函数之外，它一旦被定义就一直存在于整个程序生命周期中，它的定义可以访问类的私有成员（你可以用私有成员去定义它）

静态成员的类内初始化

我们可以为静态成员提供const整数类型的类内初始值（这要求静态成员必须是字面值常量类型的constexpr）例如：

static constexpr int
period=30;//这是在类内部进行的操作哦，这个时候静态成员变量值不会改变

初始值必须是常量表达式，我们可以把这样初始化的静态成员用在所有适合于常量表达式的地方

如果某个静态成员变量的值可以在编译期间确定并且不会改变，可以在类中直接初始化为const或constexpr，不需要在类外再定义一次，但是如果在编译期间无法确定这个变量的值（比如运算时根据条件对其进行赋值），那么必须在类外对其进行定义，用上面的举例：

constexpr int 类名::period=30；

（在类外这么定义），确保程序某个编译单元中有一份该静态成员的实际储存空间

静态成员独立于任何对象，因此可以在某些非静态成员非法的场合下使用，比如它可以是不完全数据类型（只声明未定义），或是它所属的类类型（而不必声明成它所属类的指针或引用）而且我们可以使用静态成员作为默认实参

48.IO类：标准库定义了几种头文件用于支持不同种类的IO操作（含w的意味着是宽字符版本的IO操作）

头文件iostream：(w)istream 从流中读取数据

(w)ostream 向流写入数据；(w)iostream 读写流

头文件fstream：(w)ifstream 从文件读取数据；(w)ofstream
向文件写入数据；(w)fstream 读写文件

头文件sstream：(w)istringstream 从string读取数据；(w)ostringstream
向string写入数据；(w)stringstream 读写string

宽字符（wchar_t）类型的数据操作在原来的符号前加w即可，比如wcin,wcout,wcerr，这些都和普通char版本的类型定义在同一个头文件中

IO类型间的关系

概念上，设备类型和字符大小都不会影响我们的IO操作
不管是从控制台窗口，磁盘文件或者string中读取，又或是决定字符存入哪个对象((w)char_t)都不用管，这是标准库通过继承机制实现的，利用模板（在算法那个有说）可以使用具有继承关系的类而不必了解细节（后面会说）

简单来说，继承机制使我们可以声明一个特定的类继承自另一个类，我们通常可以把继承类当成被继承的类来使用，原来怎么用现在怎么用

49.我们不能拷贝或者对IO对象赋值。所以进行IO操作的函数通常以引用的方式传递和返回流（引用不能是const的，因为读写一个IO对象会改变其状态）

50.进行IO操作时，可能会发生IO错误，比如

int ival; cin\>\>ival;

这时如果键入Boo，这时cin就会进入错误状态（希望读入int却读入了char\'B\'），一个流一旦发生错误，其上后续所有的IO操作都会失败（只有处于无错状态时才可以从流读取数据或写入数据），最简单的检测流对象状态的方法就是把它当做一个条件来使用

while(cin\>\>ival)

如果处于无错状态，那么条件为真，但是这种检测方式无法检测出具体发生了什么错误，IO库定义了一个与机器无关的iostate类型来提供表达流状态的完整功能，这个类型有四个constexpr值标识特定的位模式，可以与位运算符一起使用来检测或设置多个标志位

下面是一些常用的操作

s.clear()
将流s中的所有条件状态位复位，把流状态设置成有效，返回void；s.rdstate()
返回流s的当前条件状态，类型为strm::iostate

s.setstate(flags)
根据给定的flags标志位，把流s对应条件状态位置为flags对应位,flags类型为strm::iostate

所以可以通过类似

auto old_state=cin.rdstate();

\...

cin.setstate(old_state); 的操作来把cin置为原有状态

51.输出缓冲

每个输出流都管理一个缓冲区，用来保存程序读写的数据，比如os\<\<\"hello\";这里的文本串可能立刻被打印出来，也可能被操作系统保存在缓冲区中之后打印。缓冲区的存在有利于系统的性能提升

导致缓冲刷新的原因有很多：a.程序正常结束，作为main函数return操作的一部分，缓冲刷新被执行；b.缓冲区满了的时候需要缓冲刷新；

c.使用如endl的操作符显式刷新缓冲区

此处操作符有：endl 输出文本串加一个换行后刷新；flush
只输出文本串后刷新，不附带任何字符；ends 输出文本串加一个空字符后刷新

d.操作符unitbuf和nounitbuf

如果想在每次输出操作后都刷新缓冲区，使用unitbuf，它告诉流在接下来的每次写操作之后都执行一次flush操作；而nounitbuf则重置流，使其回到正常的缓冲方式

cout\<\<unitbuf；//改变缓冲机制

\.....

cout\<\<nounitbuf; //回到正常的缓冲方式

e.一个输出流可能被关联到另一个流，这时读写被关联的流时，关联到的流的缓冲区会被刷新

比如，标准库把cout和cin，cerr关联在一起，当cin\>\>ival;时会导致cout缓冲区被刷新

tie函数有两个重载版本：1.当tie不带参数时比如cin.tie();
这时返回指向它的输出流的指针，如果被关联的对象是输出流比如cout.tie();
时返回的就是指向这个流本身的指针，如果单独tie();则返回空指针

2.当tie接受一个指向ostream的指针时，将自己关联到此ostream，即x.tie(&ostream);
把流x关联到输出流ostream,这里x可以是任何流，返回类型是指向基础数据流类型的指针

举个例子：

cin.tie(&cout);

ostream \*old_tie=cin.tie(nullptr);
//等式右侧返回cin之前关联的输出流，即cout，在这之后又将nullptr绑定给cin重置其绑定关系

cin.tie(&cerr);

cin.tie(old_tie); //重建cin和cout的关联关系

由此可见，这种tie函数的机制是: x.tie(&ostream1);
返回x之前绑定的输出流（没有就返回空指针），并且之后把x绑定到ostream1上，多个流可以关联同一个ostream

52.文件输出输入

我们可以用IO运算符\>\>和\<\<来读写文件，可以用getline从一个ifstream读取数据，fstream提供的操作和前面知道的对cin和cout的操作一样，但是有一些它独有的操作（不能对其他IO类型使用）

fstream fstrm(s);
创建一个fstrm并且打开名为s的文件，这里名字s可以是string类型，也可以是一个指向C风格字符串的指针。默认的文件类型依赖于fstream的类型

fstream fstrm(s,mode); 按指定类型mode打开文件，其他和前面一样

fstrm.open(s);
打开名为s的文件并把文件与fstrm绑定，默认文件类型mode依然取决于fstream类型，它返回void

fstrm.close(); 关闭与fstrm绑定的文件,返回void

fstrm.is_open();
返回一个布尔值，指出与fstrm关联的文件是否成功打开且尚未关闭

如果提供了一个文件名s，则open会被自动调用

这里open还可以在文件末尾加字符串，比如s.open(ifile+\"2\");

53.用fstream代替iostream&

在要求使用被继承对象（基类型对象）的地方，可以用继承类型的对象来替代，这意味着接受一个iostream类型引用或指针的函数，可以用一个对应的fstream或sstream类型来调用

比如形参是ostream&,可以让实参为ofstream类型的对象来调用函数

54.一个文件流open操作失败的时候，这个文件流就会进入错误状态，要通过.close()操作把它成功关闭后才能继续使用这个文件流

55.有时候我们也会给main传递形参，比如说main函数位于可执行文件prog之内，我们想向程序传递一些命令行选项

这个时候命令行选项通过两个（可选的）形参传递给main函数

int main(int argc,char\*argv\[\])

这里第二个形参是数组，储存指向C风格字符串的指针（末尾有空字符），因此argv也可写成
char\*\*argv

尤其应该注意的是，这个时候输入格式是

prog(即main所在的文件名) \...

因此数组的第一个元素（索引为0）一直都是程序的名字，用户输入的可选的实参从1开始

当main函数接受一个要处理的文件（通过文件名字传递），可以通过如下操作对文件进行逐个处理

for(auto p=argv+1;p!=argv+argv;++p){

ifstream input(\*p);
//打开文件，创建输出流，记得对p解引用，因为返回地址！

if(input){\...//检验打开是否正常，后续操作省略 }

}

这里每次循环input都被重新构造，因为它是循环的局部变量（在循环内定义），每次循环中会创建和销毁一次，当fstream被销毁时，close会自动被调用。

56.每个流都有关联的文件模式用来指出流怎么使用文件

in 以读方式打开文件，只可以对ifstream或fstream对象设定；

out 以写方式打开文件，只可以对ofstream或fstream对象设定；

app
每次写操作前均定位到文件末尾，只要trunc没被设定，就可以设定，此时文件总是以out模式打开（不需要设定）；

ate
打开文件后立刻定位到文件末尾，可用于任何对象，也可与其他设定组合使用；

trunc 截断文件，只可当out也被设定时才可以设定；

binary 以二进制方式进行IO，也可用于任何对象和与其他设定组合使用

默认情况下，即使我们没有指定trunc，以out模式打开的文件也会被截断（比如当我们打开一个ofstream时，文件的内容会被丢弃，此时隐含以输出形式打开文件并且截断的意思），为了保留以out模式打开的文件的内容，我们需要同时指定app模式，这样只会把数据追加写到文件末尾，不会损失前面内容；或者指定in模式，打开文件同时进行读写操作

指定文件模式的操作：

ofstream streamName(\"fileName\",ofstream::out \| ofstream::app);

指定多种文件模式用\|隔开

57.istream从string读取数据，ostringstream向string写入数据（这些都是头文件sstream中的），而头文件stringstream两种操作都可以。sstream定义了几种特有的操作，只能对stringstream对象使用

sstream strm(s); //strm是一个sstream对象，保存string
s的一个拷贝，这个构造函数是explicit的，禁止隐式转换

strm.str(); //返回strm所保存的string的拷贝

strm.str(s); //将string s拷贝到strm中替代流内容，返回void

当我们的某些工作是对整行文本进行处理，而其他工作是只处理一些单词时，可以使用istringstream。比如我们想接受一个人名+一个或多个电话的字符串并储存数据
可以进行如下操作

struct PersonInfo{

string name;

vector\<string\> phones;}; //创建一个类来保存人名和号码

读取和分开保存人名及电话的操作如下

string line,word;

vector\<PersonInfo\> people; //创建之后用于保存的对象

while(getline(cin,line)){
//把输入全部储存到line，然后再想办法分开储存单词与号码

PersonInfo info;

istringstream record(line); //创建流record，拷贝line值

record\>\>info.name;//因为输入总是名字在前，所以先读取名字

while(record\>\>word)

info.phones.push_back(word);
//一个名字后面可能跟有多串号码，所以用while进行多次读取，直到换行后停止

people.push_back(info);}//把记录置入people中保存

58.当我们逐步构造输出（进行某种选择），然后希望选择后的内容一并被打印的时候，建议使用ostringstream

例如，对上面的例子，我们想把无效号码去除到一个新文件并打印一条错误信息，把有效号码换个格式再打印一条正确信息。我们可以先把要输出的内容写入到内存ostringstream中

for(const auto &entry:people)
//只进行写操作，声明为常量引用，使用范围for循环遍历people

{ ostringstream formatted,badNums;//创建保存正确信息和保存错误信息的流

for(const auto&nums:entry.phones){

if(!valid(nums))//伪代码，表示失效

{ badNums\<\<\" \"\<\<nums;//把失效数的字符串形式（注意类型）存入badNums

}

else formatted\<\<\"
\"\<\<format(nums);//依然是伪代码，format意思是格式，这里存入转换格式后的数字符串，插入\"
\"空格是为了分开每一段数据，上下同

}

cout\<\<entry.name\<\<\" \"\<\<formatted.str()\<\<endl;

//打印名字格式化的字符串，是一一对应打印的。后面打印错误信息也是一样的，省略

59.顺序容器：不依赖于元素的值，而是与元素加入容器时的位置相对应。标准库中顺序容器类型有：

vector
可变大小数组，支持快速的随机访问（没有方向限制），在除末尾之外的地方插入或删除元素会很慢（线性复杂度）

deque
双端队列，支持快速随机访问。在头尾位置插入或删除元素很快，其他位置很慢

list 双向列表，只支持双向顺序访问，但是在任何位置插入或删除都很快

forward_list 单向链表，只支持单向顺序访问，在任何位置插入或删除都很快

array 固定大小数组，不能添加或删除元素

string 与vector相似，但专门用来保存字符

选择容器的基本原则：

除非其他容器优势明显更大时，都应该采用vector

程序有很多小的元素并且对空间的额外开销很敏感时不要用两个链表

如果又想在中间插入元素，随后又想随机访问元素，可以在输入阶段使用list，然后确保输入完成后把list拷贝到vector

如果想把上面两个操作不定顺序地进行，只能根据执行的操作是访问更多还是插入更多，根据链表和vector/deque的相对性能进行取舍

60.一般来说，每个容器都定义在一个头文件中，文件名就是类型名，它们都是模板类，需要提供元素类型比如list\<double\>,下面介绍对所有容器适用的操作以及仅适用于顺序容器的操作。

虽然我们可以在容器中保存任何类型元素，但是容器的一些操作对于元素类型有自己的要求。比如说有一个接受容器大小参数的容器的构造函数，当使用这个构造函数来构造容器时它会使用元素类型的默认构造函数来初始化容器，如果这个类没有默认构造函数，我们就必须得在构造这种容器时提供一个元素初始化器(为每个元素提供初始值的容器)，如

vector\<\> v1(3,init);
这里init为元素初始化器，可以是类似于{3,7,0}这样的形式

容器一些操作如下

![](media/image1.jpeg){width="5.384091207349082in"
height="8.3224343832021in"}

61.forward_list的迭代器不支持递减操作，迭代器的算数运算只适用于string,vector,deque和array的迭代器

迭代器范围：由一对分别指向容器中的元素和范围尾元素后一位置的迭代器表示，通常叫做begin和end，第二个迭代器指向的从来不是范围中最后一个元素，而是最后一个元素的后一个位置，因此它们表示的范围区间\[begin,end）是左闭右开的
（即使后面那个位置没有直接说明是end，它依然是左闭右开的）。

这样左闭右开的区间有一些良好的性质：如果begin等于end，那么集合为空；如果不等于，那么范围至少包含一个元素；我们可以对begin进行递增使其与end相等

这意味着我们可以通过while(begin!=end)配合上++begin来遍历整个范围，在循环中begin必然指向一个元素，因此可以放心解引用。

62. 除了已经使用过的迭代器类型，大多数容器还提供反向迭代器，是一种反向遍历容器的迭代器，与正向迭代器相比，反向迭代器各种操作符的含义发生了颠倒，比如对它执行++操作得到的是上一个元素。

    剩下的就是类型别名了，通过类型别名，我们可以在不知道容器中元素类型的情况下使用容器（和模板很像）。如果需要元素类型，用value_type；如果需要元素类型的一个引用，可以使用reference或const_reference等，这些类型别名在泛型编程中大有所为。

    使用这些类型别名时，必须显式地使用其类名，记得用作用域运算符，如

    list\<string\>::iterator iter;
    //iter是通过list\<string\>定义的一个迭代器类型

    vector\<int\>::difference_type count;
    //count是通过vector\<int\>定义的一个difference_type类型

63. begin和end有多种版本,比如说60的图中展示的反向迭代器rbegin，常量迭代器cbegin/crbegin等等，得到迭代器的最佳方法是使用auto，如

    auto it1=a.cbegin();
    //const_iterator，意味着我们不需要写访问，并且使用auto得到对应a类型容器的迭代器

64. 每个容器类型都定义了一个默认构造函数，除了array之外其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受确定容器大小和元素初始值的参数![](media/image2.png){width="5.084285870516186in"
    height="3.9779090113735784in"}

    将一个新容器创建为某个容器的拷贝有两种方法，一是直接拷贝整个容器，还有一个就是拷贝由一个迭代器对指定的元素范围，前者要求两个容器类型及元素类型必须匹配，后者则比较宽松，只要被拷贝的元素类型能转换为新容器的元素类型就好。下面演示后者的拷贝初始化。

    forward_list\<string\>
    words(articles.begin(),articles.end());//设这里articles是vector\<const
    char\*\>类型的

    deque \<string\> authList(authors.begin(),it);
    //it是指向authors某个元素的迭代器，这个操作拷贝了authors中直到it（但是不包含it，左闭右开）的元素

65. 只有顺序容器的构造函数才支持类似于

    vector\<int\>ivec (10,-1);

    deque\<string\> svec(10);
    //前者构造十个初始化为-1的int，后者默认初始化十个空串

    的接受大小参数的初始化方法，关联容器不支持

    并且具有默认构造函数的类的顺序容器才支持后一种初始化方法，否则需要像第一种一样提供初始值

66. 标准库类型array

    和内置数组一样，标准库array的大小也是类型的一部分，当定义一个array时，不仅要指定元素类型，还要指定容器大小

    array\<int,42\> 而使用array类型的时候也必须同时指定元素类型和大小

    array \<int,42\>::size_type i ; //如果没有大小则发生错误

    由于大小也是array类型的一部分，它的构造函数都会显式或隐式地确定容器大小，而允许用户自定义大小参数不建议使用，多余且易错。array所定义的默认构造的array是非空的，包含了与其大小一样多的元素，元素都被默认初始化（这点也和内置数组一样，要注意类要有默认构造函数）对其进行列表初始化时，列表元素个数要小于等于array大小，如果小于，则优先初始化array中靠前的部分

    与内置数组不同的是，array可以进行拷贝或对象赋值操作。

    int digs\[7\]={0,1,2,3,4,5,6}; int cpy\[7\]=digs; //错误操作

    array\<int,7\> digits ={0,1,2,3,4,5,6};

    array\<int,7\> copy =digits;
    //正确操作，要求元素类型，容器类型与大小相同

67. 赋值，assign和swap

    赋值运算符的机制是将左边容器中的元素替换为右边容器元素的拷贝，所以列表初始化右边的列表也是一个容器。如果两个容器原来大小不同，赋值运算后两者大小都与右边容器相同，因此array类型允许赋值初始化，但是不支持花括号赋值。

    注意这里的区分：我们这里的赋值初始化发生在初始化过程中，此时可以用其他大小小于等于array的容器初始化它，但是赋值特指初始化之后进行赋值，比如

    c1={a,b,c};
    //这里就让c1大小为3，和右边容器相同了，c1初始化过了且不是array

    array\<int,10\> a2={11}; //这里就是赋值初始化了，是被array允许的

    array\<int,10\> a2; a2={11}; //错误，这是赋值操作

    assign操作：除了array以外的顺序容器都定义了一个名为assign的成员，它允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值，这种操作用参数所指定的元素的拷贝替换左边容器中的所有元素

    seq.assign(il) 将seq中的元素替换为初始化列表il中的元素

    seq.assign(b,e)
    将seq中的元素替换为迭代器b和e表示的范围中的元素（左闭右开）。迭代器be和e不能指向seq中的元素！

    seq.assign(n,t) 将seq中的元素替换为n个值为t的元素

    这里assign的要求非常宽松，比如我们可以将一个vector中的一段char\*值赋予一个list中的string:

    list\<string\> names; vector\<const char\*\> oldstyle;

    names.assign(oldstyle.cbegin(),oldstyle.cend());

    在assign操作中旧元素被替换了，因此会导致左边容器内部的迭代器、引用和指针失效。但是下面介绍的swap操作将容器内容交换不会导致它们失效。（除了array和string）

    swap操作交换两个相同类型容器的内容，这个操作会很快，因为元素本身并没有被移动，交换的是两个容器内部数据结构，这意味着指向容器的迭代器，引用和指针都不会失效，只是属于了不同容器。但是有两个特殊情况，一种是对string使用swap操作会导致迭代器引用指针失效（此时依然很快）；另一种特殊情况是对于array，swap操作会真正交换他们的元素，因此交换两个array元素所消耗时间与array元素数目成正比，并且会导致迭代器引用指针失效

    swap(c1,c2)和c1.swap(c2)
    都是交换c1和c2中的元素，c1和c2必须具有相同的类型，swap通常比拷贝快得多。这里前者是非成员函数版本的swap，后者是成员函数版本的swap，养成使用非成员函数版本的swap对后面的泛型编程来说是个好习惯。

68. 每个容器类型都有三个与大小相关的操作：成员函数size,empty和max_size(forward_list只支持除了size以外的两个)

    size返回容器中元素的数目；empty根据容器是否为空返回布尔值，size为0时返回true反之为false；max_size返回当前环境下该类型容器能容纳的最大元素数量（是无符号整数），它受到系统内存，编译器等等的限制（注意不是返回当前的元素数量或是已分配内存的大小）

    在两个相同类型的除了无序关联容器外的所有容器都支持关系运算符\>,\<,\>=,\<=，运算规则是：两个容器大小相同且每个位置元素对应相等，则容器相等，反之不等。如果两个容器大小不同，但比较小的那个的每个元素对应相等于比较大的那个，则比较小的那个小于大的那个。如果两个容器没有上面的对应情况，则比较第一个出现不同的元素，按照比较结果决定大小

    这说明只有容器内元素类型定义了关系运算符时，容器之间才能比较，否则发生未定义错误。

69. 顺序容器（除array）特有的添加操作

    ![](media/image3.png){width="5.90955271216098in"
    height="4.379412729658792in"}

    注意最后黑框中的提醒，在编写程序时最好能够先输入，确定完成后再使用迭代器指针等等操作。必须牢记不同数据的不同使用策略，因为这会严重影响性能，下面介绍不同的操作的适用容器：

    1.push_back:除了array和forward_list之外的所有顺序容器（包括string）都支持push_back操作，具体用法是
    container.push_back（word）;
    把元素word追加到容器container尾部，只要word和容器元素类型一致就好，它会改变容器的size

    2.push_front:支持此操作的容器类型：list,forward_list和deque，它将元素插入到容器头部，这就意味着它会改变容器内元素的索引

    3.insert:它允许我们在任意特定位置添加一个或多个元素，vector,deque,list和string都支持一般版本的insert，而forward_list提供了特殊版本的insert

    每个insert函数接受一个迭代器作为其第一个参数，将元素插入迭代器所指定的位置之前，比如slist.insert(iter,\"Hello!\")把Hello!插入到iter前一个位置。有些容器不支持push_front，但是所有顺序容器都支持insert操作，因此可以用slist.insert(slist.begin(),xxx)的方式替代push_front

    除此之外，insert函数还有更多的功能，它可以接受更多的参数，有以下三种情况

    第一种比如svec.insert(sevec.end(),10,\"Anna\");
    它第一个参数接受一个迭代器，第二个参数接受一个元素数目，最后一个参数则是想插入的元素。作用是在迭代器表示的位置之前插入元素个数个元素

    第二种比如
    slist.(slist.begin(),v.end()-2,v.end());把其他容器中两个迭代器之间的元素插入给定迭代器之前，这个范围依然是左闭右开的，比如这里把v的后两个元素插入了svec(end指向容器尾后一个元素)。这里的v不能是slist自己。

    第三种情况比如slist.(slist.end(),{\"1\",\"2\",\"3\"});把列表中的所有元素插入给定迭代器位置之前。

    insert另一个特性是返回一个指向插入的新元素的迭代器，因此可以通过类似下面的方式代替push_front操作

    list\<string\> lst; auto iter = lst.begin();

    while(cin \>\> word)

    iter = lst.insert(iter,word);

<!-- -->

4.  emplace:对比insert操作是将某些元素拷贝到容器中，emplace操作是将某些元素构造到容器中，和push，insert操作对应，emplace也有emplace,emplace_back,emplace_front三种版本且用法和push与insert一样区别是调用emplace的时候会在内存空间中创建新的对象，如c.emplace_back(25)创建了一个新的int对象，和c.push_back(int(25))很像不过后者创建的是一个临时对象

    c.emplace_back()则是使用类型的默认构造函数构造默认值，把默认值置于容器尾部

<!-- -->

70. 在局部作用域内，有些类型不会被默认初始化，分别是：基本数据类型（整数，浮点数，字符，布尔值，空类型），以及没有默认构造函数的类型在哪都不会被默认初始化。除此之外的类型例如string等等有默认初始化的非基本数据类型都会被默认初始化，要注意。局部作用域包括int
    main的作用域哦，在main函数之外的才是全局作用域，会被默认初始化

71. 关于可变性的一些补充：全局容器和全局变量(声明在int
    main之外的容器和变量)是可以被局部作用域修改的，比如函数。但是在局部作用域声明的容器和变量(包括在int
    main里声明的变量与容器)是只能在该作用域内被修改的，不能被其他级作用域修改。同样地，如果没在局部作用域内重载外部或内层变量的名字，直接使用外部变量或局部作用域内的局部作用域定义的局部变量的名字进行修改操作会报错，因为未在本作用域声明。或者函数形参为引用类型比如void
    func_a (vector\<int\> &A, int
    &v1)这时候也可以修改A和v1而不必在全局作用域声明A与v1了。

72. 访问容器中的元素操作有：(以下操作只适用于string,vector,deque,和array)

    c.back() 返回c中尾元素的引用

    c.front() 返回c中首元素的引用

    c\[n\] 、c.at(n) 返回c中下标为n的元素的引用，后者越界会抛出异常

    上面所有除了c.at(n),在越界或容器为空时行为都是未定义的，而且因为返回的都是引用，在容器非const的时候可以对容器进行写操作。

    删除容器的操作有：(以下操作容器不包括array)

    c.pop_back() 删除c中尾元素，返回void，forward_list不支持此操作

    c.pop_front() 删除c中首元素，返回void，vector与string不支持此操作

    c.erase(p)
    删除迭代器p指定的元素，返回一个指向被删元素后一位的元素的迭代器，包括尾后迭代器，除此之外的行为未定义

    c.erase(b,e)
    删除迭代器b和e指定范围内的元素，返回指向最后一个被删元素后一位元素的迭代器，范围还是左闭右开。若e是尾后迭代器，那也返回尾后迭代器

    c.clear() 删除c中所有元素返回void

    对于forward_list有特殊版本的erase

73. 特殊的forward_list操作

    对于单向链表，添加或删除元素之前的那个元素的后继会被改变，为了添加或删除一个元素，由于获取元素的前驱对于单向链表很困难，于是添加删除元素的操作是通过改变给定元素之后的元素来完成的，实现方式与其他容器操作有所不同。下面是介绍：

    ![](media/image4.png){width="5.158081802274715in"
    height="3.562315179352581in"}

74. 改变容器大小的操作：我们可以通过resize关键字来改变容器大小(array不支持此操作)

    c.resize(n)
    调整c的大小为n个元素，如果n\<c.size()，那么多出来的元素会被丢弃，新增的元素被默认初始化

    c.resize(n,t) 调整c的大小为n个元素，任何新添加的原始被初始化为t

    显然缩小操作会使得容器的引用指针迭代器失效，有时候增大操作也会使其失效，关于失效的总结如下

    ![](media/image5.png){width="5.042954943132108in"
    height="3.8454461942257216in"}

    因此在循环中调用erase,insert等操作时，应该auto一个迭代器储存迭代器并且在每次循环末尾进行更新，以防失效。特别注意的是由于尾后迭代器无论是删除还是添加都会被导致失效，所以不应该auto一个迭代器类型来储存尾后迭代器，而应该反复调用end()来获取。

75. 对于可变类型vector和string，如果和定义一样在每次连续存储时都重新分配内存空间，把元素移动到新空间再释放旧空间内存的话，性能会变得非常慢，因此为了减少重新分配内存的次数，vector和string在每次获取新的内存空间时往往会分配比需求更大的内存空间，以提高其性能。

    因此，vector和string提供了一些成员函数，允许我们与它的内存分配实现互动。

    c.capacity()
    告诉我们如果不重新分配内存空间，c可以容纳多少个元素，返回类型与size()相同，可以进行关系运算符比较

    c.shrink_to_fit() 把c能容纳元素个数上限降低到size()

    c.reserve(n)
    分配至少能容纳n个元素的内存空间(是总的内存空间，不是额外的)

    第一种只适用于vector string和deque，后两种只适用于vector和string

    只有当需求内存空间大于当前容量时调用reverse才会改变vector容量，至少分配与需求一样大的空间(可能更大)。而。shirnk_to_fit则退回多余的空间，然而再具体的实现中此请求可能被忽略，不能保证调用了就一定会退回。

76. 补充一下位运算符

    位运算符作用于整数类型的运算对象，并把运算对象看作是二进制位的集合(十进制数通过除二求余法转化为二进制)，位运算符提供检查和设置二进制位的功能。

    一般来说，如果作用对象是小整形，则它的值会被自动提升为较大的整数类型，运算对象可以带符号也可以不带符号，但是位运算符如何处理符号位要依赖于机器，因此建议只把位运算符用于处理无符号类型

    移位运算符(满足左结合律)
    ：对其运算对象进行基于二进制位的移动操作，令左侧对象按照右侧对象的要求进行移动指定位数，然后将经过移动或者提升的左侧运算对象的拷贝作为求值结果，[要注意的是右侧运算对象一定不能为负]{.mark}，且值必须严格小于结果的位数。如果通过左移或右移移出边界，那这部分的位就被舍弃了。expr1
    \<\< expr1或expr1 \>\> expr2

    左移位运算符\<\< 在右侧插入值为0的二进制位，比如bit \<\<
    8就是往右侧插入八个值为0的二进制位(这之前可能提升bit)，这代表着向左进阶了，增大了数的绝对值

    右移位运算符\>\>
    其结果依赖于左侧运算对象类型，如果是无符号类型，往左侧插入值为0的二进制位，如果是带符号类型，往左侧插入符号位的副本或者值为0的二进制位，依环境而定。这代表着往右侧移动k位的这k位会被舍弃掉

    位求反运算符 \~
    它把二进制数每一位求反，也就是1变成0，0变成1，使用方法是\~expr

    位与运算符 & 用法是expr1 & expr2
    如果两个运算对象对应位置都是1，则该位置运算后为1，否则该位置为0

    位或运算符 \| 用法是expr1 \| expr2
    如果两个运算对象对应位置至少有一个是1，那运算后该位置为1，都为0该位置才为0

    位异或运算符 \^ 用法是expr1 \^ expr2
    如果两个运算对象对应位置有且只有一个为1，那么运算后该位为1，否则为0

    对一个数进行左移操作\<\<，从二进制上看就是前进一位并补0，也就是把整个数✖️2，所以number
    \<\< n就是把这个数乘以2\^n

    同样地，右移操作\>\>就是右移一位，舍弃末尾，所以相当于除2，由于舍弃了末尾一位数，所以自动向下取整，这也是为什么整数除法会向下取整。

77. 运算符优先级表，把握不住就多加括号，从上到下优先级递减

    ![](media/image6.png){width="3.50962489063867in"
    height="3.1975470253718283in"}![](media/image7.png){width="3.7455325896762903in"
    height="4.216451224846894in"}

78. 额外的string操作

    构造string还有其他多种方法【下面的n,len2,pos2必须为无符号值】

    string s(cp, n) 这里cp是数组，s拷贝数组中前n个字符

    string s(s2, pos2)
    这里s2也是string，s拷贝从s2下标pos2开始到最后的字符，如果pos2＞s2.size()则操作未定义

    string s(s2, pos2, len2) s拷贝s2从下标pos2开始的len2个字符

    当我们从一个const
    char\*来拷贝构造string时且不传递计数值，因为前者以一个空字符结尾，所以拷贝得出的string也以空字符结尾，如果传递计数值，则不必以空字符结尾了。当然计数值不能大于size，否则未定义

    string的额外操作

    substr
    返回string的子序列，接受一个(可选的)位置和长度参数，比如s.substr(0,5)返回s中从0位置开始包括零位置，到后面共五个字符的子string。对于给出位置和长度参数的构造或substr，如果长度参数大于后面的字符个数
    那就默认直到字符数组结尾。

    string提供了接受下标版本的insert和erase操作，下标指出从该位置后开始插入的位置以及开始删除的位置

    s.insert(pos, num, args)
    在pos之前插入num个args指定的字符,nums是可选的，pos可以是下标或者迭代器，下标返回指向s的引用，迭代器返回指向第一个插入的字符的迭代器

    s.erase(pos,len)
    删除从pos开始的len个字符，len是可选的，没有的话默认从pos开始到最后

    s.assign(args) 将s中的字符替换成args指定的字符

    s.append(args) 将args指定的字符追加到s，返回指向s的引用

    s,replace(range, args)
    删除s中范围range内的字符，替换成args指定的字符，range可以是一个下标加长度，也可以是一对迭代器。返回一个指向s的引用

    args可以是字符串、"字符串位置,长度" 表示的子串、"字符数组,长度"
    表示的数组前多少个字符、以空字符为结尾的字符数组、"个数,字符"
    表示的n个字符组成的字符串、"迭代器a,迭代器b"、一个初始化列表(前面所有双引号都不用带进去，只是便于观看而已)
    根据不同的操作中range，pos的不同要选择对应的args，并不是所有的形式都可以使用的，比如insert不支持下标和初始化列表参数

    string还提供了多种搜索操作，返回值都是size_type，如果搜索失败则返回值为-1的npos，是一个无符号类型

    s.find(args)
    查找s中第一次出现args的位置(args可以是字符串)，返回第一次出现的下标

    s.rfind(args)
    查找s中args最后一次出现的位置，返回最后一次出现args的下标

    s.find_first_of(args) 查找s中args中任何一个字符第一次出现的位置

    s.find_last_of(args) 查找s中args中任何一个字符最后一次出现的位置

    s.find_first_not_of(args) 在s中查找第一个不在args中的字符

    s.find_last_not_of(args) 在s中查找最后一个不在args中的字符

    args必须是"字符(串)，位置"或"C风格字符串，位置"或"数组，位置，长度"表示从位置开始查找数组中前长度个字符，无默认值。这些第一(到二)位都是要找的东西，最后一位位置表明从s的该位置开始找，是可选的。

    类似于cstring头文件中定义的对c风格字符串的strcmp函数，标准库string也定义了类似的compare函数

    s.compare(参数) 参数可以是：s2 比较s与s2；pos1,n1,s2
    比较s中从pos1开始的n1个字符与s2；pos1,n1,s2,pos2,n2
    比较s从pos1开始n1个字符与s2从pos2开始n2个字符；pos1,n1,cp,n2
    比较容器前n2个字符；pos1,n1,cp cp是c风格字符串

79. string的数值转换

    新标准引入了多个函数以实现数值数据与string之间的转换

    要转换为数值的string中第一个非空白符必须是数值中可能出现的字符，也就是数值是int第一个非空白符必须是符号或者数字或者0x表示十六进制，e表示指数部分。对于double也可以是小数点等等。如果不能转化为数值或数值无法用任何类型表示都会抛出异常。下面是函数

    to_string(val)
    返回val的string表示，val可以是任何算数类型，其中小整型会被提升

    stoi(s, p, b)、 stol(s,p,b) 、 stoul(s,p,b) 、stoll(s,p,b)
    、stoull(s,p,b)
    返回s的起始子串(表示整数内容)的数值，b是转换基数(默认值10，基数即采用几进制转换)，p保存s中第一个非数值字符下标，默认是0。从左到右返回类型依次是int，long，unsigned
    l，ll， unsigned ll

    stof(s,p) 、stod(s,p) 、stold(s,p)
    返回s起始子串(表示浮点数)的数值，默认是十进制故没有基数，从左到右类型依次是float，double，long
    double

80. 适配器

    适配器是标准库中一个通用概念，是一种使某种事物的行为看起来像另外一种事事物一样的机制，容器迭代器和函数都有适配器。一个容器适配器接受一种已有的容器类型，使其操作起来和适配器的容器一样，也就是利用已有容器模拟其他容器功能。所有容器适配器都支持以下操作和类型

    size_type 保存当前类型最大对象的大小；value_type
    元素类型；container_type 实现适配器的底层容器类型；Type_name name
    创建名为name的空适配器；Type_name name(containerC)
    创建一个名为name的适配器，带有containerC的一个拷贝；a.empty()
    检测是否为空；a.size() 返回a中元素数目；swap(a,b) a.swap(b)
    交换具有相同类型(包括底层容器类型和适配器类型)的a和b的内容；以及所有的关系运算符

    构造适配器有两种方法，一种是像stack\<int\>
    stk(deq);(这里deq是一个deque\<int\>容器)一样，接受一个容器的拷贝来初始化适配器，这里从deq拷贝元素到stk

    因为适配器就是用其他容器来模拟某些容器的功能，所以自然有默认的使用容器类型，默认情况下stac栈
    和queue队列 是基于deque实现的，priority_que优先队列
    是基于vector实现的，但是我们也可以通过将一个命名的顺序容器作为第二个类型参数来重载默认类型

    stack\<string, vector\<string\>\>
    str_stk;代表str_stk是基于储存字符串的vector实现的储存string的栈，这种情况自然也可以通过在后面加个(svec)来拷贝初始化，注意svec与str_stk各类型完全相同就行

    然而这种重载也是有限制的，因为所有适配器都要求容器有添加删除访问尾元素的能力，并且特殊适配器有特殊要求，所以有些容器不可以用来模拟。如：stack不能用array和forward_list模拟；queue不能用vector，可以用list或deque；priority_queue不能用list而可以用vector或deque模拟。一般做题情况下更推荐用数组模拟栈或队列，工程情况下建议使用stl的适配器

    栈适配器额外操作： s.pop()
    删除栈顶元素，不返回该元素值；s.push(item) 和 s.emplace(args)
    把元素压入栈顶，该元素可以是拷贝或移动item或者由args构造；s.top()
    返回栈顶元素但不删除

    队列适配器(两种)额外操作：q.pop()
    移除queue首元素，或者priority_queue最高优先级元素，但不返回；q.front()
    返回首元素但不删除；q.back()
    返回尾元素但不删除，只适用于queue；q.top()
    返回最高优先级元素但不删除，不适用于queue；q.push(item)和q.emplace(args)
    在queue末尾或者priority_queue恰当位置创建一个元素，可以是拷贝、移动item或者由args构造

    81\. 补充：格式化输入输出------在处理大量数据时比cin和cout更快

    printf()函数的语法格式是：printf(\"\<格式化字符串\>\"，\<输出列表\>)；

    格式化字符串中如果包含以"%"开头的格式字符，printf()函数将数据转换为指定的格式输出到屏幕上。格式化字符串中包含三部分，即原样输出文字、控制字符、转义字符。如果输出列表有两个变量或者多个组成，变量之间需要用逗号隔开，多个变量与格式字符串的控制字符一一对应。

    输出不同的类型需要使用不同的控制符，这里汇总了一些常见的控制符。

    %d：输出十进制整数，一般对应int类型

    %i：输出十进制整数，与%d相同

    %c：输出字符，一般对应char类型

    %f：输出十进制实数，一般对应float类型，也可以是double类型

    %lf：输出十进制实数，一般对应double类型，也可以是float类型

    %%：输出百分号（%）

    C语言中定义了一些字母前加\"\\\"来表示那些不能直接显示的ASCII字符，称为转义字符。汇总了几个常用的转义字符。

    \\n：换行，将当前位置移到下一行开头

    \\t：水平制表，跳到下一个Tab位置

    \\\\：代表一个反斜线字符\'\\\'

    scanf()函数的语法格式是：scanf(\"\<格式化字符串\>\"，\<地址列表\>);

    因此后面一项实参带有取地址符&，如scanf(\"%d\", &a);

    %d换成%s是对字符串的输入输出

    scanf的其他使用情况：

    1.宽度
    我们可以在scanf函数中输入指定的宽度，达到宽度后，后面的数据将会赋给下一个变量，如果只有一个变量，那后面的数据被舍弃，例如

    scanf(\"%2d\",&a); 当输入455时，只有45保存到a中，5被舍弃

    scanf(\"%2d%d\",&a,&b); 当输入455时，将45保存至a，5保存至b

    2.星号 在格式字符串中使用星号，将会跳过这个输入值。例如

    scanf(\"%d\*d%d\",&a,&b); 当输入1 2 3时，1保存至a，2被跳过，3保存至b

    除此之外，还有几种特殊的函数

    1\. getchar()函数和putchar()函数

    getchar()函数用于接收键盘输入的下一个字符，并把它返回为它的ASCII码。当调用getchar()函数时，程序就会进行等待，我们输入的字符会被存放在输入的缓冲区中，直到按下回车为止，输入的字符会回显在屏幕上被看到。读取发生错误时返回-1，该函数不需要任何参数。当字符转换为int的时候会默认有转为ASCII码的机制，因此getchar特殊点只在于接受输入的下一个字符并转换

    putchar()函数把字符输出到显示器上，并返回相同的字符，在同一个时间内只会输出一个字符，它接受一个int类型参数，该参数被转换为对应字符的ASCII码，最后输出该码对应的字符

    2\. getch()函数和putch()函数

    getch()函数和前面讲到的getchar()函数功能基本相同，也是接收输入的一个字符。getch()函数直接从键盘获取值，不等待回车键。只要获取到一个值，便立即返回。getch()函数输入的字符不回显，我们在屏幕上也看不到。因此，getch()函数常用来做调试。它依然不需要任何参数

    putch()函数在使用上和putchar()函数没什么区别，也是用来向屏幕中输出一个字符。

    上面的格式化输入输出和函数都存储在C++头文件cstdio中或C头文件stdio.h中，对于C++11，可能某些编译器上在使用printf和scanf要在后面加_s变为printf_s和scanf_s才可以正常使用

    82.大多数算法定义在头文件algorithm中，标准库还在头文件numeric中定义了一组数值泛型算法(适用于不同类型及多种容器类型的算法)，一般情况下这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围进行操作，这个范围是左闭右开的。

    第一个常用标准库算法是find：其用法是find(容器m的迭代器a,容器m的迭代器b,想要找的元素val);
    它返回一个指向范围内第一个与val相同的元素的迭代器，因此通常建议作为右值赋值给auto声明的左值。如果范围内无匹配元素，则返回中间的那个迭代器b，因为这个迭代器是范围内取不到的。由此可以通过判断左值是否等于中间那个迭代器b来判断范围内是否存在该元素

    可以发现，迭代器的作用是令算法不依赖于容器，但是算法依赖于元素类型的操作，例如find要求比较运算符。但是我们之后会知道，大多数算法提供一种方法允许我们使用自定义操作来替代默认运算符。算法永远不会执行容器的操作或改变底层容器的大小！它只可能改变或移动元素，而不会直接添加或删除元素。(对于一种特殊的迭代器：插入器，算法是可以完成添加元素的操作效果的)

    标准库提供了超过100个算法，这些算法有一致的结构，通过理解其统一原则可以更方便利用与学习它们。

    大部分标准库算法都是对一个范围内(称输入范围)的元素进行操作，接受输入范围的算法总是使用前两个参数(迭代器类型)来表示此范围，左闭右开。理解算法的最基本的方法就是了解它们是否读取，改变或重排元素。

    A.只读算法

    一些算法只会读取其输入范围内的元素，而不进行改变，例如

    ①find：上面已经介绍过了

    find_if：前两个参数是表示范围的迭代器，与find不同的是，它的第三个参数是一个谓词，**[[此算法对输入序列的每个元素调用谓词，如果调用谓词为真，就返回这个元素，如果不存在这样的元素，返回尾迭代器，这里的谓词只能是一元谓词]{.underline}]{.mark}**

    ②count：它参数列表和find一样，返回给定值在范围内出现的次数。

    ③accumulate:
    参数列表也是两个迭代器+一个值(这个值可以带上它的元素类型，例如string(\"\")
    )，其作用是对范围内(左闭右开)的元素求和，和的初值被设置为第三个参数，例如accumulate(vec.cbegin(),
    vec.cend(),
    1);表示对vec内元素求和，初值为1。这里使用了const版本的迭代器避免不小心进行了写操作，但只读算法不一定只能接受const迭代器的。

    要注意的是，accumulate要求元素类型加到第三个参数上的操作必须是可行的，也就是val内参数必须与第三个参数匹配或者隐式转换。由于string重载了+运算符，因此可以通过accumulate把一个储存字符串的容器内的字符串连接在一起，第三个参数设置为string(\"\')即可，这时我们相当于显式创建了一个string
    因为我们不可以直接把一个空串传递给参数，这样会导致编译错误，因为这会导致用于保存和的对象是一个const
    char\*类型，而它并没有定义+。**[可见第三个参数还起到决定和是什么类型的作用，因此允许我们带上一个类型+括号]{.mark}**

    ④equal:
    它接受三个迭代器，前两个表示第一个序列中的元素范围，第三个表示第二个序列的首元素，用于确定两个序列是否保存相同的值，如果相同返回true，否则返回false，这要求两个序列的元素必须支持==运算符(不要求容器类型必须一样)，而且**[它基于一个非常重要的假设：第二个序列至少与第一个序列一样长。这个假设适用于所有接受一个单一迭代器来表示第二个序列的算法。对于接受四个参数表示两个序列范围的算法来说则安全许多。]{.mark}**

    [B.写容器元素的算法]{.mark}

    [一些算法将新值赋予序列中的元素，我们使用时必须注意序列原大小至少不小于我们要求算法写入的元素数目，因为算法永远不会改变容器的大小。]{.mark}

    [①fill:]{.mark}

    [它接受一对迭代器表示一个范围，一个值作为第三个参数，把范围内的元素赋上给定的值。这种算法只对给定范围写入元素，只要输入的范围有效，它就是安全的。]{.mark}

    [②fill_n:]{.mark}

    [它接受一个单迭代器、一个计数值和一个给定值，它将给定值赋予从迭代器开始的计数值个元素。例如fill_n(vec.begin(),
    vec.size(), 0);
    就是把整个vec置0，千万不能对一个空容器上使用这种形式的算法，因为给定值个元素根本不存在。这种算法假定目的位置足够大。]{.mark}

    [\*一种保证算法有足够空间容纳输出数据的方法是使用插入迭代器]{.mark}

    [插入迭代器：这种迭代器被绑定到容器上，可用来向容器插入元素。它本质上是。
    一种迭代器适配器，接受一个容器，生成一个迭代器，让它能向给定容器添加元素。插入器有三种类型：]{.mark}

    [back_inserter 一个使用push_back插入的迭代器]{.mark}

    [front_inserter 一个使用push_front的迭代器]{.mark}

    [insereter 一个使用insert的迭代器]{.mark}

    [前两个插入器只接受一个参数，即想要进行插入的容器的名字，使用例：]{.mark}

    [vector\<int\> vec; auto it = back_inserter(vec);
    //这样就创建了一个往vec里使用push_back插入元素的插入器]{.mark}

    [\* it = 42; //往空vec中插入了一个42，注意使用的时候要解引用]{.mark}

    [而第三个插入器接受两个参数，第一个参数还是名字，第二个参数必须是一个指向给定容器的迭代器，元素被插入到给定迭代器表示的元素之前。对于三种操作，它们都假设容器支持push_back,push_front和insert操作。解引用操作使得每次操作都会更新迭代器，所以可以多次使用一个插入器，注意push_front会使插入元素在序列中的顺序与插入顺序相反，而push_back和insert不会。]{.mark}

    [由此，我们可以把上面的写算法中的迭代器改成插入器，这样就可以对空容器进行插入了，例如]{.mark}

    [vector\<int\> vec; auto it = back_inserter(vec); \*it = 42;
    //朝空vec中插入42]{.mark}

    [或是 fill_n(back_inserter(vec), 10, 0);
    //添加十个0到空vec的末尾中]{.mark}

    [③拷贝算法copy:]{.mark}

    [拷贝算法是向另一个目的位置迭代器指向的序列中的元素写入数据的算法，它接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。这个算法把输入范围内的元素拷贝到目的序列中，和上面一样，目的序列至少要包含与输入序列一样多的元素。**[注意对于内置数组，使用其名字就是使用起始位置的迭代器，不必使用begin获得]{.underline}**]{.mark}

    [④replace:]{.mark}

    [replace算法读入一个序列，并把其中所有等于给定值的元素都改为另外一个元素，它接受四个参数，前两个是迭代器，表示要改变的输入序列，第三个是要搜索的值，它把所有等于这个值的元素替换成第四个参数输入的值。]{.mark}

    [⑤replace_copy :]{.mark}

    [它在replace的基础上接受第三个迭代器参数，这个迭代器指向与前两个迭代器所在容器不同的另外一个容器，用于把输入范围内的元素拷贝至另外一个容器，因此第三个迭代器必须是插入器，例如replace_copy(ilist.cbegin(),
    ilist.cend(), back_inserter(ivec), 0, 42);]{.mark}

    [中ilist并未改变，ivec包含ilist中所有0置换成42后的拷贝，从尾部压入。]{.mark}

    [⑥for_each：]{.mark}

    [它接受两个迭代器以及一个可调用对象，对输入序列范围内的每一个元素执行一次这个可调用对象，通常与lambda表达式一起使用，遍历并处理每个元素]{.mark}

    [⑦transform:]{.mark}

    [它接受三个迭代器和一个可调用对象，前两个迭代器表示输入序列，第三个迭代器表示目的位置，将输入序列中的所有元素调用可调用对象，将其返回结果写入目的位置，依然假定目的序列至少包含与输入序列一样多的元素]{.mark}

    [C.重排容器元素的算法]{.mark}

    [某些算法可以重排元素中顺序使其变得有序，也有的算法可以实现方便查找重复元素的功能，然后通过容器的删除操作去重]{.mark}

    [①sort:]{.mark}

    [sort的两个参数接受两个迭代器，表示要排序的元素范围，它按照字典顺序升序排列范围内的元素]{.mark}

    [stable_sort:]{.mark}

    [和sort的使用方法完全一样，在升序排列范围内元素的同时，它保证了相同的元素之间的相对位置在排序后不变，注意这个相同的定义，对于默认情况下是数的大小相同或是字符串完全一样，这个时候研究其相对位置意义不大，然而**[我们可以通过传入谓词改变"相同"的定义，比如当字符串长度相同时它们就相同，这时候"相同元素"的保序性就非常重要了。]{.underline}**]{.mark}

    [②unique:]{.mark}

    [unique接受两个迭代器，表示要"消除"相邻重复项元素的范围]{.mark}

    [unique算法重排输入的序列，把相邻的重复项放到序列尾部位置，由于算法并不直接添加或删除元素，因此unique只是使得不重复的元素按照原来顺序从序列开始部分排序，后面多出来的位置元素依然存在，但是我们不知道其值。unique返回一个指向不重复那段序列末尾的迭代器，叫做end_unique
    因此在sort与unique执行完后，我们使用erase操作把从end_unique到序列的end()范围内的所有元素删去。这个操作是安全的]{.mark}

    [很多算法都会比较输入序列中的元素，默认情况下是使用\<和==运算符，然而标准库为这些算法定义了额外的版本，允许我们提供资自己定义的操作来代替默认运算符，以便我们需要不同的排序顺序或者需要处理未定义比较运算符的对象]{.mark}

    [例如我们需要sort算法按字符串长度重排元素，我们将使用sort的重载版本，它接受第三个参数，这个参数是一个谓词]{.mark}

    [**谓词是一个可调用的表达式，返回一个能用作条件的值，通常设计为返回布尔值的函数**。它分为一元谓词(只接受单一参数)和二元谓词(它们有两个参数)。接受谓词参数的算法对输入序列中的元素调用谓词，**[元素类型必须可以转换为谓词的参数类型]{.underline}**]{.mark}

    **[[对于一些接受可调用对象(谓词)的算法，它们会使用到可调用对象的返回值来进行替换等操作]{.underline}]{.mark}**

    [例如，为了完成上面sort按照字符串长度排列的需求，我们定义如下谓词]{.mark}

    [bool isShorter (const string &s1, const string &s2)]{.mark}

    [{]{.mark}

    [return s1.size() \< s2.size();]{.mark}

    [}]{.mark}

    [sort(words.begin(), words.end(), isShorter);]{.mark}

    [这里如果s1长度小于s2就返回true，当谓词返回true时执行算法的操作，为false则不执行。这需要我们对算法的工作方式有所了解，知道它的操作是什么。上面的这个操作就是把短的排在长的前面。这是因为原来是字典顺序在前，这个元素在前，而现在是满足谓词条件，这个元素就在前。]{.mark}

    [算法限制谓词的参数在两个以内，但是有时候我们希望进行的操作需要更多参数例如find_if的谓词只能是一元的，如果想传递多个参数，需要另外使用一些语言特性]{.mark}

    [D. lambda]{.mark}

    [对于一个对象或表达式，如果可以对其使用调用运算符，则称为可调用对象，例如e()]{.mark}

    [我们可以向一个算法传递任何类别的可调用对象。我们目前用过的可调用对象是函数和函数指针]{.mark}

    [/\*函数指针：在第19条中介绍了其声明，我们可以把一种函数指针传递给一个函数，例如]{.mark}

    [int operater(int (\*operation) (int, int), int x, int y)
    其第一个参数就是一个接受两个int，返回类型为int的函数，**[只要满足这个要求的函数都可以被传递给它作为实参]{.underline}**(当我们使用函数的名字的时候就是使用这个函数的函数指针了)，在operater的后续操作中可以任意调用这个满足要求的传入函数，这使得一个函数可以根据不同要求调用不同的函数，极大地提高了程序的灵活性\*/]{.mark}

    除了函数和函数指针，还有两种可调用对象：重载了函数调用运算符的类，以及lambda表达式，这里介绍lambda表达式

    一个lambla表达式表示一个可调用的代码单元，可以理解为一个未命名的内联函数。和任何函数类似，它具有一个返回类型，一个参数列表和一个函数体，[**[不同的是它可以定义在函数内部]{.underline}。**它的形式是：]{.mark}

    [\[ 捕获列表 \]( 形参列表 ) -\> 返回类型 { 函数体 }
    //lambda必须使用尾置返回]{.mark}

    [其中，捕获列表是一个lambda所在函数中定义的局部变量的列表，形参列表和返回类型都是可省略的，而捕获列表和函数体必须存在，例如]{.mark}

    [auto f = \[\] { return 42; };
    这里f就是一个lambda，不接受任何参数，返回42，lambda根据返回语句自己推断出返回类型，没有返回语句就是void]{.mark}

    **[值得注意的是，如果lambda的函数体中不止包含return语句，且没有指定返回类型，都返回void]{.mark}**

    [调用lambda和普通函数一样，只需要使用调用运算符即可，如f()]{.mark}

    [下面介绍lambda每个部分的作用：]{.mark}

    [❶.向lambda传递参数和调用普通函数类似，实参用于初始化形参，通常其类型必须匹配。然而不同的是，lambda不能有默认参数，因此其接受的实参数目永远等于形参数目，传入足够的实参后就可以执行函数体了]{.mark}

    [❷.一个lambda可以出现在函数中使用其局部变量或传入实参(只能使用明确指明了的变量，变量之间逗号隔开)，**它通过将这些局部变量包含在其捕获列表中指出将会使用这些变量**，通过这种方法，我们就可以用传入参数与许多捕获的局部变量进行运算了(只有捕获了才能用！)当然，对于头文件出现的名字，只要函数作用域中包含了头文件，lambda就可以使用这些名字，不需特别捕获]{.mark}

    [❸.通过上面的auto类型初始化一个可调用对象，我们知道实际上使用lambda就是使用了一个它生成的类型的对象，这个类型在默认情况下都包含一个对应lambda捕获的变量的数据成员，它们在类创建时被初始化]{.mark}

    [lambda中变量的捕获方式：]{.mark}

    [❶.值捕获：即捕获局部变量的值的拷贝，前提是此变量必须可以被拷贝，其值是在lambda被创建的时候被拷贝的，而不是lambda被调用时才拷贝]{.mark}

    [❷.引用捕获：我们可以捕获局部变量的引用，当我们在lambda中使用其引用时，实际上使用的是与引用绑定的对象，需要保证这个对象在lambda执行时存在。**引用捕获通常用于捕获iostream对象(只能用引用捕获)，或是需要通过引用修改原始变量时**]{.mark}

    [如果引用指向一个const对象，我们不能通过lambda对其进行修改]{.mark}

    [函数也可以返回一个lambda，这时lambda不能包含引用捕获，因为函数不能返回一个局部变量的引用]{.mark}

    [❸.隐式捕获：我们可以只在捕获列表中输入&和=表示让编译器根据lambda中的代码推断我们需要用到哪些变量，**其中&表示引用捕获，=表示值捕获**]{.mark}

    当混合使用显式捕获和隐式捕获时，捕获列表第一个元素必须是&或=，如果是&，则后续的所有值捕获都必须是显式捕获，如果是=则所有引用捕获都得是显式捕获。只有一个=或&就说明所有用到的局部变量全部采用该种捕获方式。

    ❹.可变lambda：默认情况下，对于一个值捕获的变量，lambda不会改变其值，如果我们希望改变其值，必须在[参数列表首加上关键字mutable。]{.mark}

    [auto f = \[v1\] () mutable {return ++v1; };
    **这时候表示参数列表的括号不可去掉**]{.mark}

    [再次提醒，lambda的函数体中若有除了return以外的语句，那么它默认返回void，也就是不返回，**如果想让它返回，则返回类型不可忽略**]{.mark}

    lambda比普通谓词有灵活，可使用多个已有变量的优势，但是对于一些在很多地方都需要用到的操作，使用函数作为谓词会比使用lambda更方便，可是如果lambda需要捕获变量，也就是[函数需要的参数大于算法接受谓词的元数时]{.mark}，我们必须解决[向其他所需参数传递实参]{.mark}的问题

    ➤标准库bind函数：

    它定义在头文件functional中，可以被视为一个通用的函数适配器，**[它接受一个可调用对象，生成一个新的可调用对象来"适应"原对象的参数列表]{.mark}**

    [auto name1 = bind(name2, arg_list);
    其中name1与name2一样，都是可调用对象类型，而arg_list则是一个逗号分隔的参数列表，对应给定的name2参数，换句话说：当我们调用name1的时候，等同于调用name2，并传递给它arg_list中的参数]{.mark}

    **[注意arg_list中的参数要包含形似_n
    (n为整数)的名字，它是一个占位符，占据了传递给name1的参数的位置，也就是传递的参数不能在name2的第n个位置]{.mark}**

    [例如，auto check6 = bind(check_size, \_1, 6);
    如果check_size接受一个string对象s]{.mark}

    [那么调用check6(s)就相当于调用check_size(s, 6)
    //第一个位置不允许传递的参数进入]{.mark}

    [其中，名字_n定义在std命名空间的子空间placeholders中，理论上每用一次_n都得在前面声明using
    std::placeholders::\_n;]{.mark}

    [但是可以通过using namespace std; 来省去这些麻烦的操作]{.mark}

    [再举一个占位符的例子，帮助我们更好理解它：
    f是一个有5个参数的可调用对象]{.mark}

    [auto g = bind(f, a, b, \_2, c, \_1);]{.mark}

    [这里两个占位符占用了g的第二个和第一个位置，**而f后面的参数列表的顺序就是传递给f的实参的顺序**。如果调用g(X,
    Y)实际上是调用f(a, b, Y, c, X)]{.mark}

    [这说明bind可以用来重排传入函数的参数的顺序]{.mark}

    [bind基于参数的拷贝实现，但是有时候我们希望以引用方式传递参数，或者该类型无法拷贝，我们就不能直接把参数名字写入bind里面了]{.mark}

    **[这时我们可以使用标准库ref和cref函数，用法类似于
    ref(os)，它们也定义在function中]{.mark}**

    [它们生成一个包含给定引用的类，此对象支持拷贝操作。**我们可以向bind传递一个ref(name)代表以拷贝形式传递name的引用。**其中，cref表示保存const引用]{.mark}

    [83.再谈迭代器]{.mark}

    [除了容器定义的迭代器与插入器以外，头文件iterator还定义了几种迭代器。]{.mark}

    [❶.iostream迭代器：]{.mark}

    [尽管iostream不是容器，但标准库还是定义了可以作用于IO类型对象的迭代器]{.mark}

    [istream_iterator 读取输入流； ostream_iterator
    向一个输入流写入数据]{.mark}

    [**[这些迭代器将它们对应的流当作一个特定类型的元素序列来处理]{.underline}**，通过流迭代器，我们就可以使用泛型算法从流中读写数据了，下面介绍两个迭代器的操作]{.mark}

    [istream_iterator操作]{.mark}

    一个istream_iterator使用 \>\>
    来读取流，这说明[要读取的类型必须定义了输入运算符。]{.mark}

    创建一个istream_iterator对象时，我们可以将其绑定在一个流上，如

    istream_iterator\<int\> name(cin); //从cin中读取int，绑定在cin上

    又比如 ifstream kk(\"afile\");

    istream_iterator\<string\> name(kk);
    就是从名为afile的文件中读取string

    [一个istream迭代器的尾后迭代器就是空迭代器]{.mark}(定义时没有绑定任何流)，因此可以通过判断一个流迭代器是否等于一个未绑定流的迭代器来判断它是否到达流末尾或者遇到io错误

    例如， 下面就是从输入流中读取int并且置入vec中的操作

    string s; cin \>\> s;

    istream_iterator\<int\> in_iter(cin), eof;

    vector\<int\> vec(in_iter, eof);

    比如我们输入11 12 13
    14，则vec将是{11,12,13,14}，把int改string，**[并且输入一群用空格隔开的字符串，它们也会被以空格分开存入vec]{.mark}**！

    对于流迭代器，也可以通过解引用符返回从流中读取的值，或者用箭头运算符访问指向对象的成员，相当于(\*iterator).member，而且也可以像正常的迭代器一样使用加减法，在流上移动。自然也可以参与算法，直接对输入流进行算法操作

    流的数据读取**[并不是立刻发生于istream迭代器绑定到流上的]{.mark}**，标准库只能保证我们第一次解引用迭代器之前完成读取数据的工作(**[也就是当我们使用迭代器的时候才真正读取]{.mark}**)，这个顺序在从两个不同对象同步读取一个流的时候要注意，**[要重置输入流实现同步读取]{.mark}**，例如

    // 创建一个输入流对象

    std::istringstream input(\"1 2 3 4 5\");

    // 创建两个 vector 容器

    std::vector\<int\> vec1, vec2;

    // 使用 std::istream_iterator 从输入流中读取数据，并将数据存储到
    vec1 和 vec2 中

    std::istream_iterator\<int\> in_iter(input), eof;

    std::copy(in_iter, eof, std::back_inserter(vec1)); // 将数据存储到
    vec1 中

    input.clear(); // 重置输入流状态

    input.seekg(0); // 定位输入流的读取位置到开头

    std::copy(in_iter, eof, std::back_inserter(vec2)); // 将数据存储到
    vec2 中

    ostream_iterator操作

    和istream迭代器类似，我们可以对任何具有输出运算符 \<\<
    的对象定义一个ostream_iterator，例如

    ostream_iterator\<T\> out(os); 就是把类型为T的值写入输出流os中

    我们还可以提供一个第二参数(可选)，它必须是一个C风格字符串(字符串字面常量或一个指向空字符结尾的字符数组的指针，[可以用字符数组的名字实现]{.mark})，在每次输出后都会打印一次这个字符串

    [ostream_iterator不允许为空或者为尾部迭代器]{.mark}

    对ostream_iterator的[解引用和加减操作实际上都可以忽略]{.mark}，对程序没有任何影响，[而对此迭代器的赋值操作就是把元素写到输出流中输出]{.mark}

    [如果自定义类定义了输入和输出运算符，那么我们就可以使用流迭代器处理类类型了]{.mark}

    [两种流迭代器都不支持递减操作]{.mark}

    ❷.反向迭代器reverse_iterator

    [除了forward_list的迭代器和流迭代器以外，其他容器都支持反向迭代器]{.mark}，我们可以通过调用rbegin、rend、crbegin、crend来获得反向迭代器，其实际上的递增递减操作与操作符是反过来的，例如\--实际上对它来说是移动到下一个对象。由于两种流迭代器都不支持递减操作，因此无法创建反向迭代器

    对算法使用反向迭代器，算法就会反向处理范围了，例如

    sort(vec.rbegin(), vec.rend());
    就是降序排列vec元素，把最小元素放在最后

    使用反向迭代器的算法如果返回迭代器，返回的也是反向迭代器

    对一个反向迭代器hh调用其base成员，返回其对应的普通迭代器(位置不同)

    即hh.base()是普通的迭代器

    普通迭代器和反向迭代器指向的元素关系如下图

    ![](media/image8.png){width="2.875in" height="0.8362981189851268in"}

    \[crbegin(),
    line.rcomma)与\[rcomma.base(),line.cend())表示的line中范围相同，为了实现这一点，[一个反向迭代器与其base成员生成的应该是相邻位置，而非相同位置。其中，base指向的位置时该反向迭代器对应的正向迭代器的下一个位置。]{.mark}例如rbegin和end，rend和begin，因为其目的只是表示元素范围

    这也提醒我们当我们从一个普通迭代器初始化一个反向迭代器/给一个反向迭代器赋值时，[两者指向的并不是相同元素]{.mark}

    84.泛型算法结构

    任何算法的基本特性是它要求迭代器提供哪些操作，这些操作可以分为五个类别

    单遍扫描：同一个元素只能处理一次

    输入迭代器(只读不写，只能递增)

    它支持相等与不等运算符，前置和后置的++运算符，用于读取元素的解引用运算符(只出现在赋值运算符右侧)，箭头运算符(相当于解引用+点)。例如：istream_iterator

    输出迭代器(只写不读，只能递增)

    前置后置的++运算符，用于写元素的解引用运算符(只出现在赋值运算符左边)，例如:ostream_iterator

    多遍扫描：可以多次处理一个元素

    前向迭代器(可读可写，只能递增)

    支持前两个的所有操作的同时，只能沿一个方向移动。对于例如replace算法和forward_list容器，只能使用前向迭代器，例如：容器forward_list中的迭代器

    双向迭代器(可读可写，可增可减)

    在上面的所有操作以外还支持递减运算符\--，reverse算法要求双向迭代器，例如：list中的迭代器

    随机访问迭代器(可读可写，支持全部迭代器运算)

    支持随机访问在内的一切迭代器操作，包括加上一个数减去一个数，比较大小，下标运算符等等，例如：vector,deque中的迭代器

    这五种迭代器从前往后功能逐渐全面，[算法对其迭代器参数规定了最小类别]{.mark}，只有功能大于等于这个类别的迭代器传递给算法才不会产生错误。这种错误大部分不会被编译器检测出来，要格外注意。

    85.算法的命名规范

    [算法遵循一套命名和重载规范]{.mark}，了解这些规范有利于我们了解算法

    A.使用[重载形式]{.mark}传递谓词的算法

    它们接受谓词参数来代替\<或==运算符，它们可以额外调用谓词对元素进行比较来确定两个元素的关系，进而进行算法的操作。例如unique中的==运算符可以被谓词重载

    B.[接受一个谓词代替元素值]{.mark}的算法

    这种需要接受谓词参数的算法[都有额外附加的_if前缀]{.mark}，例如find_if

    它们用到了谓词传递的值，并且利用这个值来对元素进行操作，例如find_if接受一个谓词，并按照其返回结果查找使得谓词返回非零值的元素。这种算法不是重载，而是对名字加了个后缀以免去可能的歧义

    C.区分[拷贝元素]{.mark}的版本和[不拷贝]{.mark}的版本

    前者比后者多需求一个目的位置迭代器

    一些算法在原来母算法的基础上提供了将处理后的元素写到一个指定的输出位置的功能，例如
    reverse_copy(beg, end, dest)
    将前两个迭代器范围内的元素逆序拷贝到dest为开头的位置(可以是不同容器)
    [这类算法都在名字后面附加一个_copy]{.mark}

    当然，\_copy与_if是可以同时出现在一个额外算法上的，它表示利用谓词返回值进行操作并且把输入序列中元素拷贝到目的位置，例如remove_copy_if

    86.链表类型list和forward_list定义了几个独有的成员函数形式的算法在其头文件

    lst.merge(lst2)
    lst与lst2[必须都是升序排列的]{.mark}，将来自lst2的元素合并入lst，进行归并排序，也就是把lst2中的元素按大小插入lst，利用\<运算符比较

    lst.merge(lst2, comp) 在上面一条的基础上用comp重载\<运算符

    lst.remove(val) 利用==运算符，删除掉与val相等的元素

    lst.remove_if(pred) 删除掉使pred返回真的元素

    lst.reverse() 反转lst中元素顺序

    lst.sort() lst.sort(comp)
    前者利用\<运算符升序排序，后者利用comp的比较操作重载\<

    lst.unique() lst.unique(pred)
    前者删除==为真的元素拷贝，后者删除二元谓词返回真的元素

    上面这些算法虽然algorithm都有，但是利用链表特有的版本消耗才小，而下面的splice算法是链表特有的

    lst.splice(\...) //只能用于list flst.splice_after(\...)
    //只能用于forward_list

    其调用运算符里可以是：

    (p, lst2)
    p是一个指向lst中元素的迭代器，或者指向flst首前位置的迭代器，函数将lst2中的所有元素移动到lst中p前的位置或者flst中p后的位置，同时将元素从lst2中删除。这要求它们类型相同且不能是同一链表

    (p, lst2, p2)
    p2是一个指向lst2中位置的有效迭代器，将p2指向的位置移动到lst中p前或者将p2之后的所有元素移动到flst中

    (p, lst2, b, e)
    b和e表示lst2中合法范围，把给定范围元素移动到lst或flst，这里lst2和它们可以是同一个链表，但p不能指向be范围内的元素

    显然链表特有的操作会改变容器，而不是和通用算法一样不改变底层容器

    87.关联容器

    关联容器中的元素是按关键字来保存和访问的，而不像顺序容器按照容器中位置来顺序保存访问。它支持高效的关键字查找与访问。

    标准库定义了三个维度的八个容器，⒈以set(集合)还是map(键值对)作为主要容器

    ⒉允许重复关键字与否 ⒊是否按顺序保存元素

    主要分map和set两种，一开始不允许关键字重复，若关键字可重复出现的就在map或set前加multi，在此基础上，不带unordered_的前缀的为有序关联容器，带此前缀的才是无序容器

    map和multimap定义在map头文件，set和multiset定义在set头文件

    而无序容器版本的那四个容器则定义在unordered_map和unordered_set头文件中

<!-- -->

A.  使用map(关联数组)

    关联数组以关键字为索引，通过关键字到值的映射来进行查找。当定义一个map时，必须既指明关键字类型又指明值类型。比如

    map\<string, size_t\> word_count;

    就表明此关联数组的关键字类型为string，值类型为size_t，而其的值初始化必须是用大括号包围的{键，值}，例如

    map\<string, string\> exclude = { {\"aaa\",\"zzz\"},
    {\"bbb\",\"yyy\"} };[注意括号中第一个是关键字，第二个是值！]{.mark}

    而对空关联数组添加元素也很简单，比如

    exclude\[\"mmm\"\] = \"ooo\"; 就是添加了一个关键字，并初始化其值

B.  使用set(关键字集合)

    而定义一个set和定义map不同，只需要指明关键字类型即可，因为它并没有值，例如

    set\<string\> excle;
    一个set可以配合find操作对其中的关键字进行查询。它有着非常高效的搜索性能。比如

    excle.find(\"name\")就返回excle中\"name\"关键字的迭代器，没有则返回尾后迭代器end

    其列表初始化也只需像普通的数组列表初始化一样即可

C.  使用multimap或multiset

    一个map和set中的关键字必须是唯一的，不允许多个元素有相同的关键字，而容器multimap和multiset则没有这个限制，它们都允许多个元素有相同的关键字。关于这些容器的使用，后面会进行细说。

<!-- -->

87. 有序容器的关键字类型

    关联容器对关键字类型有一些限制，无序容器后面说，这里先介绍有序容器的关键字类型要求。

    对于有序容器
    它按照关键字类型的\<运算符来比较两个关键字，从而按照严格弱序（默认是升序）的顺序进行排列，[因此所提供的关键字类型**必须有\<运算符的定义**，并且这个定义符合下面介绍的要求。]{.mark}

    **[与算法类似，我们可以提供自己定义的操作来代替关键字上的\<运算符，这个操作必须满足以下的条件，称为严格弱序（看作\"小于等于\"）]{.underline}**

    **[两个关键字不能同时\"小于等于\"对方；并且满足传递性，即a
    \"小于等于\" b，b \"小于等于\" c，那么一定有a \"小于等于\"
    c]{.underline}**

    **[如果两个关键字任何一个都不\"小于等于\"另一个，则这两个关键字\"等价\"，这个等价也必须具有传递性。等价时容器把它们当做\"相等\"来处理，即两个关键字只能关联一个值，使用两个中的任意一个都能访问到同一个值上去]{.underline}**

    使用自定义操作类型的方法很简单，需要在定义语句中尖括号里元素类型后面紧跟着给出，例如我们定义

    bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs)

    {

    return lhs.isbn() \< rhs.isbn();

    }

    想把它用到multiset中去，只需要为容器提供一个比较操作类型[，这个类型是一个函数指针类型
    也就是说我们需要提供一个指向compareIsbn的函数指针类型，这可以通过decltype简单地实现，**但是要注意decltype获得函数指针类型时一定要额外加一个\***]{.mark}

    [同时，**在容器名字后面要使用括号括起来指示操作的函数或lambda语句的名字**]{.mark}

    [multiset\<Sale_data, decltype(compareIsbn)\*\>
    bookstore(compareIsbn);]{.mark}

    [牢记使用函数名字时会转化为一个指针，所以其实此处是使用一个指示操作的函数的指针，所以使用&compareIsbn也是一样的。]{.mark}

88. [pair类型：定义在头文件utility中]{.mark}

    [pair保存两个数据成员，是一个用来生成特定类型的模板，两个数据成员的类型并不要求一样，比如：]{.mark}

    [pair\<string, string\> anon; pair\<string, size_t\>
    word_count;]{.mark}

    [当然也可以用形如( , )或{ , }的初始化器进行初始化。]{.mark}

    [pair的数据成员是public的，分别命名为first和second，用点运算符访问即可。]{.mark}

    [pair类型支持的操作有：]{.mark}

    [pair\<T1, T2\> p(v1, v2); pair\<T1, T2\>p = {v1, v2};
    等价的两条初始化语句]{.mark}

    [make_pair(v1, v2);
    返回一个用v1和v2初始化的pair，类型自动推算]{.mark}

    [p1 关系运算符 p2 优先比较first，如果相等再比较second]{.mark}

89. [关联容器操作]{.mark}

    [关联容器具有额外的类型别名，分别是key_type, mapped_type 和
    value_type。]{.mark}

    [对于set类型，key_type（键类型）和value_type（值类型）是一样的，因为set保存的值就是关键字。而在map中，由于是键值对的形式储存，每个元素实际上是一个pair对象，类型为pair(const
    key_type,
    mapped_type)，mapped_type只适用于map，由于map的关键字不可改，故第一个类型为const的。]{.mark}

    [我们可以使用作用域运算符来提取一个类型的成员，如]{.mark}

    [set\<string\>::value_type v1; v1是一个string]{.mark}

    [map\<string, int\>::mapped_type v2; v2是一个int]{.mark}

    [关联容器也具有迭代器]{.mark}

    [当解引用\*一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用，对于map来说，这个value_type是一个pair类型，first成员储存const的关键字，second成员才储存值。]{.mark}

    [关于迭代器本身，值得注意的是：set类型虽然同时定义了interator和const_interator，但是这两种类型都只允许只读访问set元素。依然可以通过作用域运算符得到它们：]{.mark}

    [set\<int\>::interator setit = aset.begin();]{.mark}

    [而想获得map的迭代器，建议最好使用auto作为类型，更加方便。关联容器的迭代器也支持关系运算符，begin和end]{.mark}

    [我们通常不对关联容器使用算法，因为它只能使用只读算法，而这类泛型算法对关联容器的查找效率远远不如它们自带的find成员，在平时用的最多的是将其作为一个源序列或目的位置使用copy算法]{.mark}

    [关联容器的添加与删除元素：]{.mark}

    [关联容器的insert成员可以向容器中添加一个元素或一个元素范围，接受源容器的两个const迭代器或者一个初始化器列表或符合元素类型的对象。]{.mark}

    [set和map由于包含不重复的关键字，因此插入一个已存在的元素对容器没有任何影响，set插入重复元素会自动去重]{.mark}

    [map的元素类型是pair，所以insert的括号里应该是形如(pair\<T1,
    T2\>(a1, a2))或({a1, A2})或(make_pair(a1,
    a2))这样创建pair的语句。]{.mark}

    [除此之外的添加元素操作还有emplace，和insert不同，它只有当元素的关键字不在容器中时才会插入或构造元素，]{.mark}

    [添加单一元素的insert和emplace都会返回一个pair，其包含一个指向具有指定关键字的元素以及一个指示插入是否成功的bool值。可以用auto加上.second获得这个布尔值]{.mark}

    [对于multi版本的map和set，由于关键字不必唯一，调用insert时总会插入一个元素，返回一个指向新元素的迭代器，不必有bool值了。]{.mark}

    [关联容器定义了三个版本的erase，第一个版本接受一个key_type参数，删除所有该关键字对应的元素，如果是非multi类型的容器则会返回0或1，0说明想要删除的元素不在容器中；第二个版本接受一个迭代器，只删除该位置上的元素，返回该迭代器后的元素的迭代器；第三个版本接受两个迭代器，删除范围内的所有元素，返回第二个接受的迭代器。]{.mark}

    [map容器还可以进行下标操作]{.mark}

    [c\[k\]
    返回关键字为k的元素，如果不在c中则创建一个，进行值初始化，返回类型为mapped_type]{.mark}

    [c.at(k)
    访问并检查关键字为k的元素，如果k不在c中则抛出out_of_range异常]{.mark}

    [关联容器的访问元素：]{.mark}

    [c.find(k)
    返回一个迭代器，指向第一个关键字为k的元素，如果不在容器中，返回尾后迭代器]{.mark}

    [c.count(k) 返回关键字等于k的元素的数量，如果没有则返回0]{.mark}

    [对于不允许重复关键字的容器，这两操作没什么太大区别，对于map而言，使用find来查询元素比下表操作好得多，因为下标操作在遇到未在map中的关键字时会插入一个新元素，浪费空间]{.mark}

    [对于允许重复关键字的multimap和multiset，如果有多个元素具有同一个关键字，那么这些元素会相邻存储！此时count给出元素数目，find给出第一个元素的迭代器，可以通过\--数目与++迭代器遍历同样关键字的元素]{.mark}

    [c.lower_bound(k)
    返回一个迭代器，指向第一个关键字不小于k的元素]{.mark}

    [c.upper_bound(k)
    返回一个迭代器，指向第一个关键字大于k的元素]{.mark}

    [这两个操作实际上也就是分别指向关键字为k的第一个元素与关键字为k的最后一个元素，它们共同表示了一个范围；如果元素不在容器中，则它们会返回相等的迭代器：指向一个不影响排序的关键字插入位置，]{.mark}

    [c.equal_range(k) 返回储存两个迭代器的pair
    表示关键字大小等于k的元素的范围，若不存在，则两个成员均为c.end()]{.mark}

    []{.mark}

    [90.]{.mark}

    [91.动态内存]{.mark}

    [静态内存用来保存局部static对象，类static数据成员以及定义在任何函数之外的变量；栈内存用来保存定义在函数内的非static对象，[它只在其定义的程序块运行时才存在]{.underline}。]{.mark}

    [分配在静态内存与栈内存中的对象由编译器自动创建和销毁]{.mark}

    [而程序还拥有一个内存池，这部分内存称为自由空间或堆，**程序用堆来存储动态分配的对象：即那些在程序运行时分配的对象**]{.mark}

    **[动态对象的生存期由程序控制，当它们不再使用时，代码必须显式地销毁它们]{.mark}**

    [cpp中，动态内存的管理是通过一对运算符来完成的：]{.mark}

    [**new**
    在动态内存中为对象分配空间并返回一个指向该对象的指针，并且可以选择对对象进行初始化]{.mark}

    [**delete**
    接受一个动态对象的指针，销毁该对象，并释放与之关联的内存]{.mark}

    [因为动态内存的使用很容易出现问题，因此新标准库提供了两种智能指针类型来帮助我们更安全地管理动态对象。智能指针对行为类似常规指针，但区别是**它负责自动释放所指向的对象。**]{.mark}

    **[智能指针类型都定义在头文件memory中：shared_ptr
    允许多个指针指向同一对象； unique_ptr 它"独占"所指向的对象；
    weak_ptr
    是一种伴随类，它也是一种弱引用，指向shared_ptr所管理的对象]{.mark}**

    **[类似vector，智能指针也是模板类，必须提供它所指向的类型：]{.mark}**

    [shared_ptr\<Type\> p1; //定义shared_ptr对象]{.mark}

    [unique_ptr\<Type\> p2; //定义unique_ptr对象]{.mark}

    [weak_ptr\<Type\> p3; //定义weak_ptr对象]{.mark}

    **[所有默认初始化的智能指针都保存着一个空指针。]{.mark}**

    [**智能指针使用方法与普通指针类似，解引用它后返回它指向的对象。如果在一个条件判断中使用智能指针，则意思是检测指针是否为空**
    if(p1) \.....]{.mark}

    [下面是shared_ptr与unique_ptr都适用的操作：]{.mark}

    **[shared_ptr\<T\> sp; 或 unique_ptr\<T\> up;
    定义一个可以指向类型为T对象的空指针]{.mark}**

    **[if(p) 把指针作为条件判断，为空返回假，反之为真； \*p
    解引用p得到它指向的对象]{.mark}**

    **[p -\> mem 等价于(\*p) .mem 获得指向对象的成员； swap(p, q) 或
    p.swap(q) 交换p和q中的指针]{.mark}**

    **[p.get()
    返回p中保存的指针，小心使用，因为智能指针释放了对象之后这个返回的指针所指向的对象也就消失了]{.mark}**

    [A.shared_ptr 类]{.mark}

    [**每个shared_ptr都有一个关联的计数器，称为引用计数，它在我们对一个对象进行拷贝操作时递增该对象的计数器**，这包括：拷贝初始化，作为参数传递至函数，作为函数返回值等]{.mark}

    [**当为shared_ptr赋新值或它被销毁（**比如局部shared_ptr离开作用域**）则计数器递减，计数器变为0时，它会自动释放自己所管理的对象，因为该对象没有引用者了**]{.mark}

    [这样的释放操作是通过这个类的析构函数实现的**。shared_ptr的析构函数会递减其指向对象的引用次数，并且在到达0时销毁并释放对象所占用的内存**]{.mark}

    [这样的性质使得我们可以很容易地使用动态内存：**我们只需要保证每个指向同一块内存的shared_ptr在无用之后不再保留，将所有指向该内存的指针删除掉即可释放内存**（尤其要注意当在容器中放置shared_ptr时，用完以后记得用erase删除那些不再需要的shared_ptr）]{.mark}

    [shared_ptr特有的操作：]{.mark}

    **[make_shared\<T\>(args)]{.mark}**

    **[这其实是一个函数，返回一个shared_ptr，指向一个（初始化）值为args的动态分配类型为T的对象，括号中的参数传递给T的构造函数，例如]{.mark}**

    [auto p1 = make_shared\<int\>（42）
    返回一个指向值为42的int的shared_ptr]{.mark}

    [auto p2 = make_shared\<string\> (5, \'9\')
    返回一个指向值为\"99999\"的string的ptr]{.mark}

    **[括号()中的参数必须与类型T的某个构造函数匹配，使得函数可以构造一个该类型的对象。如果不提供参数，则进行值初始化：用模板类中元素的默认初始化值初始化类]{.mark}**

    **[shared_ptr\<T\> p(q)]{.mark}**

    **[用q拷贝初始化p，为q的计数器加一，这要求q中的指针必须能转换为\*T(p中指针类型)]{.mark}**

    **[p = q]{.mark}**

    **[用q拷贝赋值p，递减p原来指向的对象的引用计数，递增q指向对象的引用计数]{.mark}**

    **[p.use_count()]{.mark}**

    **[返回与p共享对象的智能指针数量，这个操作可能很慢，所以一般用来调试]{.mark}**

    **[p.unique()]{.mark}**

    **[若p.use_count()为1，返回true，否则返回false]{.mark}**

    [程序使用动态内存大致有三个原因：**①程序不知道自己需要使用多少对象
    ②程序不知道所需对象的准确类型
    ③程序需要在多个对象之间共享数据**]{.mark}

    [对于原因①，一个很经典的例子是容器类，例如vector，它并不知道容纳对象的上限。]{.mark}

    [对于vector而言，其分配的元素只在vector存在时才存在，一旦vector被销毁，其元素也都被销毁。但某些时候我们需要**类分配的资源具有与原对象相独立的生存期，即当我们拷贝一个类的对象时，原对象与其拷贝引用相同的底层元素，此时销毁其中一个对象并不会销毁底层数据**，**因为另一个对象在使用它们**。这就是出于原因③而使用的动态内存]{.mark}

    [.....................................................................................................................]{.mark}

    [下面以实现StrBlob类为例，**实现一个新的集合类型的最简单方法是使用某个标准库容器来管理元素，从而用标准库类型来管理元素所使用的内存空间**，本例使用vector]{.mark}

    [**但我们并不能在一个类的对象中直接保存vector**，因为对象销毁时其成员也会被销毁，vector中的元素不复存在。为了解决这个问题，**我们将vector保存在动态内存中**，同时为每个StrBlob设置一个shared_str来管理动态分配的vector，它会记录有多少个StrBlob共享这个vector，并在没有使用者时销毁vector，这里仅显示类内的一部分代码：]{.mark}

    [......]{.mark}

    [private:]{.mark}

    [std::shared_ptr\<std::vector\<std::string\>\> data;
    //即类内拥有一个指向储存string的vector的指针data，它负责管理这部分内存]{.mark}

    [......]{.mark}

    [public:]{.mark}

    [std::vector\<std::string\>::size_type size() const {return data -\>
    size(); } //调用指向对象的size函数，并返回其返回值]{.mark}

    [我们希望该类在初始化时可以接受一个initializer_list初始化其data成员]{.mark}

    [StrBollb(initializer_list\<string\> i1):
    data(make_shared\<vector\<string\>\>(i1)) {}]{.mark}

    [//接受一个Initializer_list，用来初始化data，此处是列表初始化，通过拷贝列表中的值初始化data]{.mark}

    [......]{.mark}

    [**如果我们想允许使用者按下标访问类的成员，必须要检测输入下标是否在范围内**，这可以通过以下check函数实现：]{.mark}

    [我们在执行访问的成员函数执行操作前增加一步check，用于检测下标是否合法，是合法的时才会执行以后的操作，否则抛出异常：]{.mark}

    ![](media/image9.png){width="6.225101706036745in"
    height="6.191941163604549in"}

    [在设计类时，要时刻注意这样的越界问题，及时检测同时抛出异常]{.mark}

    [B.直接管理内存]{.mark}

    [**cpp允许我们使用new和delete来直接分配和释放动态内存**，比起智能指针，这样的用法非常容易出错]{.mark}

    [①
    **在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针**]{.mark}

    [int \*pi = new int;
    //指针pi指向一个动态分配的、未初始化的无名对象]{.mark}

    **[默认情况下，动态分配的对象是默认初始化的，这意味着对于内置类型或组合类型，其对象的值是未定义的；而对于类类型，其对象将用默认构造函数（如果有的话）进行初始化]{.mark}**

    **[我们可以用直接初始化的方式来初始化一个动态分配的对象：]{.mark}**

    [int \*pi = new int(1024); string \*ps = new string(2, \'9\');
    //\"99\"]{.mark}

    [vector\<int\> \*pv = new vector\<int\>{0, 1, 2};]{.mark}

    [auto p1 = new auto(obj);
    //auto大法，编译器从初始化列表内元素类型来推断指针类型]{.mark}

    [这些都是合法的直接初始化方式，想进行值初始化（默认初始化）把括号改为空圆括号()即可。这对于类类型没什么区别，因为它们加不加圆空括号都会调用默认构造函数，**而对于内置类型，两者区别很大，不加括号的话其值是未定义的**]{.mark}

    **[当然，分配一个const对象也是合理的：]{.mark}**

    [const int \*pci = new const int(1024);]{.mark}

    [**一个动态分配的const对象必须进行初始化，**类类型可以隐式初始化，因为有默认构造函数，其他的则不行。]{.mark}

    **[当一个程序用光了所有可用的内存时，再次使用new会抛出一个类型为bad_alloc的异常。我们可以用nothrow关键字来阻止其抛出异常：]{.mark}**

    [int \*p3 = new (nothrow) int;
    //**如果分配失败，new会返回一个空指针**]{.mark}

    [92.拷贝控制]{.mark}

    [当定义一个类时，我们显式或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么，一个类通过定义五种成员函数来控制这些操作：**拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数**]{.mark}

    [拷贝和移动构造函数定义了当[用同类型的另一个对象**初始化**本对象时的操作]{.underline}，拷贝和移动运算符定义了[将一个对象**赋予同类型**的另一个对象时的操作]{.underline}，析构函数定义了当此类型对象销毁时的操作------它们统称拷贝控制操作]{.mark}

    **[拷贝构造函数]{.mark}**

    **[如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数]{.mark}**

    [class Foo{]{.mark}

    [public:]{.mark}

    [Foo(); //默认构造函数]{.mark}

    [Foo(const Foo&); //拷贝构造函数]{.mark}

    [};]{.mark}

    [**拷贝构造函数的第一个参数必须是一个引用类型**，我们也可以接受一个非const引用在拷贝构造函数中，不过几乎总是使用const。拷贝构造函数在几种情况下都会被隐式地使用，**因此它通常不该是explicit的**]{.mark}

    [如果我们没有为类定义拷贝构造函数，**编译器会自动合成一个**(即使已有其他构造函数，也会自动合成一个拷贝构造函数)]{.mark}

    [一般来说，合成拷贝构造函数会将其参数(**被拷贝的非static对象**)的成员逐个拷贝到正在创建的对象中。内置类型的成员，**它会直接拷贝**；而类类型的成员(其他自定义类)，**则会使用其拷贝构造函数来拷贝**。虽然我们**不能直接拷贝一个数组**，但它也会逐元素地拷贝一个数组类型成员。]{.mark}

    [拷贝初始化在以下情况均会发生，它们可以通过拷贝或移动构造函数实现：]{.mark}

    **[a.用=定义变量时
    b.将一个对象作为实参传递给一个非引用类型的形参]{.mark}**

    **[c.从一个返回类型为非引用类型的函数返回一个对象]{.mark}**

    **[d.用花括号列表初始化一个数组中元素或一个聚合类中的成员]{.mark}**

    [在函数调用过程中，**具有非引用类型的参数要进行拷贝初始化**，对于作为用来初始化非引用类型参数的拷贝构造函数，也是一样的，调用它时需要提供参数，而如果它接受非引用类型参数，那此时所需的**拷贝操作是不能脱离拷贝构造函数存在的**，**因此拷贝构造函数的参数只能是引用类型**。]{.mark}

    [我们前面提到，拷贝构造函数通常不应该是explicit的，**但是普通的构造函数完全可以是explicit的**，这就导致了当构造函数是explicit的时，拷贝初始化与直接初始化就有很大的区别了。作为一个例子，我们看到vector[接受单一参数表示向量大小时的构造函数]{.underline}，它就是explicit的：]{.mark}

    [vector的直接初始化：vector\<int\> v1(10);
    //正确，初始化了一个大小为10的向量]{.mark}

    [拷贝初始化： vector\<int\> v2 = 10;
    //错误，接受一个参数的构造函数是explicit的]{.mark}

    [更容易犯错的地方：]{.mark}

    [void f(vector\<int\> v3);
    //函数接受一个vector类型参数，这是非引用类型参数]{.mark}

    [f(10);
    //错误，非引用类型参数通过拷贝初始化，而vector的构造函数explic不允许拷贝构造，因此无法通过10初始化一个vector]{.mark}

    [f(vector\<int\> v3(10) );
    //正确，通过直接初始化方式构造了vector]{.mark}

    [当我们使用小括号来直接初始化时，编译器是略过了拷贝构造函数的，但是这不意味着拷贝构造函数可以被隐藏起来，**无论何时，拷贝/移动构造函数都必须是存在且可访问的**（比如不能是private的）]{.mark}

    **[拷贝赋值运算符]{.mark}**

    **[类既可以控制其对象初始化的方式，也可以控制其对象赋值的方式]{.mark}**

    [这需要略微介绍一些重载运算符的知识，具体讨论在后面的条目中。]{.mark}

    [重载运算符本质上是函数，它的名字组成： **operator\~
    其中\~是我们要定义的运算符符号**。例如重载赋值运算符就是一个名为operator=
    的函数。重载运算符的参数表示运算符的运算对象：]{.mark}

    [即**ReturnType operator\~(Parameters);**
    ReturnType是运算符的返回类型，，括号内的参数根据重载的运算符是一元还是二元，相应地需要一个或两个或零个。]{.mark}

    [重载运算符可以作为成员函数和非成员函数，作为成员函数时，**其左侧运算对象被绑定至隐式的this，通常是赋值运算符和下标运算符；**作为非成员函数时，**其左侧运算对象作为第一个参数，右侧运算对象作为第二个参数传入重载运算符函数，更多参数以此类推。**]{.mark}

<!-- -->

a.  [拷贝赋值运算符]{.mark}

    [它作为类的成员函数，通常接受与所在类类型相同的参数]{.mark}

    **[Type& operator=(const Type&);
    赋值运算符通常返回指向其左侧运算对象的引用，这里拷贝赋值的左侧对象的类型也是Type，因此返回类型为Type&]{.mark}**

    [合成拷贝赋值运算符：如果一个类未定义自己的拷贝赋值运算符，那么编译器会为它生成一个合成拷贝赋值运算符，默认将右侧运算对象的每个非static成员赋给左侧运算对象的成员]{.mark}

    **[析构函数]{.mark}**

    [析构函数释放对象使用的资源，并且销毁对象的**非static成员**]{.mark}

    [析构函数也是作为类的成员函数，它没有返回值，也不接受参数]{.mark}

    [语法： **\~Type(){\...};
    函数体是可选的，它可以用delete等关键字决定析构时的操作**
    因为它不接受参数，所以自然也不能被重载]{.mark}

    **[对于一个给定类，只能有一个析构函数，若类本身未定义析构函数，则编译器为它生成一个合成析构函数]{.mark}**

    [析构函数发生场景：1.变量离开其作用域；2.当一个对象被销毁时，其成员被销毁]{.mark}

<!-- -->

3.  [容器被销毁时，其元素被销毁；]{.mark}

4.  [对于动态分配的对象，当指向它的指针应用delete运算符时对象被销毁；]{.mark}

5.  [对于临时对象，当创建它的完整表达式结束时，对象被销毁]{.mark}

    [cpp中我们并不需要定义所有控制类的拷贝的操作：拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符，析构函数，我们可以只定义一两个而不定义其他的。但是这五个操作通常是每个都被需要的，只是我们让编译器为我们合成了而已。]{.mark}

    **[当我们决定一个类是否需要定义它自己的拷贝控制成员时，应该基本原则是确定这个类是否需要自定义一个自己的析构函数，如果需要，则基本可以肯定它也需要拷贝构造函数和拷贝赋值运算符。例外的是：如果需要自定义拷贝构造函数和拷贝赋值运算符，那不一定需要自定义析构函数]{.mark}**

    [这三个操作如果只自定义其中一个，那往往会出问题，例如：如果只自定义了一个析构函数，操作是delete某一个成员，而使用合成的拷贝构造函数和拷贝赋值运算符。同时该成员是一个可能在多个类实例中能指向同一个地址的指针，那么在拷贝构造和最终返回时可能会出现对同一个地址应用两次delete(被拷贝的实例被析构一次+被构造对象返回时析构一次)，从而导致错误。因此这时最好把拷贝构造函数和拷贝赋值运算符也自定义一下防止可能的问题。]{.mark}

    [除了隐式方法之外，也可以显式地要求编译器合成：应用=default即可]{.mark}

    [Type (const Type&) = default; \~Type() = default;]{.mark}

    [与=default相似但不同的是=delete，它的作用是阻止拷贝与赋值，防止编译器为它们生成合成的版本，例如]{.mark}

    [Nocopy &operator = (const Nocopy&) = delete;
    是一个阻止赋值的操作]{.mark}

    **[=delete通知编译器，我们不希望定义这些成员]{.mark}**

    [值得注意的是，**我们不能对析构函数使用=delete**
    ，因为我们无法销毁此类对象，编译器将不会允许我们创建一个delete了析构函数的类型的临时对象或定义了此类型的变量，**不过我们可以动态分配这种类型的对象**，比如]{.mark}

    [struct NoDtor {]{.mark}

    [NoDtor() = default; \~NoDtor() = delete;
    //使用默认构造函数，删除析构函数的类]{.mark}

    [}]{.mark}

    [NoDtor nd; //错误，编译器不允许创建此类型变量]{.mark}

    [NoDtor \*p = new NoDtor();
    //正确，创建了一个指向该类型动态分配对象的指针，
    但我们无法删掉它了]{.mark}

    [delete p; //错误，因为NoDtor析构函数被删除了]{.mark}

    [我们知道，如果未定义拷贝控制成员，那么编译器会为我们定义一个合成的版本，对于构造函数也一样，会定义默认构造函数。但**合成的拷贝控制成员可能是删除的**，这会出现在以下情况：]{.mark}

    [①类的某个成员的析构函数是删除的或不可访问的(例如是private成员)，则其合成析构函数被定义为delete删除的，其合成拷贝构造函数也会被定义为删除的]{.mark}

    [②类的某个成员的拷贝构造函数是删除的或不可访问的，则其合成拷贝构造函数被定义为删除的]{.mark}

    [③类的某个成员的拷贝赋值运算符是删除的或不可访问的，或者类有一个const的或引用的成员，则其合成拷贝赋值运算符被定义为删除的]{.mark}

    [④类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器
    或类有一个const成员，它无类内初始化器切其类型为显式定义默认构造函数，则该类的默认构造函数被定义为删除的]{.mark}

    [这四条的本质都在于：**如果一个类有成员不能默认构造，拷贝，赋值或销毁，则其对应的成员函数将会被定义为删除的**]{.mark}

    [新标准以前，我们把拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝：]{.mark}

    [class KK{]{.mark}

    [KK(const KK&); KK &operator=(const KK&);]{.mark}

    [public:]{.mark}

    [KK() = default; \~KK();]{.mark}

    [}]{.mark}

    [这里public之前的部分默认为private，从而阻止非友元与成员函数拷贝该类型对象，为了阻止友元与成员函数的拷贝，我们只在private中声明拷贝构造函数和拷贝赋值运算符，而不定义它们，除了后面会提到的某些情况外，这样的操作是合法的。当然在新标准下，我们无需也不应该使用这种方法，直接=delete更好]{.mark}

    [一般来说，一个负责管理类外资源的类（即类有分配和释放内存的功能，如new）必须定义拷贝控制成员，为此我们必须确定此类型对象的拷贝语义（**对象进行复制操作的规则和行为）**，一般有两种选择：**使类的行为看起来像一个值或一个指针**]{.mark}

<!-- -->

A.  [行为像值的类]{.mark}

    [93.组合构造函数]{.mark}

    [Line::Line(Point xp1, Point xp2): p1(xp1), p2(xp2) {]{.mark}

    [\....]{.mark}

    [}]{.mark}

    [这是组合类的构造函数，用Point类型的xp1，xp2构造Line的成员p1和p2，要注意顺序：先p1，再p2，最后Line]{.mark}

    [94.多维数组pArray\[i\]\[j\]中]{.mark}

    [pArray\[i\]也有类型，其类型是指针类型Type
    \*，而pArray则是指针的指针 Type \*\*]{.mark}

    [Type是pArray\[i\]\[j\]的类型，即声明时的]{.mark}

    [Type pArray\[i\]\[j\]]{.mark}

    [更多维度以此类推]{.mark}
