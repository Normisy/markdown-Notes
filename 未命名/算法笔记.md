# 算法基础课
# Chapter 1. 排序与二分
## 1.1 快速排序：基于分治思想
快速排序的算法流程：
①**确定分界点**，假设数组从l到r，常用的边界点有：左边界l 右边界r与中心（l+r)/2，或者随机取一个数都行．

②把整个区间进行筛选，**保证所有左边区间的数小于等于x，右边区间的数大于等于x**即可，这部分是最复杂的

③递归处理左右两端，左右分别排好了整个区间也就排好了．

整个算法核心部分是②。先看一种暴力的算法处理它，理解起来比较简便：
* 1. 建立数组a\[]、b\[]以及存最终结果的数组M\[]
* 2. $$ 扫描储存原数列的数组q区间[l, r]:\quad \begin {cases}
 当q[i]\leq x 时，把x插入a[\quad]\\
当q[i]>x时，把x插入b[\quad]\end {cases}
$$
* 3. 把数组a\[]插入M\[]，再把b\[]插入M\[]。

这种做法十分暴力，**时间复杂度O(N)，但额外占用了空间**．

更优美，也是建议直接背下来的双指针算法：
在区间q\[l~r的**两端定义两指针i与j**，分别**往中间走**，对于左端的i，**如果指向的数小于x，就往后移动一位，如果指向的数大于等于x，就停下来**，转而开始移动j。对于j也是类似的，**如果指向的数大于等于x，向前移动一位，直到指向的数小于x停下**，此时**把i和j指向的数进行交换（swap)**，然后继续移动i。这样的步骤**直到i与j相遇停止**．

显然这种方法是正确的。

这样思路虽然简单，但有许多下标方面的细节会需要注意**边界问题**，这时建议多背模板，考试时重推很浪费时间
例题：第一行输入一个大于1小于1e6（10^6）的整数n，第二行输入n个整数代表数列，要求进行快速排序
```
#include <iostream>
using namespace std;

const int N = 1e6+10;  //多一点防止溢出
int n; int q[N];

void quick_sort(int q[], int l, int r){
if (l >= r)  return;  
//当两端重合时，说明输入只有一个数，直接返回。>=改为==也一样
int x = q[(l + r)/2], i = l-1, j = r+1;
//这里取x为中点，事实上上面说的点都能取。i和j要加一减一，因为后面的do-while语句先执行后判断

while(i < j){
do i++;  while(q[i] < x);
do j--;  while(q[j] > x);
//移动两指针的作用是*略过符合要求的项*，在不符合的地方停下等待递归
if (i < j)
	swap(q[i], q[j]);
//只有当i和j都停下时才会进行交换，不能省略
}
quick_sort(q, l, j);
quick_sort(q, j+1, r);
//递归处理是靠这一步而非dowhile语句：此时以j为原来的右边界，处理左侧的小区间；j+1为左边界处理右侧子区间。然后继续处理各个子区间的两个子区间，从而遍历完所有的项目，完成排序。
//此处也可以i指针为边界：quick_sort(q, l, i-1),quick_sort(q, i+1, r);
//** 注意：如果以i指针为边界，那么int x就不可取q[l]为值了，因为此时产生边界问题，无法递归；同理，如果以j指针为边界，int x不可取q[r] **
}
```

```

int main(){
scanf("%d",&n);    //输入量比较大的时候，scanf会比cin更快，大于等于一百万输入的时候就用scanf

for(int i=0;i<n;i++)     //下面是常规输入输出
scanf("%d" , &q[i] );

quick_sort(q , 0 , n-1);

for(int i=0;i<n;i++)
printf("%d ",  q[i]);//括号里就是输出的内容，所以"%d"后面一定要带空格

return 0;
}
```

## 施工中，先看后面的

# Chapter 2. 高精度计算与前缀和、差分
## 施工中，先看后面的

# Chapter 3. 双指针算法与离散化

# Chapter 4. 数据结构


# 算法提高课
# Chapter 1. 动态规划
## 1.1 数字三角形模型
施工中

## 1.2 最长上升子序列模型（LIS）
施工中

## 1.3 背包模型：组合类型的dp
简要回顾以下算法基础课中的背包模型
01背包问题：每个物体只有选或不选两种情况
**状态表示**$$f[i,j]\rightarrow \begin{cases} 集合：所有只从前i个物品中选，且总体积不超过j的选法的集合\\
属性：所有物品的最大价值Max 
\end{cases}
$$
**状态计算（集合划分）：一般通过有区分度的“最后一步”进行划分**
这里的最后一步就是“最后一个物品”，**01背包问题中只有“选或不选”两个方案，因此划分如下：**
![[Pasted image 20240913183725.png]]
在划分好两个集合之后，**只需要求出两个集合各自的最大值，然后对其取Max即可得到我们想要的值**
对于左侧集合，设第i个物品的体积为$v[i]$，价值为$w[i]$，从定义上可见，其最大值等于选择第i-1个物品且总体积不超过$j-v[i]$的最大价值，$Max_1=f[i-1, j-v[i]]+w[i]$
对于右侧集合，就是简单的$Max_2=f[i-1,j]$了。对这两个值求max就可得到所需值

完全背包问题：每个物品可以选$0,1,\cdots, \infty$个
**状态表示：和01背包问题一致**
**状态计算：增加了多次选择第i个物品的可能，因此要改变划分方法**
第i个物品可以选择多次，因此**按照选择多少次第i物品进行划分**：
![[Pasted image 20240913185112.png]]
因为总体积是有限的j，因此**最多只能选择有限个**
下面计算各集合的最大值，前面和01背包问题都差不多：
$Max_0=f(i-1,j), Max_1=f(i-1,j-v_i)+w_i, Max_2=f(i-2,j-2v_i)+2w_i,\cdots$
而这么直接计算，需要在0到s进行枚举，这会导致增加一重循环，使得算法时间复杂度为$O(n^3)$，因此需要进行优化
我们注意到
$$ \begin{align}
f[i,j]&=max(f[i-1,j],&f[i-1,j-v]+w,f[i-2,j-2v]+2w,\cdots , f[i-1,j-s*v]+s*w)\\
f[i,j-v]&=max(&f[i-1,j-v]+w,f[i-2,j-2v]+2w,\cdots , f[i-1,j-s*v]+(s-1)*w)
\end{align}$$
很显然，上面每一项的除第一项之外的每一项都比下面的多了一个w，因此可以直接用下面进行替换，因为求的是最大值
$$f[i,j]=max(f[i-1,j],f[i,j-v]+w)$$
算法基础课的相应部分有其代码实现的细节，例如优化状态表示为1维表示
**当空间优化成1维以后，只有完全背包问题的体积是从小到大进行循环的

多重背包问题：每个物品选$0,\dots , s_i$个