# 0. 基于ASCII码进行文本的编码和解码（文件读写）
## 0.1 编码算法

表头给出的可打印字符从32到126，**不妨减去32使其映射至0到94** 
由于下面每一行的字母都比上一行向左移动了一个位置，所以：  
我们在忽略表头的一行一列的情况下编码行列号，也就是**把一串可打印字符储存到0到94这95个位置的数组中**  
设行表头选中的字符位于数组索引x处，列表头选中的字符位于数组索引y处  
相对于标准的可打印字符数组，索引为y的行上的可打印字符数组相对原数组向左偏移了y位  
也就是说，原数组开头的前y个字符被砍去，并且按原顺序被接到数组的后y个字符中去了  
那么我们就可以根据得到的y，构建出一个现字符数组，例如  
假设原字符数组是：abcdefg  
那么y=3时的现字符数组为：defgabc  
注意y从0开始数  

编码算法的思想：首先，我们构建一个大小为95的字符数组aschar\[95]，使用强制类型转换`static_cast\<char>(int值)` ，把第32-126的字符存进去  
然后，根据编码字符串和被编码文本，构建出编码串与被编码文本对应，设为char A\[N]和char B\[N]，N是相同的  
从编码串A中读出一个字符A\[i]，使用`static_cast<int>(A[i])-32`就可以得到该字符在aschar中的索引了
得到索引，就是我们的y了 
可以发现，y的值域为\[0, 94]。最多可偏移94个单位，即除了'~'都被砍掉然后接到后面去了，这是合理的
  
有了这个y，我们还需要根据编码串字符A\[i]对应的被编码文本B[i]，用`static_cast<int>(B[i])-32`得到索引x。  
我们来寻找“给定x和y，假设构建出来一个向左偏移y位的现字符数组，求该数组索引为x的字符是哪个”的数学规律：

设行表头选中的字符位于数组索引x处，列表头选中的字符位于数组索引y处
x和y都是从0开始数的，通过代码可以简单得到
把问题缩小为8位数组的情况
原aschar： a b c d e f g h      在y=3时
现          ： d e f g h a b c
那么：
- 当x<=8-y-1=7-y，例如x=4，此时要找的字符'h'处于aschar\[x+y]（注意这里x和y都是从0开始数的）
- 当7-y< x <= 7，例如x=5，此时要找的字符'a'位于aschar\[x-(8-y)]


于是总结为 ：
- 0<= x <= 94-y时，字符r为aschar\[x+y]
- 94 - y < x <= 94时， 字符r为aschar\[x-95+y]

那么编码算法就可以很容易地写出来了：
$$ k = \begin{cases}
x+y,\quad 0\leq x\leq 94-y\\
x-95+y,\quad 94-y<x\leq 94
\end{cases}$$

## 0.2 解码算法
和编码算法相反，我们有一个编码串A\[N]和一个待解码串C\[N]，N相同
其实差距并不大，我们依然从编码串A\[]中取出一个元素A\[i]
将A\[i]使用`static_cast<int>(A[i])-32`得到索引y
那么现在的问题就是在得到y和字符r的情况下，求出x使用`static_cast<char>(x+32)`转换回字符

通过`static_cast<int>(C[i])-32`，我们可以得到待解码字符串同位置上字符r在aschar中的索引k
我们知道：
$$ k = \begin{cases}
x+y,\quad 0\leq x\leq 94-y\\
x-y-2,\quad 94-y<x\leq 94
\end{cases}$$
于是：
当$0\leq x\leq 94-y$时，由于$k=x+y$，此时$y\leq k\leq 94$，，有$x=k-y$
当$94-y<x\leq 94$时，由于$k=x-95+y$，此时$-1<k\leq y-1$，有$k+95-y$
得到：
$$ x=\begin {cases}
k-y,\quad y\leq k\leq 94\\
k+95-y,\quad -1<k\leq y-1
\end{cases}$$
然后再使用`aschar[x]`把各位上的字符转换回原来的字符即可。

## 0.3 文件读写优化
如果只是将输入文件保存到string然后完成输出，空间复杂度过高。因此想办法在单个字符读入后就进行编码+输出

# 1.task1线性表

## 1.2 法雷数列
## 1.2.1 算法思路
总之先看到$n\leq 5$时的法雷数列：
![[Screenshot_20240919_150722_com.huawei.photos.png]]
可以发现，对于法雷数列$F_n$，分母不等于n的部分是可以在$F_{n-1}$中间找到的，而在分母=n的项中，**其分子和分母n是互质的**，也就是说$F_n$与$F_{n-1}$的个数差异为**小于n且与n互质的数的数目**
而给定一个数n，求解小于n且与n互质的数的步骤可以这么进行：
- 1. 将**所有小于n的质数**处理出来
- 2. 将第一步处理出的质数中，被n模后余数为0的质数剔除：即剔除$n\% t ==0$的所有t，将剔除的t放在另一个动态数组中
- 3. 所有剩下的a和n-a，以及1和n-1，就是小于n且与n互质的整数了
- 我们设a和1这样被直接处理出来的数为整数b，而n-a和n-1这样通过减法得到的数为整数c

下面的问题在于：由于法雷数列是递增的，同时题目不允许使用任何数值比较的方法进行排序，如何将处理出来的这些数放到合适的位置上？
根据法雷数列的性质：对于数列中的连续三项：$a_n = s_n / m_n,\quad  a_{n+1} = s_{n+1} / m_{n+1},\quad a_{n+2} = s_{n+2} / m_{n+2}$，有：
$$ s_{n+1} = (s_n + s_{n+2} ) , \quad m_{n+1} = (m_n + m_{n+2}) （可能经过约分） $$

在求小于n且与n互质的数的时候，我们单独处理出了所有被n模后余数为0的质数t，遍历存储t的数组，利用$(m_n + m_{n+1})\%t_i==0 \quad\&\&\quad (s_n + s_{n+1})\%t_i ==0 \quad\&\&\quad (m_n + m_{n+1})/t_i==rank$
其中rank为链表的阶数，就可以求出所有满足条件的分母$(m_n + m_{n+1})/t_i=rank$（不需要计算，直接是阶数rank），和所有满足条件的分子$(s_n+s_{n+1})/t_i$了，并且知道该分数的插入位置就在$a_n=s_n / m_n$之后
小于n的质数的个数小于$(n)^{\frac{1}{2}}$，其中被n模后余数为0的数就更少，对性能影响很小。那么该算法中主要影响性能的是对n-1阶链表的遍历搜索，找到数的位置。

因此我们尽量优化一下搜索的过程，虽然单链表无法使用二分等方法优化，但是

## 1.3 大数阶乘
首先我们明确所使用的数据结构：双链表，因为可以进行尾插，不需要考虑反向的情况下就能进行各种运算
### 1.3.1 结构搭建
使用双链表，从低位到高位，从前往后存储，然后从后往前输出。
### 1.3.2 算法
首先，明确一下我们的乘法结果的储存：我们使用乘法左侧的对象的副本来进行存储和计算。
我们以3位的链表结点为例写出乘法的进位原则。
我们的乘法是以每个链表结点的位数为最小单位进行的，也就是说当链表结点为3位时，我们将数的每三位数作为一个整体来考虑。
于是，考虑一个三位数乘法：$$\begin{align}
999 * 999 &= 998001 \\
999 + 999 &= 1998
\end{align}$$
不难发现所有的n位内整数乘法的结果位数在2n以内，加法位数在n+1以内。于是我们可以这么想：
观察三位数乘法：
$$ 
\begin {align}
&1 \quad \quad 2 \quad \quad 3 \\
&4 \quad \quad 5 \quad \quad 6 \\
&------ \\
&6 \quad \quad 12\quad \quad 18\\
5\quad \quad &10 \quad \quad 15 \\
4\quad \quad 8\quad \quad &12\\
-------&------------\\
4 \quad \quad 13\quad \quad &28\quad\quad 27\quad\quad 18

\end {align}
$$
然后最后将个位以外的数进到前面一位就得到结果
因此类似地，我们的计算也**把进位放在最后处理**：先计算各个结点相乘后的数值，使用一个int data保存各位上没有进行进位的原始数值
然后每次相乘，都把原始数值加到对应位置的int data 上
**最后根据int data的值进行进位，低位保存在int item中，高位加到前一位的int data，如果前面没有结点了就新建结点，最后输出int item即可**

# 2. task2 栈与队列
## 2.1 列车重排
使用栈对列车进行排序，使得列车呈现降序排列
缓冲车道使用栈的形式存储，可能有多个缓冲车道

列车使用栈进行存储，每节车厢为栈的一个结点，根据输入构建列车。每个栈维护一个size，用于判定车厢位置是否满足要求，从0开始数
缓冲车道各自满足自顶向下递增的关系
出轨final使用size进行判断，如果输入的值\=\=size+1，将其放入出轨
如果不满足栈顶元素值\=\=size+1：如果1号缓冲车道为空，将原车栈顶元素弹入1号车道；如果原车栈顶元素大于1号车道栈顶元素，将其弹入2号车道；如果原车栈顶元素大于任何一个前面已有的缓冲车道的栈顶元素，那么创建一个新的车道，将元素弹入该车道
而对于一个不需要创建新车道同时不能放入出轨的原车栈顶元素，我们知道缓冲车道最底层的元素自前向后递增，所以从前往后进行与缓冲车道栈顶元素的比较，将其弹入第一个满足栈顶元素大于该元素的缓冲车道

所有缓冲车道使用可变数组进行存储，当所有原车元素都被放入缓冲车道和出轨时，从前往后遍历缓冲车道数组中各车道的栈顶元素，将符合要求的弹入出轨即可
由于输出的要求，为每个车厢增加一个

## 2.2 二值图像分组

# 3. 
## 3.1 根据前序遍历序列+中序遍历序列确定二叉树
前序序列：根节点->左儿子->右儿子
中序序列：左儿子->根节点->右儿子

根据这个性质，我们可以知道：
- 对于中序序列中的任何一个元素，其左边的所有元素为其左子树的所有元素；其右边的所有元素为其右子树的所有元素
- 对于前序序列的任何一个元素，根节点后面的元素首先是左子树的所有元素，然后是右子树的所有元素，再进行细分，根节点的子节点若作为父节点，那么这个子结点对应的子树集合序列（也就是整个序列去掉另外一个子树集合中的所有元素得到的子序列）也符合这个要求（相当于是该子结点作为根节点了）

因此，根据这个性质，我们可以：
对于一个结点，我们提取出以该结点为根节点的子树集合（子序列），这个通过在树的中序序列中寻找到这个元素的位置索引i，然后该结点的左子树的元素个数为i（索引从0开始数），右子树的元素个数为size-i
获得了个数之后，我们在前序序列往后数i个，就是左子树集合了；再往后数size-i个，就是右子树集合
对于两个子树集合，前序序列中它们的头元素都是各自的根节点，因此这是一个规模更小的等价问题，符合递归的性质

那么递归中我们想做什么？我们希望将每一步中的根节点与子树的根结点进行连接，所以我们每次递归时，都为获得的两个子树区间的首元素创建一个结点，然后连接到根节点的左右，这就是整个确定树的思路了

基准情况：区间长度为0，即区间头和区间尾产生了交叉

举个例子：
设前序序列  ABFHILMGJKCDEOP
设中序序列  HFLIMBJGKADCOEP

