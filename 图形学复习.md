# C1. 硬件知识总结

# C2. 图元输出：画线

## 1. 扫描转换

在光栅扫描式图形显示器中，控制每个点阵单元的亮度来显示整幅图像，点阵单元实际上就是像素点阵
图形的扫描转换也叫图形的光栅化，它主要分为两步：
- 首先根据图形的定义，在点阵单元上确定最佳逼近于图形的像素集，是连续量向离散量的转换
- 然后根据图形，为像素集中的每个像素指定合适的颜色值
这几章的内容就主要在于对二维几何图形进行扫描转换，以在指定的输出设备上根据坐标描述构造图形

## 2. 直线的扫描转换

直线的扫描转换指的是在有限个像素组成的矩阵中确定最佳逼近该直线的一组像素
直线绘制的质量要求：
- 直线要直
- 直线的端点要准确，没有定向性和断裂的情况
- 直线各处颜色和亮度保持一致
- 画线速度要快

### 2.1 直接使用直线方程

根据线段的斜截式方程$y=kx+b$来进行直线的直接显示：
- 首先将端点转化为像素点坐标(x1, y1), (x2, y2)
- 设置$k=\frac{y_2-y_1}{x_2-x_1}$和$b=y_1-k\times x_1$
- 若$|k|\leq 1$，**对$(x_1, x_2)$开区间上的整数带入方程求y**
- 若$|k|\geq 1$，**对$(y_1, y_2)$开区间上的整数带入方程求y**
对于垂直线段不适合，特殊考虑。对于水平线段与对角线段也特殊考虑

优点：简单；缺点：浮点运算复杂

### 2.2 DDA算法

使用直线的斜截式方程，可以得到：
$$ k=\frac{y_{end}-y_0}{x_{end}-x_0}$$
进而，设x轴的增量为dx，y轴的增量为dy，可以得到：
$$ \begin{align}
dy &= k\times dx\\
dx &= \frac{dy}{k}
\end{align}$$
对于数值微分法，其思想在于**根据当前的像素坐标位置，直接计算下一个像素坐标位置，而不代入方程**
使用微分方程表示直线：
$$ 
\begin{align}
x_{i+1}&=x_i+\epsilon \Delta x\\
y_{i+1}&= y_i+\epsilon \Delta y\\
\epsilon &=\frac{1}{\max(|\Delta x|, |\Delta y|)}
\end{align}
$$
当$\epsilon$足够小时，精度无限高

为了避免直线断裂，我们会选取**最大位移方向：x方向和y方向中，当取该方向1步时，另一个方向移动距离小于1，则该方向为最大位移方向**，从最大位移方向每次移动一单位距离
因此，整个算法计算分情况如下：
首先，取
$$
k=\frac{\Delta y}{\Delta x}=\frac{y_{end}-y_0}{x_{end}-x_0}
$$
然后从$(x_0, y_0)$到$(x_{end}, y_{end})$，执行如下操作：

$$ \begin{cases}
0<k<1\begin{cases}
从左往右画线\begin{cases}
x=x+1\\
y=y+k
\end{cases}\\
从右往左画线\begin{cases}
x=x-1\\
y=y-k
\end{cases}
\end{cases}\\
k>1\begin{cases}
从左往右画线\begin{cases}
y=y+1\\
x=x+1/k
\end{cases}\\
从右往左画线\begin{cases}
y=y-1\\
x=x-1/k
\end{cases}
\end{cases}\\
-1<k<0\begin{cases}
从左往右画线\begin{cases}
x=x+1\\
y=y+k
\end{cases}\\
从右往左画线\begin{cases}
x=x-1\\
y=y-k
\end{cases}
\end{cases}\\
⭐（注意符号相反）k<-1\begin{cases}
从左往右画线\begin{cases}
y=y-1\\
x=x-1/k
\end{cases}\\
从右往左画线\begin{cases}
y=y+1\\
x=x+1/k
\end{cases}
\end{cases}
\end{cases}
$$
上面所有涉及到k的都需要经过一步取整运算
缺点：需要使用浮点运算

### 2.3 中点画线算法

为了消除DDA算法中的浮点运算，注意到对于最大位移方向每个整数坐标所对应的非整数坐标值，**若小数部分小于0.5，那么取下方（正右方）的那个像素，若大于0.5，取上方（右上方）的像素，若等于0.5，我们约定取正右方的那个像素**

因此，我们需要判断计算得到的数值的小数部分与0.5之间的关系，由于浮点运算与比较非常耗时，我们使用线性规划的方式进行判别，具体来说：
给定已知直线的隐式方程$F(x,y)=ax+by+c=0$，其中$a=y_0-y_1, b = x_1-x_0, c=x_0\times y_1-x_1\times y_0$

根据方程的性质，我们可以知道：
$$ \begin{cases}
F(x_t, y_t)=0\Rightarrow (x_t,y_t)在直线上\\
F(x_t, y_t)<0\Rightarrow (x_t,y_t)在直线下方\\
F(x_t, y_t)>0\Rightarrow (x_t,y_t)在直线上方\\
\end{cases}$$
因此，以将x轴作为最大位移方向的情况为例：
设当前像素坐标为$P(x_p, y_p)$，则待选像素为$P1(x_p+1, y_p)$和$P2(x_p+1, y_p+1)$
同时设P1和P2之间的中点为$M(x_p+1, y_p+0.5)$，在线段上的对应点为$Q(x_p+1, y_q)$
那么只需要**将点M的坐标代入隐式方程F(x,y)，判断其符号，即可在P1和P2中选出下一个像素了**

为了简化形式，我们构造**误差项**：
$$
\begin{align}
d&=F(M(x_p+1, y_p+0.5))=F(x_p+1, y_p+0.5)\\

\end{align}
$$
这就是我们的判别式，d大于等于0，选择P2；d小于0，选择P1
而后续的点需要继续判别，我们不对每个点一一计算误差项d，而是通过d0向后续误差项的地推关系式进行d的更新：

1. 当d小于0，选择$P1(x_p+1, y_p)$后，下一个误差项$d'=F(x_{p1}+1, y_{p1}+0.5)=F(x_p+2,y_p+0.5)=y_p+0.5-k(x_p+1)-b+a=d+a$
	也就是说，当$d_i< 0$时，$d_{i+1}=d_i+a$

2. 当d大于等于0，选择$P2(x_p+1, y_p+1)$时，下一个误差项$d'=F(x_{p2}+1, y_{p2}+0.5)=F(x_p+2,y_p+1.5)=...=d+a+b$
	也就是说，当$d_i\geq 0$时，$d_{i+1}=d_i+a+b$

对于初始值$d_0$，设端点为$A(x_0,y_0),B(x_e,y_e)$可以如下求出：
$$
\begin{align}
d_0&=F(M(x_0+1, y_0+0.5))=F(x_0+1, y_0+0.5)\\
&= a(x_0+1)+b(y_0+1/2)+c\\
&= ax_0+by_0+c+a+b/2\\
&=a+b/2
\end{align}
$$

为了避免除法和浮点数的出现，由于仅在初始值$d_0$出现了b/2，且我们只关注d的正负，我们把d变为原来的2倍即可：
$$
\begin{align}
d_0&=2F(M(x_p+1, y_p+0.5))=2F(x_p+1, y_p+0.5)\\
&= 2a(x_p+1)+b(2y_p+1)+2c\\
&=2(ax_p+by_p+c)+2a+b\\
&=2a+b
\end{align}
$$
而后续的递增变为
$$\begin{cases}
d_i\geq 0\Rightarrow d_{i+1}=d_i+2a+2b\\
d_i<0\Rightarrow d_{i+1}=d_i+2a

\end{cases}
$$



因此可以得到总的算法流程
$$ 
\begin{align}
1.& 给定端点A(x_0,y_0),B(x_e,y_e),(已经取整)\\
2.& 求出\begin{cases}
a=y_0-y_e\\
b=x_e-x_0\\
d_0=2a+b
\end{cases}\\
3.& d_0相当于就是点A的误差项，根据d_0的正负判断点A的下一个像素位置，然后更新d_0
\\
4.&更新策略：
\begin{cases}
d_i>0\Rightarrow 下个点选择右上方点(x_i+1,y_i+1)，d_{i+1}=d_i+2a+2b\\
d_i<0\Rightarrow 下个点选择正右方点(x_i+1,y_i)，d_{i+1}=d_i+2a\\
i=0、1、2、\cdots 、e-1
\end{cases}
\end{align}
$$

## 2.4 Bresenham算法

基本思想是画线算法每次迭代，在最大位移方向必定需要走一步，而在另一个方向不一定需要走，我们只需要判定它什么时候在非最大位移方向走一步即可

设端点为$P1(x_0, y_0)$和$P2(x_e, y_e)$，$k=\frac{\Delta y}{\Delta x}$
1. 最大位移方向为x
此时y方向在x方向每走一步时移动的距离是k，若k的小数位置<0.5，那么选取的点就是当前点$(x_i, y_i)$的正右侧点$(x_i+1,y_i)$；若$k\geq 0.5$，则选择$(x_i+1,y_i+1)$
同时，接下来要再+k变为2k，判断2k的小数位置与0.5的关系

2. 最大位移方向为y
同理，只是k变成了1/k

但是这种形式过于麻烦，因为还要取小数，作浮点运算等等

为了进行优化，我们取下面的判别量
$$ 
\begin{align}
e&=(d-0.5)\times 2\Delta x=x\\
\Delta x &= x_e-x_0\\
d&=\begin{cases}
k, 最大位移方向为x\\
1/k, 最大位移方向为y
\end{cases}
\end{align}
$$
于是有以下算法步骤：
$$\begin{align}
1.& 输入直线端点P_0(x_0, y_0)和P_1(x_1, y_1)\\
2.& 计算初始值：\begin{cases}
\Delta x = x_1-x_0\\
\Delta y = y_1-y_0\\
e_o = -\Delta x_0\\
x = x_0\\
y = y_0
\end{cases}\\
3.& 绘制点(x,y),然后更新e=e+2\Delta y(这一步每次都要做)\\
4.& \begin{cases}
若e>0,\begin{cases}
x=x+1\\
y=y+1\\
e=e-2\Delta x
\end{cases}\\
若e\leq 0,\begin{cases}
x=x+1\\
y=y\\
e不更新
\end{cases}\\
\end{cases}

\end{align}$$

# C3. 图元输出：画圆

## 3.1 简单画圆算法

对于最简单的画圆算法，存在两种思想：
1. 基于离散点的二维坐标，利用圆方程导出x、y坐标逐个计算，此时需要开平方、乘方和取整，计算量太大了，而且还要检查最大位移方向
2. 基于极坐标，利用参数方程$\begin{cases} x=R\sin\theta\\ y=R\cos\theta \end{cases}$ 将角度离散化，逐个解算xy坐标。该方式需要计算三角函数，同样过于复杂

## 3.2 DDA画圆算法

### 1. 角度DDA法

已知最简单的圆方程$x^2+y^2=R^2$，可以得到：
$$ \begin{align}
x_n&=R\cos\theta, y_n=R\sin\theta\\
dx&=-R\sin\theta d\theta =-y_nd\theta\\
dy&=R\cos\theta d\theta =x_nd\theta
\end{align}
$$
此处的$d\theta$即为步长：
$$
\begin{align}
x_{n+1}&=x_n+dx=x_n+(-y_nd\theta)\\
y_{n+1}&=y_n+dy=y_n+x_nd\theta
\end{align}
$$
因此，我们选取合适的步长值：
$$ |d\theta| = \frac{1}{R+1}$$
这是为了使得$max(|(y_n-y_0)d\theta|,|(x_n-x_0)d\theta|)\leq max(|(y_n-y_0)|,|(x_n-x_0))|\times |d\theta| = R|d\theta|\leq 1$得到的，为了精度更好将分母加了1

同时，注意到圆的对称性，我们只需要在x轴与y=x之间第一象限的部分绘制圆的八分之一，然后利用对称性映射到另外七个区域即可
算法步骤：
1. 假设圆心在原点，初始化$x=R, y=0,\theta=0$
2. 然后通过$\theta = \theta + d\theta=\theta + \frac{1}{R+1}, x=R\cos\theta, y=R\sin\theta$更新值
3. 同时绘制另外七个对称点
4. 在$x>y$时重复23步骤。直到$x\leq y$

缺点：需要计算复杂的三角函数

## 3.3 中点画圆算法 

为了避免三角函数和乘方开方计算，参照中点画线算法我们可以知道：
设圆的隐式方程为$F(x,y)=0$，那么有：$\begin{cases} F(x_t,y_t) > 0\Rightarrow 点在圆外\\F(x_t,y_t) = 0\Rightarrow 点在圆上\\F(x_t,y_t) < 0\Rightarrow 点在圆内 \end{cases}$

我们只考虑**在y轴与y=x之间第一象限的部分**绘制圆的八分之一，然后利用对称性映射到另外七个区域即可，此时**最大位移方向为x方向**
而在这个区域绘制时，只会出现以下两种待选点：
$$ \begin{bmatrix}
P & P_u \\
- & P_d
\end{bmatrix}$$
当前点是$P(x_p, y_p)$，待选点是$P_u(x_p+1,y_p)$和$P_d(x_p+1, y_p-1)$
仿照中点画线算法，假设是最简单的圆方程$x^2+y^2=R^2$，可以构造如下误差项：
（注意因为是下面的中点，所以-0.5）
$$
d=F(P)=F(x_p+1, y_p-0.5) = (x_p+1)^2+(y_p-0.5)^2-R^2
$$
当$d_i\leq 0$时，说明圆上的点相比中点更高，取$P_u$，则有：
$$ d_{i+1}=F(P_u)=F(x_p+1, y_p-0.5) = d_i+2x_p+3$$
当$d_i>0$时，说明圆上的点相比中点更低，取$P_d$，则有：
$$ d_{i+1}=F(P_d)=F(x_p+1, y_p-1.5) = d_i+2(x_p-y_p)+5$$

而对于d的初始值，可以得到：
$$ 
d_0=F(x_0+1,y_0-0.5)=F(0+1, R-0.5)=1.25-R$$
（初始点是$P(0, R)$)
为了使其简便和消除浮点运算，使用$d-0.25$代替$d$，这样将正负判断变为d和-0.25的大小判断，但是**因为d始终为整数（其增量都是整数，可以进行舍入）**，这个大小判断又等价于d和0的判断，即**仍为d的符号判断**

综上所述，整个算法流程为（假设圆心在原点）
$$ \begin{align}
1.& 输入圆半径R\\
2.& 计算初始值d=1-R, x=0, y=R\\
3.& 绘制另外七个对称点\\
4.& 判断d的符号：\begin{cases}
d\leq 0\Rightarrow 先令d=d+2x+3，再更新\begin{cases}
x=x+1\\
y=y
\end{cases}\\
d> 0\Rightarrow 先令d=d+2(x-y)+5，再更新\begin{cases}
x=x+1\\
y=y-1
\end{cases}\\
\end{cases}\\
5.& 当x<y时，重复34步骤，直到x\geq y
\end{align}$$
注意，我们是**先更新d，再更新坐标**，因为d的增量依赖于未更新的坐标
缺点：算法中**存在浮点运算**
## 3.4 Bresemham画圆算法

依然先考虑圆心在原点的圆的第一象限情况，由3.3可知，在这个区域绘制时，只会出现以下两种待选点：
$$ \begin{bmatrix}
P & H \\
- & D
\end{bmatrix}$$
当前点是$P(x_p, y_p)$，待选点是$H(x_p+1,y_p)$和$D(x_p+1, y_p-1)$

该算法的思想是：**H点和D点中距离圆周边界距离最小的点，就是下一个像素点**
它只存在三种情况：
1. H和D全部在圆内
2. H在圆外，D在圆内
3. D在圆上，H在圆外
我们采取**H点和D点到圆心的距离平方减去半径的平方**来度量这个圆周边界距离
$$ 
\begin{align}
\Delta_H&=(x+1)^2+y^2-R^2\\
\Delta_D&=(x+1)^2+(y-1)^2-R^2\\
\end{align}$$
显然，根据三种情况，$\Delta_D\leq 0$
则有如下判别式：
$$\delta = |\Delta _H|-|\Delta_D|$$
若$\delta\leq 0$，选择点H作为下一个像素，否则应选D

**当$\Delta_D<0$时，只可能为情况1或2**
1. 情况1：H和D都在圆内
由于在第一象限，y随x单调递减，由于H比D的纵坐标大，所以显然选择H

2. 情况2：H在圆外，D在圆内
有$\Delta_H > 0 且\Delta_D <0$，因此
$$ 
\begin{align}
\delta &= \Delta_H+\Delta_D\\
&= 2\Delta_D+2y-1
\end{align}$$
所以，若$2\Delta_D+2y-1\leq0$，选择H为下一像素，反之选择D为下一像素

为了保证一致性，我们不妨对于情况1也验证一下$\delta = 2\Delta_D+2y-1$的取址：
此时有$\Delta_H < 0 且\Delta_D <0$，因此显然$\delta = 2\Delta_D+2y-1\leq 0$
根据情况2的判断选择H，根据情况1原本的显然判断也是选择H，因此**两套方法是一致的**

因此归纳如下：
$$ 当\Delta_D<0时，若2\Delta_D+2y-1\leq0，选择H为下一像素，反之选择D为下一像素$$


**当$\Delta_D=0$时**
因为D到圆周边界距离已经是0了，不可能更小了，因此**直接选择D作为下一像素**

那么一切问题就在于计算$\Delta_D$
依然采取代入+增量法：

1. 当下一像素（第i像素）是H时
$$
\begin{align}
\Delta_D^{(i+1)} &= ((x+1)+1)^2+(y-1)^2-R^2\\
&=\Delta_D^{(i)}+2(x+1)+1
\end{align}$$
2. 当下一像素是D时
$$
\begin{align}
\Delta_D^{(i+1)} &= ((x+1)+1)^2+((y-1)-1)^2-R^2\\
&=\Delta_D^{(i)}+2(x+1)-2(y-1)+2
\end{align}$$

最后计算$\Delta_D$的初始值：
$$ 
\begin{align}
\Delta_D^{(0)} &= (0+1)^2+(R-1)^2-R^2\\
&=2\times (1-R)
\end{align}$$
即可得到最终的算法了

若圆心不在原点，则将xy改为$\begin{cases} x\rightarrow x+x_c\\  y\rightarrow y+y_c\\ \end{cases}$即可，带C的为圆心坐标常数


## 3.5 中点画椭圆算法

由于椭圆四个象限内的部分没有关于y=x的对称性，因此在画椭圆时需要画出四分之一的部分，随后进行对称映射

椭圆的隐式方程为：
$$ \begin{align}
\frac{x^2}{a^2}+\frac{y^2}{b^2}&=1\\
\Rightarrow F(x,y)=b^2x^2+a^2y^2-a^2b^2&=0
\end{align}
$$
同样地，有$\begin{cases} F(x,y)=0\Rightarrow 点在椭圆上\\ F(x,y)>0\Rightarrow 点在椭圆外\\ F(x,y)<0\Rightarrow 点在椭圆内\end{cases}$

同时注意到，在四分之一的椭圆部分，最大位移方向会在x方向和y方向之间变化，其分界点随椭圆的长短轴不同而会改变，因此需要**引入法向量找到分界点**
$$ \frac{\partial F}{\partial x}+\frac{\partial F}{\partial y}=2b^2 x+2a^2y$$
可以看到，在x方向上的偏导数为$2b^2x$，在y方向上的偏导数为$2a^2y$，若一个方向的偏导数大于另一个方向的偏导数，则该方向为最大位移方向

实际操作上，由于我们后续的判断主要依靠中点，因此**利用偏导数确定最大位移方向所代入的点也是中点**：
$$ \begin{cases}
2b^2(x_i+1)<2a^2(y_i-0.5)\Rightarrow y为最大位移方向\\
2b^2(x_i+1)=2a^2(y_i-0.5)\Rightarrow 分界点，两分量相同\\
2b^2(x_i+1)>2a^2(y_i-0.5)\Rightarrow x为最大位移方向\\
\end{cases}
$$
***若从上一中点到下一中点的不等号改变方向，则说明椭圆弧的部分发生转移，最大位移方向发生改变***

选择椭圆中位于第一象限的四分之一部分，从y轴向c轴绘制，同时对称映射至其余三个部分


1. 对于**上半部分（x为最大位移方向）**，我们构造误差项：
$$ d_1=F(x_i+1,y_i-0.5)=b^2(x_i+1)^2+a^2(y_i-0.5)^2-a^2b^2$$
由于我们从y轴向x轴绘制，此过程y随x递减。所以这里的中点依然是-0.5而非+0.5
显然有$\begin{cases}若d_1\leq 0\Rightarrow 取P_u(x_i+1,y_i)\\若d_1>0\Rightarrow 取P_d(x_i+1,y_i-1)\end{cases}$
递推关系：
$$\begin{cases}
当d_1^{(i)}\leq 0\Rightarrow d_1^{(i+1)}=d_1^{(i)}+b^2(2x_i+3)\\
当d_1^{(i)}> 0\Rightarrow d_1^{(i+1)}=d_1^{(i)}+b^2(2x_i+3)+a^2(-2y_i+2)\\
\end{cases}$$
代入方程即可求出，步骤略

$d_1$的初始值：
$$ 
d_{10}=F(1,b-0.5)=b^2+a^2(-b+0.25)
$$

2. 对于**下半部分（y为最大位移方向）**，构造误差项：
$$ d_2=F(x_i+0.5, y_i-1)=b^2(x_i+0.5)^2+a^2(y_i-1)^2-a^2b^2$$
依然是因为从y到x，因此下一个中点在x方向是+0.5而非-0.5
显然有$\begin{cases}若d_2\leq 0\Rightarrow 取P_r(x_i+1,y_i-1)\\若d_2>0\Rightarrow 取P_l(x_i,y_i-1)\end{cases}$
递推关系
$$\begin{cases}
当d_2^{(i)}\leq 0\Rightarrow d_2^{(i+1)}=d_2^{(i)}+b^2(2x_i+2)+a^2(-2y_i+3)\\
当d_2^{(i)}> 0\Rightarrow d_2^{(i+1)}=d_2^{(i)}+a^2(-2y_i+3)\\
\end{cases}$$

$d_2$的初始值：
$$
\begin{align}
设当&2b^2(x_i+1)-2a^2(y_i-0.5)的符号由负到正时的最后一个点为(x_0,y_0)\\
&d_{20}=F(x_0+0.5, y_0-1)=b^2(x_o+0.5)^2+a^2(y_0-1)^2-a^2b^2
\end{align}
$$
注意，上述所有误差项的递增项都基于$x_i和y_i$，因此算法中需要先更新误差项，再更新x和y坐标

总结，整个算法的步骤如下：
$$ \begin{align}
1.& 输入椭圆长半轴a与短半轴b\\
2.& 计算初值d=b^2+a^2(-b+0.25),x=0,y=b\\
3.& 绘制点(x,y)及其在另外三个象限的对称点\\
4.& 判断d的符号：\begin{cases}
若d\leq 0 \rightarrow \begin{cases}
先更新d=d+b^2(2x+3)\\
再更新\begin{cases}
x=x+1\\
y=y
\end{cases}
\end{cases}\\
若d>0\rightarrow \begin{cases}
先更新d=d+b^2(2x+3)+a^2(-2y+2)\\
再更新\begin{cases}
x=x+1\\
y=y-1
\end{cases}
\end{cases}
\end{cases}\\
5.& 在b^2(x+1)<a^2(y-0.5)时重复3和4，反之转到6\\
6.& 使用上半部分计算得到的最后一个(x',y')求得初值d=b^2(x'+0.5)^2+a^2(y'-1)^2-a^2b^2\\
&同时有\begin{cases}
x=x'\\
y=y'
\end{cases}\\
7.& 绘制点(x,y)及其在另外三个象限的对称点\\
8.& 判断d的符号：\begin{cases}
若d\leq 0 \rightarrow \begin{cases}
先更新d=d+b^2(2x+2)+a^2(-2y+3)\\
再更新\begin{cases}
x=x+1\\
y=y-1
\end{cases}
\end{cases}\\
若d>0\rightarrow \begin{cases}
先更新d=d+a^2(-2y+3)\\
再更新\begin{cases}
x=x\\
y=y-1
\end{cases}
\end{cases}
\end{cases}\\
9.& 在y>0时重复步骤7和8，反之结束
\end{align}$$

# C4. 图形关系与结构

## 4.1 矢量运算

### 1. 概念

1. 造型技术：在计算机中建立适当模型以表示不同图形对象的技术
2. 图形对象按照能否使用欧式几何描述，可划分为$\begin{cases} 规则对象：几何造型、几何模型\\ 不规则对象：过程模拟/数据放大技术\end{cases}$
3. 几何元素：构成形体的最基本元素
4. 图素：可以使用一定几何和属性参数描述的最基本图形输出元素，$\begin{cases}二维图形系统：图元/图素\\三维图形系统：体素（三维空间分割上的最小单位）\end{cases}$
- 线：一维几何元素，可能是两个或多个邻面的交集（正则形体只有两个，非正则可有多个）
- 面：二维几何元素，可以无内环，但必须有且仅有一个外环，具有方向（外法线方向），可以是平面或曲面
- 环：二维几何元素，是由有序有向边组成的边的封闭边界，外环边方向逆时针，内环边则为顺时针
- 体：三维几何元素，由封闭表面围成的空间，边界是有限面的并集

图形信息：图形对象以及构成它的点线面的位置、相互关系与几何尺寸
	几何信息：形体在欧式空间的位置和大小
	拓扑信息：形体各分量的数目以及其相互之间的连接关系，用于消除几何信息具有的二义性
非图形信息：对象的线型、亮度、颜色等信息

拓扑学：研究几何图形或空间在连续改变形状后保持不变的一些性质，只考虑物体间的位置关系而不考虑其形状与大小

刚体运动：不改变图形上任意两点和几何性质的运动，例如旋转和平移
拓扑运动：允许形体作弹性运动，但不改变拓扑信息（图上的点在拓扑意义上与原来相同）
拓扑等价：一个图形作弹性运动与另一图形重合

### 2. 九交集模型

是一套适用于空间查询的模型，能够表示平面几何图形间的拓扑关系
设有空间对象A和B，使用B(A)、B(B)表示其边界；I(A)、I(B)表示其内部；E(A)、E(B)表示其外部，则两者间的拓扑关系为：
$$
\begin{bmatrix}
I(A)\cup I(B) & I(A)\cup B(B)& I(A)\cup E(B)\\
 B(A)\cup I(B)& B(A)\cup B(B)& B(A)\cup E(B)\\
E(A)\cup I(B)& E(A)\cup B(B)& E(A)\cup E(B)
\end{bmatrix}
$$
每个位置的取值为0或1，代表没有相交和有相交

### 3. 矢量

有向线段：一条线段的端点具有次序
矢量：有向线段的起点在坐标原点上
计算机图形学中，所有需要绘制的对象都具有形状、位置和方向等属性，需要编写程序描述它们以及周围的光线强度，计算出最终在显示器上每一个像素的值。
向量分析和图形变换（矩阵计算）是解决这个问题的好方法

向量点积：
$$
a\cdot b=|a||b|\cos\theta=\sum\limits_{i=1}^{n}a_ib_i
$$

向量叉积：
$$
a\times b=|a||b|\sin\theta=\begin{bmatrix}
\vec{i}&\vec{j}&\vec{k}\\
x_a & y_a & z_a\\
x_b & y_b & z_b
\end{bmatrix} = (y_1z_2-y_2z_1)\vec{i}-(x_1z_2-x_2z_1)\vec{j}+(x_1y_2-x_2y_1)\vec{k}
$$
若两向量共线，其叉积为0，点积为两者长度的乘积；若两向量垂直，其点积为0，叉积为两者长度的乘积（模长）
右手定则：计算叉积结果向量的方向，将右手食指指向a的方向，中指指向b的方向，拇指即为叉积方向

#### 使用叉积判断折线段拐向
假设折线段三个点从下往上依次为点p0、p1和p2，则有：
- 若$(p_2-p_0)\times (p_1-p_0)>0$，则p0p1p2向左拐（尖角朝左）
- 若$(p_2-p_0)\times (p_1-p_0)<0$，则p0p1p2向右拐（尖角朝右）
- 若$(p_2-p_0)\times (p_1-p_0)=0$，则p0p1p2共线

## 4.2 几何图形位置关系

### 1. 点在线上的判断

设点为Q，线段为P1P2，则有：
$$ 若(Q-P_1)\times (P_2-P_1)=0,且Q在以P_1P_2为对角顶点的矩形内，则Q在线段P_1P_2上$$

### 2. 两线段相交

主要需要进行快速排斥和跨立实验两步：
1. 快速排斥实验：检查以两线段为对角线的矩形是否相交，如果不相交，则可以肯定它们不相交，直接结束；若相交，则需要进行跨立实验进一步检查
2. 跨立实验：假设线段P1P2和Q1Q1，则有：
$$ 若(P_1-Q_1)\times (Q_2-Q_1)\cdot (Q_2-Q_1)\times (P_2-Q_1)\geq 0，则有两线段跨立$$
此时必有两线段相交

### 3. 圆在矩形中

只需要判断：
1. 圆心在矩形中
2. 圆的半径小于圆心离矩形四边最小的距离

### 4. 点是否在多边形内

#### 奇偶判断
以点P为端点，朝向多边形的任意方向（一般以水平向右）延一条射线L
当L与多边形的交点个数为奇数时，点P在多边形内；若为偶数，点P在多边形外

特别考虑以下特殊情况：
1. 当交点为多边形的顶点时，若顶点所属的两条边在多边形异侧，则计数；在同侧，则不计入交点数量
2. 当L与多边形边重合时，不作计数
3. 当P点在多边形的边上时，直接判断P属于多边形

#### 非零环绕
依然使用从点P任意引出一条射线L的方式，区别在于交点的计数：
将多边形的每条边矢量化：若射线从多边形一条边的左侧穿过该边，则将计数+1，反之将计数-1
若最终的计数值不为0，则P在多边形内部；若为0，则P在多边形外部

规范来说，为了具体确定哪侧是多边形边的左侧和右侧，我们需要为每条边规定一个方向。一般来说，只需要按照“所有边形成的矢量之和为0”的规则确定其方向就行，可能会有多种情况，例如顺时针和逆时针，但都是正确的

### 5. 线段在多边形内

对于凸多边形（凸集合），判断方式很简单：若线段的**两个端点都在凸多边形内**，则线段必在该凸多边形内

对于凹多边形（存在大于180度的内角），情况则较为复杂
判断方法：
1. 求出所有线段和多边形边相交的交点，将交点以先x后y的方式排序，序列中相邻两点就是在线段上相邻的两个交点
2. 若任意相邻两点的中点都在多边形内，则该线段在多边形内
通过反证法可证

只需要检测线段端点和各个相邻交点之间的中点都在多边形内，则必可知线段在多边形内

若线段和多边形某条边内交（交点不是多边形的顶点，而是多边形的两个顶点之间连线边上的点）时，则可以直接确认线段必有在多边形外侧的部分（快速判断）

### 6. 判断凹凸多边形

方法1. 依次判断多边形顶点按照顺时针或逆时针方向遍历，前中后三个顶点的拐向（$(p_2-p_0)\times (p_1-p_0)$的符号）是否一致，若不一致，则为凹多边形；反之为凸多边形

方法2. 依次平移多边形的每个顶点至原点，同时让顶点两侧边的任意一条边与x轴对齐，若对于所有顶点，这么做以后整个图形都在x轴的同一侧（上侧或下侧），则是凸多边形；反之为凹多边形

### 7. 点和线段在圆内

判断点在圆内：点和圆心距离小于半径
判断线段在圆内：由于圆是凸集，只需要判断线段的两个端点都在圆内即可

## 4.3 交点计算

### 4.3.1 线段与线段的交点计算算法

设两条线段为L0=P1P2和L1=Q1Q2，计算它们之间的交点：
1. 判断两者是否相交，通过[前面所讲的相交判断](### 2. 两线段相交)可得，若不相交，直接结束
2. 若L0平行于Y轴（横坐标相同或纵坐标），判断L1是否相应平行
3. 计算两直线斜率，判断是否相同
4. 若斜率不同，则再联立求交
总之就是通过多种快速判断尽量避免直接求交

### 4.3.2 直线或线段与圆的交点

1. 若L是线段，且端点P1和P2都在圆内，则不存在交点
2. 若L平行于y轴，计算圆心到L的距离，与半径r比较，若距离大于r，则必没有交点；反之利用勾股定理求出交点坐标（注意相切情况）
3. 若不平行于坐标轴，求出L的斜率以及点斜式方程，与圆方程联立求解坐标
4. 若L是线段，则求解的坐标还需判断是否在线段范围内

# C5. 区域填充

- 区域：相互连通的一组像素集合，通常由一个封闭的轮廓线定义
- 区域填充：将区域集合内的像素置为新的颜色，可以是常数或函数
- 多边形的扫描转换（填充）：从顶点信息除法求出位于多边形内部的各个像素，将颜色值写入帧缓存对应单元
- 需要解决的问题：确定所填充的像素，需要填充什么颜色

## 5.1 简单线扫描

使用水平扫描线从上往下与多边形求交，每次求交过后将交点按先x后y的坐标进行排序。
根据归纳法我们可以发现，设排序序列从1开始编号，那么当经过序号为奇数的交点时，其到后一个交点之前的所有点都是需要填充的点；若当经过序号为偶数的交点，其到后一个交点之前的所有点都是不需要填充的外点

因此，总的算法步骤是：
1. 在当前扫描线上对所有边求交
2. 将交点进行排序
3. 将交点进行配对：前奇-后偶
4. 在配对交点之间的区间进行填充

缺点：
1. 求交运算复杂且过于频繁
2. 排序运算过于频繁
3. 效率太低
## 5.2 边相关扫描线填充

注意到扫描线是一个像素一个像素地连贯扫描的，且多边形的边互相连接，也具有连贯性，因此我们可以利用它们的连贯性对算法进行优化，减少求交和排序的操作

首先，我们考虑的都是直线边，因此类似于画线算法，直线上每个像素的获取都是可以根据一个初始值+递推来得到的
由于这里我们每次将扫描线往y轴方向上移一个像素单位，因此我们的位移方向就是y方向，此时每一步x方向的位移量是1/k个单位的像素，k为斜率

根据多边形的边互相连接，我们发现并不需要每次都为所有边求交：每次移动时，只有部分边会和扫描线有交点，这样的边称为有效边
由于扫描线从y轴方向移动，不妨**将多边形每条边的y轴最小值作为该边首次出现的位置**
然后构造如下的边数据结构：

| x   | ymax | 1/k | next |
| --- | ---- | --- | ---- |
其中，
- x代表这条边与扫描线第一次相交时交点的x坐标，这是我们递推的初值
- ymax代表这条边上点的最大y值，这样一来结合该边首次出现的位置，就能得到边的范围了
- 1/k是斜率的倒数，代表y轴方向移动一步时x轴方向的移动距离
- next是指向下一条边的指针，用于在递推时实现无缝切换

我们首先维护一个称为边表的数据结构，它是一个按照y轴坐标进行分类存放边的桶，类似如下：

| y=10 |      |
| ---- | ---- |
| y=9  | P2P3 |
| y=8  |      |
| y=7  | P1P2 |
| ...  | ...  |
其中每条边被存放在对应于它们第一次出现时的y轴坐标位置的索引位置，这个表用于记载所有新边的出现，而不负责维护变为无效边的有效边的删除

而随着扫描线扫描进行更新的数据结构是有效边表：它是一个链表，但是是随时更新的：
- 最初有效边表是一个空链表，其没有y索引
- 随着扫描线向上扫描，若该y值处出现新的有效边（通过查询边表获取），将该有效边所对应的结点按照x值递增的顺序插入应该在链表中的位置
- 若在经过某一y值ycurr后，根据边中储存的ymax信息得知ymax < ycurr，此时该有效边变为无效边，将其对应的结点从链表中删去即可

链表更新后，我们通过表中边存储的x值（初始x值x0）来进行递推：每向上移动一个单位像素，x值加1/k，增量也存在表中了，这样就可以避免反复求交影响效率

优点：交点计算采用增量形式，更快；只在有新的有效边加入时排序（其实也就是遍历链表找位置）
缺点：桶和链表的维护开销比较大

## 5.3 边填充

算法基本步骤：
- 按照任意顺序处理多边形的每条边，每条边仅处理一次
- 对于每条边，先求出这条边与每一条X扫描线的交点，对扫描线上交点的右方的所有像素求补（简单来说，假设从线段两端点各自引出两条水平线，在水平线-线段-水平线所围成的范围内，选择在直线右侧的区域，若该区域未填充，则填充颜色；若已填充，则去除颜色）

为了减少运算量，我们可以首先使用最小外接矩形框住整个图形，然后在窗口-水平线-线段-水平线-窗口这个小范围内进行求补

特点：多边形外的像素总被运算偶数次，多边形内的像素总被运算奇数次，根据算法原理显然有偶数次求补后为无色，奇数次求补后为有色

优点：适用于具有帧缓存的图形系统，算法简单
缺点：每个像素被访问多次，对于复杂图形来说处理数据量很大

改进：在外接矩形窗口中央设置一个竖直的栅栏边界，每次取补运算改为对扫描线与边的每个交点与栅栏之间的像素取补，减少运算量

## 5.4 简单种子填充

是一种深度优先遍历算法，它使用栈实现
算法很简单：
1. 从区域内任意选取一个像素点作为种子点入栈，
2. 从栈中取出栈顶种子点
3. 按照连通需求（四连通：一个像素点上下左右四个位置都是可达区域；八连通：一个像素点周围八个位置都是可达区域），检查周围连通的点是否为边界或已经被填充的点：
4. 若是，则忽略
5. 若不是，则将该点填充内部颜色，同时将其入栈
6. 在栈非空时，转到2
7. 栈为空时停止算法

优点：递归执行，算法简单
缺点：效率不高：每个像素都引起递归，且存在很多像素重复入栈的情况（已经在栈中了，但后面还入栈了），进出栈耗时太高

因此对其进行以下优化：
## 5.5 扫描线种子填充

为了减少重复出入栈的情况，我们限定遍历的区间即可
1. 从区域内选取任意一个像素点作为种子入栈
2. 从栈中取出栈顶种子点
3. 沿着扫描线，以对种子像素开始的水平左右侧的所有像素进行填充，直到遇到边界像素
4. 整个填充范围的最左像素位置记为xl，最右像素记为xr，获得填充区间
5. 在填充区间内，检查与当前扫描线相邻的上下两条扫描线的像素是否全部被填充或是边界，如果存在非边界像素，取最靠左的那个像素作为种子像素入栈
6. 在栈非空时，转到2
7. 栈为空时停止算法

## 5.6 线宽显示

### 5.6.1 线刷

即在单一直线附近构造一个多边形模板，在其中进行填充

**直线线宽**
对于斜率在-1到1之间的直线，在其两条端点处上下对称地延伸竖直直线，两条直线对应端点连线斜率和原直线必然相同，对于所构造的平行四边形填充直线颜色
对于斜率大于1或小于-1的直线，延伸水平直线，其他相同

缺点：直线相交处存在缺口，不自然，线宽为偶数时无法确定中心，可以通过添加线帽和

具体实现方法采用区域填充：首先确定扫描线与直线的相交范围（左右端点）存在表中，然后根据刷子的线型更新表中原端点数据，得到各个角点数据，使用直线段连接后，利用多边形填充算法填充

### 5.6.2 图案填充

在多边形填充时采用固定图案，而非固定颜色，可以使用二进制位记录整个大的图案，然后填充时将相应位置的图案的像素值赋给像素即可

# C6. 图形裁剪

点的裁剪不难，根据第五章判断点在多边形内的算法得到所有在多边形内的点即可

## 6.1 二维线段裁剪

基本概念是对于裁剪窗口（不一定是矩形）中的图形部分进行保留，其他窗口外的部分进行删除
### 6.1.1 Cohen-Sutherland线段裁剪

将以窗口的四条边及其延长线所分割出来的九个区域进行特殊的二进制编码，线段两个端点在哪个区域就拥有一个相应的二进制编码，根据线段端点的编码，可以快速判断出那些完全不可见和完全可见的线段部分，通过与边界求交，反复划分线段，直到找到完全可见的部分，就是所有需要显示在窗口内的子线段了

具体来说，我们设窗口上边界的y坐标为wyt，下边界的y坐标为wyd，左边界的x坐标为wxl，右边界的x坐标为wxr
同时，编码的格式为$D_3D_2D_1D_0$，端点坐标为$(x,y)$：
$$ \begin{align}
1.& 若x<wxl,则D_0=1,否则D_0=0\\
2.& 若x>wxr,则D_1=1,否则D_1=0\\
3.& 若y<wyb,则D_2=1,否则D_2=0\\
4.& 若y>wyt,则D_3=1,否则D_3=0
\end{align}$$
注意，类似于x=wxl的边界情况，取的也是0，所以窗口及其边界上的点都是0000编码

对于（端点不在窗口边界上）的子线段来说，有以下规律：
$$\begin{align}
设&一条线段的两端点编码为RC_1和RC_2，则有：\\
1.& 若RC_1 | RC_2 = 0,则线段完全可见，简取\\
2.& 若RC_1 \& RC_2 \neq 0,则线段完全不可见，简弃
\end{align}$$
注意，由于之后会求线段与窗口边界的交点，交点与端点又形成子线段，此时子线段是不满足这个规律的，因为窗口边界上的点的编码为0000，它和任何点求与都是0000，但显然存在完全在窗口外且其中一个端点在窗口边界上的完全不可见线段
后面我们判断这种简弃线段用的并不是该规律

因此，算法步骤为：
1. 对待裁剪线段的端点求出其区域码RC1和RC2，进行上述判断，若属于其中一种情况，则直接进行简取或简弃
2. 若非其中任意一种情况，则求线段与边界的交点（通过判断编码对应位置是否为1，得到应该求交的边，对这些边求交，然后将交点按xy坐标排序）
3. 在交点处将线段进行划分，必存在完全在窗口在外面的简弃线段，舍弃即可

优点：简单，对于简取和简弃线段的判断快速
缺点，需要求交点

### 6.1.2 中点分割裁剪

算法步骤依然采用编码的思想：
1. 输入端点坐标和窗口边界坐标，进行端点区域码计算
2. 若区域码情况属于简取或简弃情况，进行简取或简弃
3. 若不属于，则求直线段的中点，将生成的两条子线段入栈
4. 每次从栈顶取出一个线段，计算区域码，判断是否为简取或简弃情况
5. 若属于，则进行简取或简弃
6. 若不属于，则仍然求中点，入栈，进入4步骤
7. 在栈非空时进行该步骤
8. 当栈为空时，合并保留的直线段端点，得到最终逼近的点

缺点：效率不高
下面的算法对这个过程进行了优化
### 6.1.3 Nicholl-Lee-Nicholl裁剪算法

该算法在求交之前将整体区域划分为更小的子区域来减少求交运算
具体来说，对于线段的其中一个端点，将其与窗口的各个顶点连接并引多条射线，对于矩形窗口，这样就能将整个空间划分为四个部分，然后判断另外一个端点所在的部分，这样一来就可以确认出线段与之相交的两条边是什么了，对它们求交即可

### 6.1.4 Liang-Barsky直线裁剪

该算法中，线段裁剪的本质是在线段端点+线段延长线与窗口边界及其延长线的交点集合中，将其分为上下两种集合，分别找出另一集合中最靠近该集合的点，其组成的线段就是整个线段中完全可见的部分。

将被裁剪线段视为有方向的，方向为从左到右，从下到上，根据线段的方向，我们可以将窗口的四条边（及其延长线）划分为入边和出边两类：入边即线段从外往内穿过的两条边，出边即线段从内往外穿过的两条边。
对于上集合，所构成它的点就是线段与出边的两个交点加上线段靠右靠上的那个端点；对于下集合则是线段与入边的两个交点加上靠左靠下的端点。

因此我们在数学上需要能找到区分出入边交点以及求出它们的方法
假设需要裁剪的线段端点为$P_1(x_1,y_1)$和$P_2(x_2,y_2)$，我们以P1作为起点
使用直线的参数方程：
$$\begin{cases}
x=x_1+u(x_2-x_1)\\
y=y_1+u(y_2-y_1)\\
0\leq u\leq 1
\end{cases}$$
来表示直线，可以看到，从P1到P2（靠近起点P1方向到靠近终点P2方向）的过程中，u不断增加，由于规定在线段上，所以这里u取值在0到1，若取值在负无穷到正无穷，则是代表点从靠近P1的方向到靠近P2的方向移动了
有了这样的单调关系，我们可以发现参数u和点的坐标是一一对应的，并且u值和点靠近P1还是P2有一致的关系：u值越小，点越靠近P1，u值越大，点越靠近P2

因此可以将求点问题转化为求u问题，下集合中最靠近P2的点的u值U1和上集合中最靠近P1的点的u值U2分别是
$$ U_1=\max(0, u_{出边1}, u_{出边2}),U_2=\min(1,u_{入边1},u_{入边2})$$
0和1代表两个端点P1和P2

为了判断入边和出边，我们设窗口上边界的y坐标为wyt，下边界的y坐标为wyd，左边界的x坐标为wxl，右边界的x坐标为wxr，则：
$$ \begin{cases}
若\Delta x>0\Rightarrow x=wxl为入边，x=wxr为出边\\
若\Delta x<0\Rightarrow x=wxr为入边，x=wxl为出边\\
若\Delta y>0\Rightarrow y=wyb为入边，y=wyt为出边\\
若\Delta y<0\Rightarrow y=wyt为入边，y=wyb为出边\\
\end{cases}$$
为了求出与边界的交点的u值，将对应值代入参数方程：
$$\begin{cases}
x_1+u_1(x_2-x_1)=wxl\\
x_1+u_2(x_2-x_1)=wxr\\
y_1+u_3(y_2-y_1)=wyb\\
y_1+u_4(y_2-y_1)=wyt
\end{cases}\Rightarrow \begin{cases}
u_1(x_1-x_2)=x_1-wxl\\
u_2(x_2-x_1)=wxr-x_1\\
u_3(y_1-y_2)=y_1-wyb\\
u_4(y_2-y_1)=wyt-y_1
\end{cases}$$
这样解出的u1234就是对应交点的u值了

更简单的形式，将ui乘的式子设为pi，等号右边的式子设为qi，就可以写为$u_i=q_i/p_i$的形式了

根据判断，只要$p_i<0$，就是入边，$p_i>0$，则为出边
这样我们就可以求出
$$ U_1=\max(0, u_{出边1}, u_{出边2}),U_2=\min(1,u_{入边1},u_{入边2})$$
了
对于pi=0的情况：
- 若qi<0，则完全不可见，整个线段被舍去
- 若qi>=0，则：
	- 若U1 > U2，则完全不可见，舍去
	- 若U1 <= U2，则部分可见，需要求交点保持可见部分

将U1和U2求出并代入方程即可得到可见部分的两个端点了

### 6.1.5 Cyrus-Beck直线裁剪

将梁的算法从矩形拓展到任意凸多边形窗口
考虑线段P1P2和凸多边形R，可知它们至多有两个交点
设A是凸多边形边界上的任意一点，N是多边形在这一点处对应的内法向量

依然使用参数方程P(t)=t(P2-P1)+P1表示线段，则A到被裁线段上任意一点P(t)的点积存在三种可能的情况：
- N·(P(t)-A)<0：P(t)在多边形外侧
- N·(P(t)-A)=0：P(t)在多边形边及其延长线上
- N·(P(t)-A)>0：P(t)在多边形内侧

因此，P(t)点在多边形内的充要条件是：**对凸多边形上任意一点A及其内法向量N，都有N·(P(t)-A)>=0**

在此思想上，我们在凸多边形R的M条边上**每条边各取一个点Ai**，理论上需要求出所有的均满足Ni·(P(t)-Ai)>=0的t值，但是我们可以进行优化，类似于梁的算法，分为下限组和上限组，求最值以获得可见线段的两个端点

- 下限组：若Ni·(P(t)-Ai)>0，则ti应归入下限组
- 上限组：若Ni·(P(t)-Ai)<0，则ti应归入上限组
- 若Ni·(P(t)-Ai)=0，则无交点
由于$t=-\frac{N\cdot (P_1-A)}{N\cdot (P2-P1)}$，把Ni和Ai代入即可求得ti并根据上述规则分组

那么两个端点的参数为：
$$ \begin{align}
t_l&=max({0, max({t_i:N_i·(P(t_i)-A_i)>0(下限组))}})\\
t_h&=min({1, min({t_i:N_i·(P(t_i)-A_i)<0(上限组)})})\\
\end{align}$$
且只有在$t_l<t_h$时是可见线段的参数，反之完全不可见，简弃

## 6.2 二维多边形裁剪

### 6.2.1 单边裁剪算法：SH多边形裁剪

该算法的基本思想是每次用**窗口的一条边**对多边形进行裁剪，其将待裁剪多边形依次与裁剪窗口的每一条边进行“过筛”。每过一条边，就把当前顶点序列重新过滤成一个新的顶点序列；最终经过全部窗口边后，保留下来的顶点就是裁剪后的多边形。由于每次只处理一条边，算法实现简单、效率稳定，但窗口必须是凸多边形。

具体来说，其算法流程为：

1. 首先把待裁多边形顶点按顺时针／逆时针顺序存入列表 inputList。

2. 依次处理窗口的每条边：

新建输出表outputList

每次取inputList中的两个顶点(S, P)，其中 S 是前一个顶点，P 是当前顶点，循环遍历，根据点在窗口内外的情况保存点至outputList：
（注意当前处理点是P，而不是S，因此只有P或交点I可能被保存，S是已经被处理或即将处理的点了）
1. 若P 在内，S 在内 → 保存 P。

2. 若P 在内，S 在外 → 先计算交点 I，再保存 I、P。

3. 若P 在外，S 在内 → 仅保存交点 I。

4. 若P 在外，S 在外 → 不保存任何点。

5. 使用outputList代替inputList，继续下一条窗口边

6. 若inputList为空或四条边均已被遍历，结束，inputList即为裁剪所得的多边形

该算法的缺点：
只适用于凸多边形，对于凹多边形，可能会出现多余的边

### 6.2.2 双边裁剪算法：WA多边形裁剪

双边裁剪算法中，设裁剪窗口为Pw，被裁多边形为Ps，它从Ps的任意一个顶点（一般选择在窗口外的点）按照**顺时针**跟踪Ps的每一条边，当Ps与Pw相交时（实交点，不是延长线），按照以下规则处理：
1. 若该边由不可见侧进入可见侧，则输出可见直线段（交点-顶点），转入第3步
2. 若是由可见侧进入不可见侧，则：
	首先输出可见直线段
	从当前交点开始，不沿着Ps了，而是沿着Pw窗口的边界，按照**顺时针**裁剪窗口，即，取窗口Pw的边而不是Ps的边：首先找到Ps和Pw**最靠近当前交点的那个交点（沿着窗口的顺时针方向找）**，此时输出当前交点与下一交点之间沿着窗口多边形Pw的边界，这样就能和可见直线段形成闭合的多边形了。然后再转回当前交点以及Ps方向，继续处理Ps的每条边
3. 处理完Ps的每条边，回到起点后，结束

这个方法利用了窗口和被裁多边形的边界来完成多边形的裁剪，因为结果区域同时具有两者的边界

对于裁剪窗口是凹多边形或带有内环的多边形，使用下面的内裁剪形式：
内裁剪实现步骤：
1. 建立两个顶点表：窗口多边形和被裁多边形的顶点表，顶点表初始时存储了各自的顶点
2. 求窗口和被裁多边形的所有交点，按顺序插入两个顶点表中（也就是，在已有的顶点之间按顺序插入交点，两个多边形表中插入的交点一样）
3. 进行裁剪：若存在没有被跟踪过的交点，进行下面的步骤：
	1. 建立裁剪结果多边形的顶点表，用于储存结果
	2. 选取任意没有跟踪过的交点为起始点，将其存储进结果顶点表
	3. 若是入点（不可见到可见侧），跟踪窗口多边形的边界；反之，跟踪裁剪多边形边界，跟踪顺序都是顺时针。如果跟踪完生成了闭合的图形（回到遍历过的点），就从最后一次跟着的点开始，继续沿着裁剪多边形追踪
		举个例子：
		被裁多边形：V1 V1' V2 V3 V3' V4 V5
		窗口多边形：W1 W2 W3 W4 V5' V4' V3' V1' W1
		其中带撇的为交点，V3' 为出点
		那么跟踪过程假设从V1'开始，首先跟着被裁多边形序列：V1' V2 V3 V3' 
		然后V3‘检测为出点，在窗口多边形序列中找到V3'，跟踪：V3' V1'
		检测到V1'被跟踪过，形成了闭合多边形，停止
		然后在被裁多边形序列中找到出点V3' 的后一个点V4，沿着该序列继续跟踪
	4. 在跟踪过程中，每遇到一个顶点或交点就将其存储进多边形的顶点表中，直到遇到新的交点

这样的过程适用于所有窗口情况

存在一些特殊情况要特判：
- 与裁剪多边形的边重合的窗口多边形的边，不参与求交点，认为无交点
- 对于顶点落在裁剪多边形的边上的窗口多边形的边，若这条边在窗口内侧，将其算作交点，若在外侧，则不算交点


## 6.3 字符裁剪

可以分为
- 按字符串精度裁剪：字符串有部分在外面就删掉整个字符串；
- 字符精度裁剪：只裁剪外侧的字符，字符一部分落在外面也要删掉整个字符
- 笔画和像素精度裁剪，对于笔画，将其分解为直线段对窗口作裁剪；对于点阵字符，使用点裁剪；对于矢量字符，使用线裁剪

# C7. 图形几何变换

## 7.1 二维图形的变换

### 1. 比例变换矩阵

$$ \begin{bmatrix}
x'\\
y'\\
\end{bmatrix} = \begin{bmatrix}
S_x & 0\\
0 & S_y\\
\end{bmatrix}\begin{bmatrix}
x\\
y\\
\end{bmatrix}$$
其中Sx为x方向上的比例变换系数，Sy为y方向上的比例系数


### 2. 旋转变换矩阵
$$ \begin{bmatrix}
x'\\
y'\\
\end{bmatrix} = \begin{bmatrix}
\cos\theta & -\sin\theta \\
\sin\theta & \cos\theta \\
\end{bmatrix}\begin{bmatrix}
x\\
y\\
\end{bmatrix}
$$
逆时针时，$\theta$取正数，顺时针时取负数

### 3. 对称变换矩阵
对角元素为+1或-1的对角矩阵，对应位置代表对称变换时的系数
下面就是沿着x轴对称：$\begin{cases}x'=x\\ y'=-y\end{cases}$的矩阵：
$$ \begin{bmatrix}
x'\\
y'\\
\end{bmatrix} = \begin{bmatrix}
1 & 0\\
0 & -1\\
\end{bmatrix}\begin{bmatrix}
x\\
y\\
\end{bmatrix}$$

### 4. 错切变换矩阵
错切变换就是形如$\begin{cases}x'=x+cy\\ y'=bx+y\end{cases}$的变换，其中c为x方向的错切因子，b为y方向的错切因子
写成矩阵形式：
$$ \begin{bmatrix}
x'\\
y'\\
\end{bmatrix} = \begin{bmatrix}
1 & c\\
b & 1\\
\end{bmatrix}\begin{bmatrix}
x\\
y\\
\end{bmatrix}$$

### 5. 平移变换与齐次坐标
平移变换$\begin{cases}x'=x+T_x\\y'=y+T_y\end{cases}$需要引入常数$T_x$和$T_y$，显然对于$2\times 2$的矩阵来说无法实现，因此我们考虑为原来的2维向量（n维向量）引入一个新的维度，其值为一个常数，n->n+1，就是齐次坐标了：
$$ \begin{bmatrix}
x\\
y\\
\end{bmatrix}\rightarrow \begin{bmatrix}
h\cdot x\\
h\cdot y\\
h\end{bmatrix}$$
显然随着h的不同，这样的坐标会有多个。当h取1时，称其为**规范化齐次坐标**

因此平移变换的矩阵可表示为：
$$ \begin{bmatrix}
x'\\
y'\\
1
\end{bmatrix} = \begin{bmatrix}
1 & 0 & T_x\\
0 & 1 & T_y\\
0 & 0 & 1
\end{bmatrix}\begin{bmatrix}
x\\
y\\
1
\end{bmatrix}$$
或者：
$$ \begin{bmatrix}
x' & y' & 1\\
\end{bmatrix} = \begin{bmatrix}
x & y & 1\\
\end{bmatrix}\begin{bmatrix}
1 & 0 & 0\\
0 & 1 & 0\\
T_x & T_y & 1
\end{bmatrix}$$


使用齐次坐标之后，将整个变换矩阵拓展如下：
$$
\begin{align}
&\begin{bmatrix}
x' & y' & 1\\
\end{bmatrix} = \begin{bmatrix}
x & y & 1\\
\end{bmatrix}
\begin{bmatrix}
a & b & |\quad p\\
c & d & |\quad q\\
\hline
l & m & |\quad s\\
\end{bmatrix}\\
其中:\\
&1. abcd部分的元素控制图形的比例、旋转、对称、错切等变换\\
&2. lm部分的元素控制对图形的平移变换\\
&3. pq部分元素控制对图形的投影变换（后一章内容）\\
&4. s元素控制对图形的整体比例变换

\end{align}
$$
因为这里我们采用了**行向量形式**，对之前提到的旋转、比例、对称、错切变换矩阵的形式也要相应稍微改动一下：

#### 1. 齐次旋转

$$
\begin{bmatrix}
x' & y' & 1\\
\end{bmatrix} = \begin{bmatrix}
x & y & 1\\
\end{bmatrix}
\begin{bmatrix}
\cos\theta& \sin\theta & 0\\
-\sin\theta & \cos\theta & 0\\
0 & 0 & 1\\
\end{bmatrix}\\
$$
实际上就是把左上角采用了列向量表示时的2\*2矩阵转置后的矩阵而已
这里$\theta$取正为逆时针，取负为顺时针旋转

#### 2. 齐次比例
$$
\begin{bmatrix}
x' & y' & 1\\
\end{bmatrix} = \begin{bmatrix}
x & y & 1\\
\end{bmatrix}
\begin{bmatrix}
S_x & 0 & 0\\
0 & S_y & 0\\
0 & 0 & 1\\
\end{bmatrix}\\
$$
这里由于左上角是对角2\*2矩阵，转置后没有任何区别

#### 3. 齐次对称&错切
$$
\begin{bmatrix}
x' & y' & 1\\
\end{bmatrix} = \begin{bmatrix}
x & y & 1\\
\end{bmatrix}
\begin{bmatrix}
a & b & 0\\
c & d & 0\\
0 & 0 & 1\\
\end{bmatrix} =\begin{bmatrix}
ax+cy & bx+dy & 1\\
\end{bmatrix}
$$
根据对称$\begin{cases}x'=+-x\\ y'=+-y\end{cases}$和错切$\begin{cases}x'=x+cy\\ y'=bx+y\end{cases}$的定义来设置系数即可
特别注意错切变换的系数：a和d都为1，c和b取任何数（包括0）
- 若b=0，代表错切变换沿着x轴方向，c>0为x正，c<0为x负
- 反之，若c=0，则错切变换沿着y轴方向
- 都不为0则沿着两轴变换

## 7.2 二维复合变换

实际上就是多个变换矩阵相乘。由于矩阵乘法不满足交换律，但满足结合律，因此矩阵相乘的顺序决定了复合变换的结果
具体来说，无论是行向量形式还是列向量形式，靠近被变换向量的矩阵变换先进行，远离的矩阵后进行变换

### 7.2.1 参考点不为原点的变换
之前的变换矩阵，包括旋转、比例等变换，都是基于“参考点为原点”而产生的。
对于相对参考点不在原点的情况，往往需要进行平移到原点-针对原点的几何变换-反平移的方式进行
例如，相对点$(x_r, y_r)$进行逆时针旋转$\theta$角度的变换如下：
$$
\begin{bmatrix}
x' & y' & 1\\
\end{bmatrix} = \begin{bmatrix}
x & y & 1\\
\end{bmatrix}
\begin{bmatrix}
1& 0 & 0\\
0 & 1 & 0\\
-x_r & -y_r & 1\\
\end{bmatrix}\\
\begin{bmatrix}
\cos\theta& \sin\theta & 0\\
-\sin\theta & \cos\theta & 0\\
0 & 0 & 1\\
\end{bmatrix}\begin{bmatrix}
1& 0 & 0\\
0 & 1 & 0\\
x_r & y_r & 1\\
\end{bmatrix}\\
$$
第一次变换将相对于点的坐标系向原点方向移动，因此具有负号；随后使用基于原点的旋转矩阵，最后向原相对点进行平移，符号为正


### 7.2.2 相对于其他方向的变换
对于“基于二维坐标轴x和y”的变换矩阵，例如对称矩阵，有时候我们的对称轴并不是坐标轴，而是任意给出的一条直线，此时需要将坐标轴进行旋转或平移到对应直线，然后再进行对应坐标轴的对称变换，最后需要反变换回原坐标系

以将图形沿着y=bx+a直线进行对称变换为例，其截距为a，采用**行向量**形式表示
1. 首先将直线平移到过原点处$T_1=\begin{bmatrix} 1 & 0 & 0\\0 & 1 & 0\\ 0 & -a & 1\end{bmatrix}$
2. 根据斜率b得到**直线与x轴之间的夹角$\theta$**，**顺时针**旋转$\theta$角度：$T_2=\begin{bmatrix}\cos\theta & -\sin\theta & 0\\ \sin\theta & \cos\theta & 0\\ 0 & 0 & 1\end{bmatrix}$
3. 进行关于x轴的反射变换$T_3=\begin{bmatrix} 1& 0& 0\\0 & -1 & 0\\ 0& 0 & 1\end{bmatrix}$
4. 逆时针旋转$\theta$度，复原角度：$T_4=\begin{bmatrix}\cos\theta & \sin\theta & 0\\ -\sin\theta & \cos\theta & 0\\ 0 & 0 & 1\end{bmatrix}$
5. 平移回原位置$T_5=\begin{bmatrix} 1 & 0 & 0\\0 & 1 & 0\\ 0 & a & 1\end{bmatrix}$
6. 总的变换为$\begin{bmatrix}x' & y' & 1\\\end{bmatrix} = \begin{bmatrix}x & y & 1\\\end{bmatrix} T_1T_2T_3T_4T_5$

类似的还有错切变换，沿着xy轴的错切变换改为沿着任意两条互相垂直直线的错切变换，也是先平移后旋转再变换，然后逆变换

## 7.3 三维图形的变换
### 1. 三维齐次坐标

类似于2维齐次坐标，在第四维度增加常数，常数为1的齐次坐标为规范化齐次坐标
拓展后的齐次坐标及变换矩阵如下：
$$
\begin{bmatrix}
x' & y' & z'& 1\\
\end{bmatrix} = \begin{bmatrix}
x & y &z& 1\\
\end{bmatrix}
\begin{bmatrix}
a & b & c&|\quad p\\
d & e & f&|\quad q\\
h & i& j&|\quad r\\
\hline
l & m &n& |\quad s\\
\end{bmatrix}\\
$$
同样地：
- 左上角区域负责比例、对称、旋转、错切变换
- 右上角区域负责进行投影变换（下一章内容）
- 左下角区域负责平移变换
- 右下角区域负责整体比例变换（更改第四维度的常数）

### 2. 三维比例变换

最后一个元素为1的对角矩阵，每个元素表示向各坐标轴变换的比例系数：
$$
\begin{bmatrix}
x' & y' & z'& 1\\
\end{bmatrix} = \begin{bmatrix}
x & y &z& 1\\
\end{bmatrix}
\begin{bmatrix}
S_x & 0 & 0&0\\
0 & S_y & 0&0\\
0 & 0& S_z&0\\
0 & 0 &0& 1\\
\end{bmatrix}\\
$$
无论是行向量还是列向量形式都是这样的矩阵

### 3. 三维旋转

首先需要直到如何确定旋转的正方向？
使用右手定则，将右手拇指对准沿着旋转的轴，其他手指握环，环所对应的旋转方向就是正方向
因此，可以发现，逆时针为正方向，角度取正；顺时针为负方向，角度取负

绕什么轴变换，矩阵对角位置对应的元素就为1，这是共同的
#### 1. 绕z轴旋转和绕x轴旋转

这两种旋转的矩阵具有类似的形式，很好记忆

绕x轴：
$$
\begin{bmatrix}
x' & y' & z'& 1\\
\end{bmatrix} = \begin{bmatrix}
x & y &z& 1\\
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0&0\\
0 & \cos\theta & \sin\theta&0\\
0 & -\sin\theta& \cos\theta&0\\
0 & 0 &0& 1\\
\end{bmatrix}\\
$$
绕z轴：
$$
\begin{bmatrix}
x' & y' & z'& 1\\
\end{bmatrix} = \begin{bmatrix}
x & y &z& 1\\
\end{bmatrix}
\begin{bmatrix}
\cos\theta & \sin\theta & 0&0\\
-\sin\theta & \cos\theta & 0&0\\
0 & 0& 1&0\\
0 & 0 &0& 1\\
\end{bmatrix}\\
$$
可以发现，实际上就是将对应位置元素置为1，然后将二维旋转矩阵搬到其他两个坐标对应的位置

但是y轴的形式就稍微有些不同，因为它隔开了两个坐标
#### 2. 绕y轴旋转

$$
\begin{bmatrix}
x' & y' & z'& 1\\
\end{bmatrix} = \begin{bmatrix}
x & y &z& 1\\
\end{bmatrix}
\begin{bmatrix}
\cos\theta & 0 & -\sin\theta&0\\
0 & 1 & 0&0\\
\sin\theta & 0& \cos\theta&0\\
0 & 0 &0& 1\\
\end{bmatrix}\\
$$
可以看到，不仅仅是简单地把二维旋转矩阵拆到另外两个坐标上，还将其进行了转置

### 4. 三维对称&错切变换

实际上就是对矩阵左上角的元素进行赋值：
$$
\begin{bmatrix}
x' & y' & z'& 1\\
\end{bmatrix} = \begin{bmatrix}
x & y &z& 1\\
\end{bmatrix}
\begin{bmatrix}
a & b & c&0\\
d & e & f&0\\
g & h& i&0\\
0 & 0 &0& 1\\
\end{bmatrix}\\
$$
对称变换：除了对角线上的元素是正负1以外，其他元素均为0，根据沿着该轴对称的需求，将对应元素设置为-1即可，例如沿着y轴的：$\begin{bmatrix}1 & 0 & 0&0\\0 & -1 & 0&0\\0 & 0& 1&0\\0 & 0 &0& 1\\\end{bmatrix}$

错切变换：对角元素都是1，沿着哪条轴进行错切，对应列的其他两个元素就不为0，分别是另外两轴各自的错切系数
例如沿着y轴错切$\begin{bmatrix}1 & a & 0&0\\0 & 1 & 0&0\\0 & b& 1&0\\0 & 0 &0& 1\\\end{bmatrix}$和沿着x轴错切$\begin{bmatrix}1 & 0 & 0&0\\ c & 1 & 0&0\\ d & 0& 1&0\\0 & 0 &0& 1\\\end{bmatrix}$

## 7.4 三维复合变换

单个变换矩阵的叠加，离向量近的矩阵先进行变换，通过简单变换的组合可以得到所有对于变换的需求

### 1. 相对于任意非原点参考点的三维变换

思路：
1. 将参考点移到原点中，作减法
2. 进行基于原点的变换矩阵
3. 反平移，作加法

### 2. 绕任意轴的三维旋转变换

主要思想在于将旋转轴（三维直线）旋转到z轴位置，然后按照z轴旋转的变换矩阵进行变换，最后旋转回去

对于三维直线，由于其维度增加了，因此不能仅仅通过一个角度的旋转使其与z轴重合，而是需要通过**首先将其移动到过原点，接着投影到一个平面内，然后再沿着垂直于这个平面的轴进行旋转，使得其与其中一条坐标轴重合，然后再进行针对于该坐标轴的旋转变换，最后逆变换回去即可**
注意投影到的平面需要有我们选定的那个轴
例如：
设直线在三个轴上的截距为$x_a, y_a, z_a$，在xoy平面上的投影与x轴的夹角为$\alpha$，在xoz平面上的投影与z轴夹角为$\beta$，需求中将图形沿着该直线轴旋转角度为$\theta$
1. 平移变换，将直线平移至原点：$T_1=\begin{bmatrix} 1 & 0 & 0 & 0\\0 & 1 & 0 & 0\\ 0 & 0 & 1 & 0 \\ -x_a & -y_a & -z_a & 1\end{bmatrix}$
2. 绕x轴逆时针旋转$\alpha$，使其落在xoz平面上：$T_2=\begin{bmatrix} 1 & 0 & 0 & 0\\0 & \cos\alpha & \sin\alpha & 0\\ 0 & -\sin\alpha & \cos\alpha & 0 \\ 0 & 0 & 0 & 1\end{bmatrix}$
3. 绕y轴逆时针旋转$\beta$，使其与z轴重合：$T_3=\begin{bmatrix} \cos\beta & 0 & -\sin\beta & 0\\ 0 & 1 & 0 & 0\\ \sin\beta & 0 & \cos\beta & 0 \\ 0 & 0 & 0 & 1\end{bmatrix}$
4. 然后绕z轴旋转$\theta$角度即可：$T_4=\begin{bmatrix} \cos\theta & \sin\theta & 0 & 0\\-\sin\theta & \cos\theta & 0 & 0\\ 0 & 0 & 1 & 0 \\0 & 0 & 0 & 1\end{bmatrix}$
5. 逆变换过程略，将T3和T4的角度反过来，然后T1的平移量取相反数变为正即可

所以此时可能需要经过好几次旋转，才能使其与坐标轴重合

# C8. 图形投影

也是图形变换的一种，在计算机屏幕上，往往需要显示三维的物体，这实际上就是把三维物体投影到二维投影平面的过程

其中，投影又分为$\begin{cases}透视投影：投影中心到投影面之间的距离是有限的\\ 平行投影：投影中心到投影面的距离是无限的\end{cases}$

## 8.1 三维平行投影变换

平行投影又可分为两类$\begin{cases} 正投影：投影方向和投影平面法向量共线且相反（正射向平面）\\斜投影：投影方向与投影平面法向量的反方向之间具有一定夹角\end{cases}$

### 8.1.1 正投影

正投影图具有三视图和正轴侧图两类
- 三视图：投影面与某一坐标轴垂直时，得到的投影就是三视图
- 正轴侧图：投影面与三个坐标轴都不垂直，都有交点，此时得到的投影是正轴侧图

#### 三视图
包括以下三种：
- 主视图：投影平面是xoz平面
- 俯视图：xoy平面
- 侧视图：yoz平面

适用于物体的一个坐标面平行于投影平面的情况，这样的投影能够反映形体的实际尺寸，但是只有一个面的投影，单一三视图无法完全形象地表示出形体的三维特征，往往需要把三个三视图放在一起展示，综合得到物体形状

计算方法：
1. 首先确定组成三维形体的各个顶点的位置坐标，之后需要对它们进行矩阵变换
2. 把顶点坐标拓展为齐次坐标
3. 求出所作变换的矩阵
4. 运算求得各个顶点的变换后点，此时会获得多个二维的投影点
5. 通过二维投影点绘制三视图

在矩阵表示中，向哪个坐标平面投影，本质上是把三维形体中的每个点的，**垂直于该坐标平面的那条坐标轴，所对应的坐标归0**，因此变换矩阵就是一个对角矩阵，对角元素中，除了该坐标轴所对应的元素为0之外，其余元素都为1，例如向xoz平面的投影矩阵为$T_1=\begin{bmatrix} 1 & 0 & 0 & 0\\0 & 0 & 0 & 0\\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1\end{bmatrix}$
##### 主视图变换矩阵
将三维物体对xoz平面作垂直投影，$T_1=\begin{bmatrix} 0 & 0 & 0 & 0\\0 & 1 & 0 & 0\\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1\end{bmatrix}$
**我们选择在主视图所在的xoz平面内显示所有三视图**，因此不需要其他的变换了


##### 俯视图变换矩阵
也就是将三维物体对xoy平面作垂直投影，$T_1=\begin{bmatrix} 1 & 0 & 0 & 0\\0 & 1 & 0 & 0\\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1\end{bmatrix}$
但是为了将三视图放置在同一个平面内，我们需要对生成的二维图形进行旋转

我们将**俯视图显示在主视图的正下方**
因此对于投影到xoy的平面，二维图形需要沿着x**顺时针**旋转90度才可以放置在主视图的正下方，对应的旋转矩阵$T_2=\begin{bmatrix} 1 & 0 & 0 & 0\\0 & \cos(-90\degree) & \sin(-90\degree) & 0\\ 0 & -\sin(90\degree) & \cos(-90\degree) & 0 \\ 0 & 0 & 0 & 1\end{bmatrix}=\begin{bmatrix} 1 & 0 & 0 & 0\\0 & 0 & -1 & 0\\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1\end{bmatrix}$

最后，为了良好的显示效果，我们对其沿着z轴负方向偏移一定距离$z_0$，使得两张三视图分离开$T_3=\begin{bmatrix} 1 & 0 & 0 & 0\\0 & 1 & 0 & 0\\ 0 & 0 & 1 & 0 \\ 0 & 0 & -z_0 & 1\end{bmatrix}$

##### 侧视图变换矩阵
也就是将三维物体对yoz平面作垂直投影，$T_1=\begin{bmatrix} 0 & 0 & 0 & 0\\0 & 1 & 0 & 0\\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1\end{bmatrix}$
我们将**侧视图显示在主视图的左边**
因此，生成的图形需要沿着z轴**逆时针**旋转90度，$T_2=\begin{bmatrix} \cos(90\degree) & \sin(90\degree) & 0 & 0\\-\sin(90\degree) & \cos(90\degree) & 0 & 0\\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1\end{bmatrix}=\begin{bmatrix} 0 & 1 & 0 & 0\\-1 & 0 & 0 & 0\\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1\end{bmatrix}$

最后，为了良好的显示效果，我们对其沿着x轴负方向偏移一定距离$x_0$，使得两张三视图分离开$T_3=\begin{bmatrix} 1 & 0 & 0 & 0\\0 & 1 & 0 & 0\\ 0 & 0 & 1 & 0 \\ -x_0 & 0 & 0 & 1\end{bmatrix}$

#### 正轴测图

也就是投影平面不是坐标平面，而是任意平面时的二维投影图形
按照投影平面与三个坐标轴的截距（交点到原点的距离），可分为：
1. 正等测/等轴测：坐标平面的三个截距相等，代表向三个坐标轴的变形系数也相等
2. 正二侧：三个坐标轴其中的两个截距相等
3. 正三测：三个坐标轴的截距各不相同


对于正轴侧图的投影变换矩阵，其思想主要如下：
1. 首先将坐标系绕y轴顺时针旋转$\alpha$角度
2. 再绕x轴逆时针旋转$\beta$角度
3. 这样投影平面就与xoy平面重合了，针对xoy平面进行投影变换即可


正轴侧图的特点：可见多面，立体效果强，主轴XYZ方向可以测量距离(距离不被压缩)
##### 正等测
由于截距相同，我们可以通过投影几何的方式计算出其变换矩阵：


### 8.1.2 斜投影

斜轴测图：指的是将三维形体像一个单一的投影面作平行投影，但投影方向并不垂直于投影面的平面投影
分为：
1. 斜等测投影：投影平面与一坐标轴垂直，且投影线与投影平面成$45\degree$角
	这种情况下，**与投影平面垂直**的线段经过投影后**长度不变**

2. 斜二测投影：投影平面与一坐标轴垂直，且投影线与该轴成$\arctan(\frac{1}{2})$度角
	这种情况下，与投影屏幕垂直的线段经过投影后**长度变为原来的1/2**


变换矩阵为$T_=\begin{bmatrix} 1 & 0 & 0 & 0\\0 & 1 & 0 & 0\\ ctg\alpha \cos\beta & ctg\alpha \sin\beta & 0 & 0 \\ 0 & 0 & 0 & 1\end{bmatrix}$

- 斜等测图：$\alpha = 45\degree , ctg\alpha = 1$
- 斜二测图：$\alpha = arctg(2), ctg\alpha = 1/2$

## 8.2 三维透视投影变换

为了获得接近真实三维物体的视觉效果而在二维的纸或画布平面上绘图或渲染的方法，称为透视图

对于变换矩阵
$$
\begin{bmatrix}
x' & y' & z'& 1\\
\end{bmatrix} = \begin{bmatrix}
x & y &z& 1\\
\end{bmatrix}
\begin{bmatrix}
a & b & c&|\quad p\\
d & e & f&|\quad q\\
h & i& j&|\quad r\\
\hline
l & m &n& |\quad s\\
\end{bmatrix}\\
$$
其中pqr的部分可以用于产生透视投影变换

透视投影也叫中心投影，其特点在于：投影线均通过投影中心，投影中心相对于投影面确定的情况下，空间中的一个点在投影面上只存在唯一一个投影

- 物体的投影视图由计算投影线与观察平面的交点获得
- 平行于投影面的平行线，其投影线互相平行
- 透视投影生成真实感视图，但不保持比例一致

灭点：不平行于投影面的平行线之投影所汇聚到的一个点
主灭点：坐标轴方向的平行线在投影面上形成的灭点
n点透视有n个主灭点，n=1，2，3

### 1. 一点透视变换矩阵

只有一个主灭点，在
$$
\begin{bmatrix}
x' & y' & z'& 1\\
\end{bmatrix} = \begin{bmatrix}
x & y &z& 1\\
\end{bmatrix}
\begin{bmatrix}
a & b & c&|\quad p\\
d & e & f&|\quad q\\
h & i& j&|\quad r\\
\hline
l & m &n& |\quad s\\
\end{bmatrix}\\
$$
中我们先假设p=r=0。q不为0，此时有：
$$ 
\begin{bmatrix}
x' & y' & z'& 1\\
\end{bmatrix} = \begin{bmatrix}
x & y & z& qy+1\\
\end{bmatrix}=\begin{bmatrix}
\frac{x}{qy+1} & \frac{y}{qy+1} & \frac{z}{qy+1}& 1\\
\end{bmatrix}
$$
当y=0时，可以得到$\begin{bmatrix} x' & y' & z'& 1\\ \end{bmatrix} = \begin{bmatrix} x & 0 & z& 1\\ \end{bmatrix}$
即y=0平面上的点经过变换后没有变化，而$y\rightarrow \infty$时，得到$\begin{bmatrix} x' & y' & z'& 1\\ \end{bmatrix} \rightarrow \begin{bmatrix} 0 & 1/q & 0& 1\\ \end{bmatrix}$
所以有无穷远处**各平行于y轴的平行线**趋近于的点是$\begin{bmatrix} 0 & 1/q & 0& 1\\ \end{bmatrix}$，这就是主灭点

同理，当p=q=0而r不为0时，z轴上存在平行于z轴平行线的主灭点$\begin{bmatrix} 0 & 0 & 1/r& 1\\ \end{bmatrix}$，z=0平面上的点不变
当q=r=0而p不为0时，x轴上存在平行于x轴平行线的主灭点$\begin{bmatrix} 1/p & 0& 0& 1\\ \end{bmatrix}$

### 2. 多点透视变换矩阵

根据归纳，对于
$$
\begin{bmatrix}
x' & y' & z'& 1\\
\end{bmatrix} = \begin{bmatrix}
x & y &z& 1\\
\end{bmatrix}
\begin{bmatrix}
a & b & c&|\quad p\\
d & e & f&|\quad q\\
h & i& j&|\quad r\\
\hline
l & m &n& |\quad s\\
\end{bmatrix}\\
$$
中pqr有两个或三个非0量的情况，透视就是两点或三点透视了

例如，若p和r不为0而z为零，齐次化结果为
$$ 
\begin{bmatrix}
x' & y' & z'& 1\\
\end{bmatrix} = \begin{bmatrix}
x & y & z& px+rz+1\\
\end{bmatrix}=\begin{bmatrix}
\frac{x}{px+rz+1} & \frac{y}{px+rz+1} & \frac{z}{px+rz+1}& 1\\
\end{bmatrix}
$$
让$x\rightarrow \infty$，有$\begin{bmatrix} x' & y' & z'& 1\\ \end{bmatrix} \rightarrow \begin{bmatrix} 1/p & 0 & 0& 1\\ \end{bmatrix}$
让$z\rightarrow \infty$，有$\begin{bmatrix} x' & y' & z'& 1\\ \end{bmatrix} \rightarrow \begin{bmatrix} 0 & 0 & 1/r& 1\\ \end{bmatrix}$

同理，对于三点透视，出现的三个主灭点就是$\begin{bmatrix} 0 & 0 & 1/r& 1\\ \end{bmatrix}$、$\begin{bmatrix} 0 & 1/q &0 & 1\\ \end{bmatrix}$和$\begin{bmatrix} 1/p & 0 & 0& 1\\ \end{bmatrix}$


### 3. 生成透视投影的方法

设下面的例子中，投影平面在xoy面上，求投影就是求空间中任意一点经过

对于**一点透视**投影
除了上述透视变换矩阵之外，因为需要向画面投影，所以还需要乘上一个平行投影矩阵
例如，假设在z轴上的灭点为(0, 0, 1/d)，

则变换矩阵应为：
$$T_=\begin{bmatrix}
1 & 0 & 0 & 0\\0 & 1 & 0 & 0\\
0 & 0 & 1 & 1/d \\ 0 & 0 & 0 & 1\end{bmatrix}
\cdot 
\begin{bmatrix}
1 & 0 & 0 & 0\\0 & 1 & 0 & 0\\
0 & 0 & 0 & 0\\ 0 & 0 & 0 & 1\end{bmatrix}
$$
也就是把平面向xoy压缩
每个点乘上这样的矩阵即可

从变换矩阵可以看出透视投影具有的性质：
1. 透视缩小效应：三维物体透视投影的大小与物体距投影中心的距离成反比

对于**两点透视**投影
投影平面

# C9. 反走样

走样：使用离散量表示连续量时，由于采样频率等原因，引起的失真现象
反走样：消除走样现象的技术，也称图形保真

反走样最简单的方法：使用分辨率高的设备，但是代价高

另一种思路是，对于锯齿状边界，在边界附近掺入灰色像素，柔化尖锐的黑白变化，使得从远处观看时能看到更平滑的边界
在这种思想的启发下，我们可以假设拥有比现有屏幕分辨率更高的分辨率，在这样更多的划分格子内进行取样计算，对像素属性进行平均化以达到平滑效果

主要分为**过取样（后滤波）和区域取样（前滤波）** 两种方法

## 9.1 过取样

在高于当前设备显示分辨率的较高分辨率，使用点取样方法计算，对几个像素的属性进行平均以得到较低分辨率下的像素属性

### 1. 简单过取样

- 在xy方向上把分辨率都提高一倍，例如m\*n的屏幕分辨率（像素个数）变为2m\*2n
- 这样每个像素被转化成四个子像素，使用这样更小的像素格子对连续的原图像进行取样
- 对四个子像素的颜色值进行简单的平均值计算，将该平均值代替原像素的值即可

### 2. 重叠过取样

- 将m\*n分辨率的显示窗口提升为(2m+1)\*(2n+1)的分辨率
- 为了得到更好的效果，在对一个原像素进行着色时，不仅采样其子像素（更高分辨率下该像素被划分而成的更小像素）的值，还采样其附近的多个原像素的子像素值
- 其实也就是在像素周围开一个一定大小的矩形窗口，在窗口内的其他像素中进行采样

### 3. 加权模板过取样

为每个矩形窗口的像素位置赋一个权值，他代表在计算平均值时对应像素值参与计算时使用的权重，一般会让窗口中心或靠近中心的子像素具有更大的权值
这样通过对不同像素的贡献值区分，赋予不同灰度值，能够起到柔滑边缘等作用

## 9.2 区域取样

由于**像素实际上是一个矩形区域**，因此我们可以对像素计算面积
以直线为例，我们完全可以把直线看作一个矩形区域，该区域划分于像素格网上，有很多像素与这个区域相交，其中许多相交但不完全被包含

### 9.2.1 简单区域取样
此时，我们可以根据相交像素与区域相交部分占整个像素面积的大小，为其赋予不同的像素值，例如被区域完全包含的像素的值为1，只相交一半的像素值为1/2等等

面积可以通过几何的方式求交，这相当于使用了一个二维盒式滤波器对连续区域进行滤波

另一种简单的求面积方式是，将屏幕像素分割为更小的子像素，总共分为了n个子像素，计算这些子像素中的那些，中心点位于区域范围内的子像素个数m，那么相交区域占比值可近似为m/n
这样可以简化运算

通过这种方式，使得**像素值只与其和区域相交的面积占比有关，而与其所在区域位置无关**，所以相邻的两个像素可能会具有较大的灰度差，**主要缺点在于每个子像素的权值是一样的**

我们认为，靠近直线段中心更近的像素应该越亮

### 9.2.2 加权区域取样

使用覆盖像素的连续的加权函数（滤波函数）来确定像素的亮度，该函数是**定义在二维显示屏幕上的函数**，将其在**整个二维显示器图形**上进行积分，就可以得到具有一定体积的滤波器，定义整个图形上的积分体积为1
这样一来，在图形的部分区域上的积分就是整体滤波器的一个子体，体积在0到1之间，用这样的体积来表示像素的亮度

根据加权函数的不同，可以获得不同的亮度显示规则

特点：
- 接近理想直线的像素会被分配更多灰度值
- 相邻两个像素的滤波器相交，可以缩小直线上相邻像素的灰度值差

# C10. 图形消隐

在显示三维形体时，我们只能看到物体朝向我们的部分，需要将被遮挡的部分从显示中去除掉，这就是图形的消隐
消隐包括消除隐藏线和隐藏面，不仅与消隐对象有关，还与观察者的位置有关

消隐算法根据消除方法可分为：物体空间的消隐算法和图像空间的消隐算法，像空间消隐算法即以屏幕窗口内的每个像素为处理单元，确定在像素位置场景中的k个物体哪个离物体最近，使用物体的颜色显示像素

## 10.1 消除隐藏线

对造型系统有所要求：因为线和线之间是不会产生遮挡的，只有面和体可能对线产生遮挡，所以造型系统需要对面或体有储存多信息

平面对直线段的遮挡算法：
1. 若线段两端点以及视点在给定面的同侧，则线段在平面的前面，不被遮挡，结束算法
2. 若线段投影和平面投影的包围盒没有交点，那么线段也不被遮挡，结束
3. 求直线与无穷屏幕的交点，如果有交点且交点在线段内部，那么将线段分为两段，其中与视点同侧的线段可见，另外一段不一定，需要下一步判断；若没有交点，或交点在线段外部，也需要下一步判断
4. 求剩下的线段的投影和平面边界的投影的所有交点，根据交点在原直线参数方程的参数求出深度值z
5. 将线段依据交点分成若干段，按照z值对各段进行排序
6. 求出第一段子线段的中点，若中点在多边形的投影内，则该子线段被遮挡，反之不被遮挡；其他段不需要这么求，因为遮挡-可见是交替的，我们得到第一个的情况就按照可见-遮挡-可见-...的方式轮下去即可
7. 结束

## 10.2 消除隐藏面
### 1. 画家算法（物+像）

又称深度排序算法，该算法思想是绘画时总是先画远处的物体，再画近处的物体
因此，**在多边形之间不贯穿且没有循环遮挡时**，多边形离观察平面的深度优先级可以被完全确定，这时扫描转换就可按照优先级低到高的顺序进行
- 先把背景置为屏幕色
- 把物体的各个面按照其离视点的远近进行排序，放置在深度优先级表中
- 按照从远到近的顺序逐个绘制面

算法核心在于进行深度排序
1. 首先找出没有深度重叠的物体面，即zmax1 < zmin2这样的，可以直接判断它们的深度关系
2. 对于存在深度重叠的面，例如zmin1\< zmin2，深度范围区间有重叠的，首先剔除以下特例：
	1. 两物体在oxy平面上投影的包围盒不相交
	2. 投影本身不相交
	3. a在b之后，且a的各个顶点都在b远离视点的那一侧
3. 处理不能剔除的情况，此时需要将重叠部分进行分割，在交点处位置进行深度比较以判断前后位置
4. 对于循环重叠的情况，需要在相交的地方把多边形分割为子多边形，再进行判断

### 2. BSP树算法（物）

分割空间的时候，相对于视点，判断物体的每个表面是位于分割空间那条分割平面的前面还是后面，前面放在二叉树的左孩子处，后面则放在右孩子处，以此类推进行分割和建树，获得一个BSP树
最后从右至左遍历BSP树，进行扫描转化

### 3. Z-buffer算法（像）

z坐标值指的是沿着观察系统的z轴计算各个对象距离观察平面的深度值
在投影面上按照每一像素位置比较所有面的深度，找到最靠近坐标屏幕的面，其颜色值就是像素的颜色值

z缓存用于存储投影面上各个像素的深度值，而帧缓存用于存储投影面上各个像素的颜色

算法步骤：
1. 首先把z缓存和帧缓存中的所有单元初始化：深度缓存初始化为1，帧缓存初始化为背景色
2. 处理场景的每一个多边形，每次一个，计算多边形上每一点的深度值，若该点深度值小于深度缓存中已有的该点深度值，把帧缓存颜色置为该点颜色

特点：使用近物取代远物，形体在屏幕上的出现顺序不重要，实现简单，适合硬件

缺点：占用空间大，没利用图像的相关性合连续性，是像素级别的消隐，一个像素被多次计算判别，太慢了

于是进行优化
### 4. 扫描线z-buffer算法（像）

基本思想是，对于物体向视点平面投影得到的多边形，使用扫描线进行求交，将扫描线分成若干个由交点分界的区间，由物体的**连续性**可知，**每个区间的颜色必然是相同的**
因此，我们只要在**每个区间**内找到**最靠近视点的那个面**，用它的颜色代替**整个区间的像素颜色**即可

实现思路：
首先将面进行投影得到投影多边形，求交点，将交点进行排序，得到若干区间
然后再区间内任取一采样点（例如中点），在过中点位置的所有面之间进行分析，分析哪个面离视点更近，取这个面的颜色

问题在于，真的需要求交吗，以及怎么知道哪些多边形和这个区间相关

对于深度值，我们可以设平面方程为$Ax+By+Cz+D=0$，那么就有$z(x,y)=\frac{-Ax-By-D}{C}$，且有递推关系式$z(x+1,y)=z(x,y)-\frac{A}{C}$

且每条扫描线的最左像素的递推关系是$x_{y+1}=x_y+1/k$（和之前边相关扫描线填充一样）
代入可得
$$ z(x_{y+1},y+1)=z(x_y,y)-\frac{\frac{A}{K}+B}{C}$$
这里的x指的是扫描线区间的最左像素$x_{min}$
所以显然可以使用边表和有效边表来优化整个过程

1. 构建多边形表和边表
2. 扫描线逐行处理，首先y=ymin，有效边表为空、
3. 更新有效边表：将边表中y最小值等于当前扫描线y的边加入有效边表，从有效边表中删除y最大值小于当前扫描线y的边
4. 计算交点，通过将有效边表中的x坐标进行排序得到交点，基于平面方程计算z值增量
5. 遍历交点区间像素，比较当前z值与z缓存的值，若小于，把颜色覆盖写入帧缓存的当前位置，反之不处理
6. y=y+1，回到3，直到y=ymax

特殊处理情况：
- 贯穿情况：扫描线上的分割点需要包含贯穿边界与扫描线的交点
- 循环遮挡：将多边形沿着贯穿平面进行分割

优点：快，简单
缺点：存储空间大。处理反走样、透明和半透明效果困难，可以使用A缓冲器算法改进

### 5. 区域子分割算法（像）warnock

采用分而治之的方法，利用了栈数据结构
当一窗口中只包含一个多边形或者一个多边形的某些部分，或者不包含任何物体，此时可以直接进行显示
多边形具有x和y坐标的最值，将其与窗口的xy最值比较就可以知道它们的包含关系了，对于相交关系，则使用直线方程作为判别函数来判断

算法思想在于将窗口划分为子窗口进行显示：
1. 若窗口内无物体，显示背景色
2. 若窗口内只要一个面，直接显示这个面
3. 若窗口有两个以上的面，将窗口四等分，对每个子窗口进行123操作，反复递归直到可以直接显示

特殊情况：如果窗口只剩像素那么大了，但是这个像素内具有两个以上的面该怎么办？一般取各面色值的平均数或特判一下，选择这些面中最近的那个面的颜色进行显示

### 6. 光线透射算法（物）

由观察平面中的任一像素射入物体空间场景的射线，可以确定所有与该射线相交的物体
获得交点以后，选择离观察平面像素最近的交点，显示其所在面片的颜色
若无交点，赋上背景色

两层循环：外层for屏幕内的每个像素，对像素形成射线；内层for物空间的每个物体，将射线语气求交，若存在交点，显示最近的交点所在面的颜色，反之显示背景色。
不需要z缓冲器，可以使用包围盒、空间分割等技术提高效率

# C11. 光照模型

分类为
- 局部光照模型：只处理光源直接照射物体表面的模型
- 全局光照模型：考虑光源直接照射和物体之间光照的相互作用
后者更好地模拟了光的反射折射和阴影，以及多个透明体之间的复杂效果

## 11.1 基本光照模型

理想漫反射体（朗伯反射体）：假设入射光在各个方向以相同强度发散，各向同性，与观察位置无关

落在物体表面的光源由环境光和点光源组成，将每个表面都视为朗播体，设定一个强度k
