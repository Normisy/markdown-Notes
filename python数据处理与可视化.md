# Part 1. Pandas入门
## 1 常用功能速览
### 1.1 数据集获取
在分析和处理数据时，需要初步了解数据集。本书常用的数据集team.xlsx来自[https://www.gairuo.com/file/data/dataset/team.xlsx]()，数据格式如下：
![[Pasted image 20240809213444.png]]

### 1.2 读取数据
和往常一样，我们为pandas在引入时取别名pd：
```
import pandas as pd
```
**pandas没有多个模块，直接引入就能调用所有功能了**
初步了解数据集后，我们把数据读入到Pandas里
**变量名用df（DataFrame），它是Pandas二维数据的基础结构。
读取数据时，我们可以直接在目录下读取文件：
```
df = pd.read_excel('team.xlsx')
#数据文件要置于py项目同文件夹下，或是通过命令行控制编译器把py和文件链接在一起
#read_excel读取xlsx文件，如果是csv文件则是read_csv，支持很多不同类型的读取
```
也可以传输一个网址，它会自动把数据下载至内存：
```
df = pd.read_excel('https://www.gairuo.com/file/data/dataset/team.xlsx')
```

**==读取数据到df之后，在处理df时就完全和原数据表格没关系了，因为我们处理的是内存中的df变量==**

> [!NOTE] 如果读取xlsx文件显示出现错误的时候
> 请检查是否下载了openpyxl库，pandas使用这个库来读取xlsx文件。如有类似的未下载库的情况，编译器会报错如下
> ModuleNotFoundError: No module named 'openpyxl'  
ImportError: Missing optional dependency 'openpyxl'. Use pip or conda to install openpyxl.

### 1.3 查看数据
**pandas查看数据有以下方法：
* ==**df.head()==    括号内可传递整数参数，无参数情况下默认返回==前5条数据==，有参数则返回前相应数目条的数据
* **df.tail()    与head类似，只是返回从后往前的n条数据
* **df.sample()    无参数情况下返回一条随机行数数据，有参数则随机返回相应数量条数据**
例如：
```
import pandas as pd  
df = pd.read_excel('team.xlsx')  
print(df.sample(5))
```
结果：
![[Pasted image 20240810134410.png]]

### 1.4 验证数据
拿到数据时，我们需要验证数据加载情况、大小等是否正确，下面是一些可用于检查的代码：

* **df.shape    （不是一个函数，别带括号）返回一个元组(a, b)，==a是数据总行数，b是数据总列数==

* **df.info()    返回由数据的==索引、数据类型和内存信息==构成的表格**，print出来就能看了
  print(df.info())的结果如下：
![[Pasted image 20240810142508.png]]
Non-Null Count给出了每一列数据非空数据的数量；Dtype则是数据的类型。

* **df.describe()    返回数据的各种统计量：==总数count、平均数mean、标准差std、最小值min、分位数、最大值max==。也是直接print出来就能看：
![[Pasted image 20240810142843.png]]

* **df.dtypes    返回各列的==数据类型==：
![[Pasted image 20240810143104.png]]

* **df.axes    返回数据行的范围、列名以及dtype
```
print(df.axes)的输出是：
[RangeIndex(start=0, stop=100, step=1), Index(['name', 'team', 'Q1', 'Q2', 'Q3', 'Q4'], dtype='object')]
```

* **df.columns    返回从左到右各列的列名，以及dtype

### 1.5 建立索引
在整个数据表中，真正意义上起到索引作用的是name列。**我们需要把起到索引作用的列设置为索引：
```
df.set_index('name', inplace=True)
```
通过set_index函数就可完成索引的设置。其中参数==inplace=True==是==可选==的，它代表需要在原数据框df中进行修改，这里就是把原数据框的格式更改成以name行为索引的更好观看的格式：
```
import pandas as pd  
df = pd.read_excel('team.xlsx')  
df.set_index("name", inplace=True)  
print(df)
```
结果：![[Pasted image 20240810145728.png]]
（inplace=默认是inplace=False，即不修改原数据框）

### 1.6 数据选取
和在excel中一样，我们可以对数据进行筛选：
* **(1)  选择特定列
  查看指定列数据：
```
  df['colomnName']   colomnName是我们希望查看的列名
  
  df.colomnName   colomnName是符合python变量名要求的列名。如果不符合要求（比如不能数字打头、仅有下划线数字和字母等）就不能用这种方法
```
**在确定了索引的情况下**的输出如下：
![[Pasted image 20240810151653.png]]

**还可以选择查看多列数据**：
```
df[['team', 'Q1']]   只返回括号内的列名所标定的列
```
**pandas库的==df.loc==函数是一个非常强大的数据选择函数，它允许你根据行标签和列标签来访问或修改DataFrame的数据。df.loc主要包括选择、切片、过滤和赋值操作。**
df.loc函数选择某一列和某几列的方法是：
```
df.loc[:, 'Q1']  选择行数的全部+Q1列，即Q1列的所有数据
df.loc[:,['Q1', 'Q2']]  选择Q1和Q2列的所有数据，需要建立列表以控制参数个数在两个
```
**df.loc\[]函数==接受两个参数时==，两个参数是行的选择和列的选择，这就是它提供切片表示的一个来源，==这里行和列使用行名和列名指代，后面介绍的df.iloc\[]函数则是用行号和列号指代==
单选直接填名字即可，==多选需要建立一个列表==

**更重要的是，该函数支持==条件选择==，也支持像列表那样的切片操作**（把一个列表切片，生成由原列表切片各部分组成的新列表），这些在下面都有介绍。

* **(2)  选择特定行
在确定了索引的情况下，我们可以通过指定索引进行行的选取
```
df[df.index == 'Liver']
```
可见df本身是自带一定的条件选取功能的

我们也可以通过**类似于列表切片的自然索引直接对df进行选择：
{ 自然索引：\[start : stop : step]，其中start是开始的索引位置，stop是最后一个选中的索引位置的==后一个位置==，step即步长。
缺省的默认值分别为：0位置：尾后位置：1 }
```
df[0 : 3]    从索引0到索引3的前一位置，选择df的前三行
df[0 : 10 : 2]    从索引0到索引9，步长为2，一共选择了5行
```

**pandas还有一个用于==位置索引==的函数是==df.iloc[]==，它允许我们通过行和列的整数位置（行号与列号代替了普通的索引）来进行数据的选择
==行号与列号从0开始数==，而且==已经被设置为索引的列不计入列号==：
```
df.iloc[3, 1]   输出第4行第2列的数据
df.iloc[:10, :]   输出行数从第1行到第10行的所有列的数据，即输出第1行到第10行
```
> [!NOTE] “a : b"形式的含义： 
> 看见这样形式的标注，需要知道**a代表起始位置，b代表结束位置，a缺省代表==从起始位置到结束位置的前一位置全部被选中==，如果b也缺省就是全选。即==：":"代表选中所有项目==**
> 当然，**还可以提供第三个==步长==参数c："a : b : c"，用于指定从a到b的步长，缺省时步长为1**

* **(3)  指定行和列范围
  提供行和列的显示范围：使用df.loc函数接受两个参数的版本，用于进行行列范围的指定，注意loc使用的是名字，iloc使用的是位号：
```
df.loc['Eorge':'Alexander' , 'team':'Q4']
“从E到A，从team到Q4”范围的数据
```

* **(4)  按条件选择
  我们可以为数据的选择提供一定条件来进行筛选：
  按条件选择即使用==布尔索引==，
  可以用于df自己的索引，此时索引的是使得条件为True的==行==：
```
  df[df['Q1'] > 90]   Q1列大于90的行数据
  df[(df['team'] == 'C') & (df.Q2 > 30)]   当然也可以使用*逻辑运算符*
```

**也可以用于df.loc函数，接受单一布尔索引的形式。此时索引的依然是使得条件为True的==行==：
```
df.loc[df.Q1 > 90]   Q1列大于90的行数据
```
  上述两个接受布尔索引的形式也可以组合起来，相当于&逻辑运算
```
  df[df['team'] == 'C'].loc[df.Q1 > 90]
```

### 1.7 分组聚合
**pandas的==groupby函数==支持将数据按某一列或多列进行分组，并且对每个组应用一个聚合函数，这系列操作称为==分组聚合==
* **分组：使用groupby函数，按照索引"team"把所有team对应行的元素相同的列数据分成一组
```
df.groupby("team")
```

* **分组完成后，我们就可以对每一组相应使用聚合函数了。以求和函数sum()与平均值函数mean()为例
```
df.groupby("team").sum()    按team分组，每组对应的列元素相加
df.groupby("team").mean()   按team分组，每组对应的列元素求平均值
```
==聚合操作只能对索引行向量使用==，例如该数据表格：
![[Pasted image 20240812162120.png]]
中，name为索引列向量，team为索引行向量，只能按team对数据进行groupby，而不能按例如'Liver'或'Eli'

### 1.8 排序
pandas的排序有以下几种：
**1.按一列或多列的值对df进行排序
```
df.sort_values(by='Q1', axis=0, ascending=True, inplace=False, na_position='last')
```
* **by是要==排序的列名或列名列表==
* **axis是==排序轴==，0是按行排序，1是按列排序，默认为0
* **ascending是==布尔值（by为单列）或布尔列表（by为列列表）==，True为升序，False为降序，默认升序
* **inplace是布尔值，表示==是否在原地修改DataFrame,如果True，则不返回新的DataFrame，直接修改原df为排序后结果==
* **na_position是处理缺失值的位置，默认为'last'，也可为'first’

**当by是列列表时，排序先按第一个列表元素列，按照ascending决定升序还是降序排列，按第一个列表元素排好后，如果有该列==相同值的元素==，则对它们按第二个元素的列表值进行排序......以此类推

**2.按照索引进行排序的方法：
```
df.sort_index(axis=0, level=None, ascending=True, inplace=False, na_position='last')
```
* **axis、inplace、na_position都与按列排序相同
* **level是多级索引的级别，当有多个索引时，提供列表，从前往后索引级别减小
* **ascending在索引有多个的时候为布尔列表，唯一索引时为布尔值，含义于按列排序相同。==索引唯一又不需要其他设置时，只需提供ascending值即可进行排序==

### 1.9 数据转换
**1. 数据表的转置：
转置即以主对角线为轴进行位置的反转，==行和列的角色调换了==。这可以通过对dataframe或返回dataframe的对象调用T得到转置的dataframe：
```
df.T      对df进行转置
df.groupby('team').sum().T   对分组且求和完成的数据表进行转置
```

**2. 将列标签


### 1.10 增加列
用pandas为数据表增加一列的操作类似于新定义一个字典的键值：
```
df['const'] = 1    #增加一列'const'，各元素值为1
df['total'] = df.Q1+df.Q2+df.Q3+df.Q4    #用其他行的元素进行计算，得出值赋给新建行相应位置的元素
类似地，还可使用其他函数为新建行各元素赋值
```

### 1.11 统计分析
下面的函数是一些用于得到数据表统计数据的函数：
```
下面的函数不传参数时默认参数为0，即对列操作，传参数1时变为对行操作，例如：
df.mean()    #返回所有列的均值
df.mean(1)   #返回所有行的均值
下同
df.corr()    #返回列与列之间的相关系数
df.count()   #返回每一列中非空值的个数
df.max()     #返回每一列的最大值
df.min()     #返回每一列的最小值
df.median()  #返回每一列的中位数
df.std()     #返回每一列的标准差
df.var()     #返回每一列方差
df.mode()    #返回每一列众数
```

### 1.12 绘图
**pandas利用plot()绘制图像，调用Matplotlib库进行可视化图形的绘制。==注意：如果直接plot显示不出来图形，需要调用Matplotlib的show()方法==
```
import matplotlib.pyplot as plt
df['Q1'].plot()    #显示Q1列数据的折线分布
plt.show()
```
也可以先进行要展示数据的选择，再画图：
```
df.loc['Ben','Q1':'Q4'].plot
#选择了'Ben'行从Q1到Q4列的数据进行绘制折线图。此时的切片操作没有左闭右开
```

**可以使用plot.bar()方法绘制柱状图：
```
df.loc['Ben':'Q1':'Q4'].plot.bar()  #纵向柱状图
df.loc['Ben','Q1':'Q4'].plot.barh() #横向柱状图
```

**对数据==聚合计算==后，可以实现一组多条折线图的绘制：
注意，绘制多条折线图时，索引行向量（标注列名的那个行向量，这里是team）作为不同线条划分的依据，而折线图则是值-索引列向量（这里是name）组成的折线图
```
df.groupby('team').sum().T.plot()
#转置T把计算得到的索引行向量和索引列向量互换，生成想要的图
```
![[Pasted image 20240812162455.png]]
不转置的图形：
![[Pasted image 20240812162846.png]]
转置后的图形：
![[Pasted image 20240812162910.png]]
**利用plot.pie()函数可绘制饼图
```
df.groupby('team').count().Q1.plot.pie()
#绘制分组、求非空数据个数后，Q1组的饼图
```


## 2 数据结构
### 2.1 数据与数据结构介绍
**我们将数据类型相同的数据称为==同构的==，同一个数据列中的各数据需要是同构的；数据类型不同的数据之间称为==异构的==，需要通过转换使其一致才能进行分析

**数据结构则是组织和存储数据的方式**，常见的有栈、队列、数组、链表、树、图等等，**数据分析中最常用的数据结构是数组**
**数组由相同类型的元素的集合组成，对每一个元素分配一个内存，存储空间是连续的。每个空间会有一个==索引==来标识位置。
==现实数据往往由多个数组组成，对应于数学中的矩阵==

### 2.2 Python数据结构
标准的python数据类型分为可变和不可变数据：
- 不可变数据：Number数字、String字符串、Tuple元组
- 可变数据：List列表、Dictionary字典、Set集合
使用python内置的type()函数即可查看数据类型
```
a = "hello"
type(a)  #返回str
```
或是使用isinstance判断是否为指定类型
```
isinstance('123', int)
#返回False
```

### 2.3 Numpy

