# 第1讲 课程概览与shell
## 1.1 Shell的用法
### 什么是shell?
如今的计算机拥有各种各样的交互接口来让我们进行指令的输入，它们覆盖了大多数的使用场景，并且各自有自己的操作限制。**为了充分利用计算机的能力，我们不得不回到最根本的方式：***文字接口Shell*** 
shell的形式多种多样，其核心功能都是一样的：**它允许你执行程序，输入并获取某种半结构化的输出，它们的语法都是类似的**
使用shell之前，我们首先需要打开**终端**，我们的设备通常都内置了终端，或者我们自己进行安装也行。
这里我们使用Git bash，界面如下：
![[Pasted image 20240711133853.png]]
我们可以看到shell的提示符如上，它显示了主机名字34382@Normist，以及当前位置是~(home)，$的含义稍后解释
### 开始使用shell！
在提示符之后，我们可以输入**命令**，它会被shell解析，最简单的命令是输入一个程序的名字，shell会自动执行这个程序，例如**date程序**：
```
34382@Normist MINGW64 ~
$ date
Thu Jul 11 14:14:19     2024

34382@Normist MINGW64 ~
$
```
它打印了当前的日期与时间。
我们还可以在执行命令的同时，向程序传递**参数**：
```
34382@Normist MINGW64 ~
$ echo hello
hello

34382@Normist MINGW64 ~
$
```
这里向**echo**命令传递了参数hello，它将该参数打印出来。
**shell基于空格分割命令**，**它执行第一个单词代表的程序，并且将后续被空格间隔开的单词作为程序可以访问的参数**
如果我们希望传递的参数中包含空格，有两种方法：**1.将整体使用单引号或双引号包裹起来，如“My Photos" ; 2.使用转义符号’\\‘，如：My\\Photos**

#### shell是怎么寻找程序date或echo的？
类似于Python，**shell其实是一个编程环境**，它具备 ***变量、条件、循环与函数*** 。
**当我们在shell中执行命令时，实际上是在执行一段shell可以执行解释的简短代码，它的流程大致如下：**
当我们输入一个指令时，如果该指令**并不是shell中某个编程关键字**，那么它会向 ***环境变量$PATH*** 进行咨询：
```
34382@Normist MINGW64 ~
$ $PATH
bash: /c/Users/34382/bin:/mingw64/bin:/usr/local/bin:/usr/bin:/bin:/mingw64/bin:/usr/bin:/c/Users/34382/bin:/c/Windows/system32:/c/Windows:/c/Windows/System32/Wbem:/c/Windows/System32/WindowsPowerShell/v1.0:/c/Windows/System32/OpenSSH:/c/Program: No such file or directory

34382@Normist MINGW64 ~
$
```
环境变量列出当shell接到指令时，**进行程序搜索的路径**。也就是说：**shell会在$PATH中搜索由':'分隔的一系列目录，基于名字搜索该程序，找到这个程序时便执行它**
我们可以通过**which指令**得知**电脑运行的程序具体在哪个目录**中：
```
34382@Normist MINGW64 ~
$ which echo
/usr/bin/echo

34382@Normist MINGW64 ~
$
```

> [!NOTE] 路径
> 路径是用来描述你的计算机中文件的位置的东西，常被一系列的斜杠/分割。绝对路径是可以绝对准确地确定一个文件位置的路径。相对路径则是相对于你当前所在位置的路径

我们可以通过**指令pwd** **输出当前我所在的目录路径：**
```
34382@Normist MINGW64 ~
$ pwd
/c/Users/34382

34382@Normist MINGW64 ~
$
```

我们可以选择改变我们的当前工作目录，通过**cd指令**（change directory) 来实现：
```
34382@Normist MINGW64 ~
$ cd /bin

34382@Normist MINGW64 /bin
$
```
这里我们把当前工作目录改变到了/bin上，提示符的~变为了/bin，在不额外设置的情况下，它总是显示路径最后一段的名称。

一对特殊的目录是 **.(点)和..(点点)****  ，**点表示当前目录，点点表示上一层目录，我们可以通过它们简单地访问整个系统：**
```
34382@Normist MINGW64 ~
$ cd ..

34382@Normist MINGW64 /c/Users
$
```
这里我们把当前位置转到了上一层目录

**我们可以通过相对路径来向下访问文件系统：**
例如使用指令 **cd ./home** ，如果当前目录下有home目录，就会转到这个home目录，如果没有则会显示找不到这个目录。
我们可以使用类似于../../../bin/echo hello\\world的方式给出完整路径来精确地调用某个程序，但这样的做法会损失一般性，有可能在其他目录下无法运行。
可见知道我们当前目录下有什么东西是很关键的，类似于pwd指令，**命令ls能够输出我们当前目录下的所有文件：**
```
34382@Normist MINGW64 ~
$ ls
 AppData/
'Application Data'@

/* 太长了，全省略掉 */

 ntuser.dat.LOG1
 ntuser.dat.LOG2
 ntuser.ini
 source/
 「开始」菜单@
 新建文件夹/

34382@Normist MINGW64 ~
$
```
我们可以使用命令cd ..回到上一级目录，然后用ls输出该级目录下的所有文件。一个相同效果的更简便写法是**ls ..** ，它直接输出上级目录下的所有文件。

一些特殊含义的符号：
**1. 符号~总是指向用户目录，我们可以通过~到达用户目录相关的目录
例如 cd ~/dev/pdos 就相当于 cd /c/Users/34382/dev/pdos，因为用户目录是/c/Users/34382

**2.cd命令中的一个重要参数是‘-’，它会回到你上一次所在的目录，例如：
```
34382@Normist MINGW64 ~
$ cd /bin

34382@Normist MINGW64 /bin
$ cd -
/c/Users/34382

34382@Normist MINGW64 ~
$ cd -
/bin

34382@Normist MINGW64 /bin
$
```
这里我们一开始在用户目录~下，然后跳转到/bin目录下，通过cd -回到了一开始所在的用户目录，再使用一次cd -则回到了之前所在的/bin目录。

#### 程序以什么作为参数?
对于ls与cd，也许它们还有一些我们所不知道的参数，那么我们该如何了解一个程序的所有用法？
**大多数程序采用一些** ***flag(标志)*** **或** ***option(选项)*** **等作为参数，它们一般都以半角字符-开头。**

**1. flag（标志）通常指代为一个开关或标识，它用于表示某个特定状态或条件。在命令行中，flag通常是一个字母或单词前面带有 '-' 或 '--' ，用于标识某种选项或行为是否启用，例如：
```
-v 或 --verbose : 表示启用详细输出模式
-h 或 --help    : 表示显示帮助信息
```

**2.option（选项）通常指代需要带有参数值的命令行参数（即带值的标志），它通常由一个字母或单词前面带有 ‘-’ 或 ’--‘，并且后面紧跟着一个值组成（单词需要带等于号=），例如：
```
-o filename 或 --output=filename  :  表示设置输出文件的路径为...
-d directoryname 或 --directory=directoryname : 表示设置工作目录为...
上面的filename和directoryname都是具体的参数值
```

**大多数程序都包含了 --help 或 -h 这个函数，它会输出一大堆关于该程序的帮助信息，方便我们了解程序可用的标志或选项，如：
```
34382@Normist MINGW64 /bin
$ ls --help
Usage: ls [OPTION]... [FILE]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.

Mandatory arguments to long options are mandatory for short options too.
  -a, --all                  do not ignore entries starting with .
  -A, --almost-all           do not list implied . and ..
      --author               with -l, print the author of each file
  -b, --escape               print C-style escapes for nongraphic characters
      --block-size=SIZE      with -l, scale sizes by SIZE when printing them;
                               e.g., '--block-size=M'; see SIZE format below
    --hyperlink[=WHEN]     hyperlink file names; WHEN can be 'always'
                               (default if omitted), 'auto', or 'never'

/* 后略 */
```
**在帮助列表中，"..."表示可不填或填1个或更多，[ ]代表可接受option，并且会说明这个option可以是什么，例如上例中的--hyperlink\[=WHEN]

一个以后会经常用到的flag是==-l==，**它会输出当前路径下的一长串文件，除此之外还给出了更多有关这些文件的信息：**
```
34382@Normist MINGW64 ~
$ ls -l
total 23186
drwxr-xr-x 1 34382 197609        0 Jun 15  2023  AppData/
lrwxrwxrwx 1 34382 197609       30 Jun 15  2023 'Application Data' -> /c/Users/34382/AppData/Roaming/
drwxr-xr-x 1 34382 197609        0 Jun 15  2023  Contacts/
lrwxrwxrwx 1 34382 197609       58 Jun 15  2023  Cookies -> /c/Users/34382/AppData/Local/Microsoft/Windows/INetCookies/

/* 省略 */

-rw-r--r-- 1 34382 197609  3407872 Jun 15  2023  ntuser.dat.LOG2
-rw-r--r-- 1 34382 197609       20 Jun 15  2023  ntuser.ini
drwxr-xr-x 1 34382 197609        0 Sep  8  2023  source/
lrwxrwxrwx 1 34382 197609       59 Jun 15  2023  「开始」菜单 -> '/c/Users/34382/AppData/Roaming/Microsoft/Windows/Start Menu'/
drwxr-xr-x 1 34382 197609        0 Jun 15  2023  新建文件夹/

34382@Normist MINGW64 ~
$
```
来看看-l给出了哪些**额外信息：

**1.形如下式的前面带d的条目代表着它是一个目录，在它下面还有着某些东西：
```
drwxr-xr-x 1 34382 197609        0 Jun 15  2023  Videos/
```
而形如下式的条目则不是个目录，而是文件：
```
-rw-r--r-- 1 34382 197609 14417920 Jul 12 00:42  NTUSER.DAT
```
后面的字符代表着文件或目录被授予的权限,阅读这串字母的方式如下：
```
将前面这串字符作如下拆分，例如：
drwxr-xr-x   ->  d rwx r-x r-x  即第一个字符单拆开，后面的9个字符3个分一组
从前往后的三组字符分别代表着文件所有者具有的权限、用户组具有的权限、其他所有人具有的权限

我们不难发现三组字符都是由r、w、x、-四个字符组成的，并且-代表rwx中的某种缺项
rwx中，r代表“具有读权限”，w代表“具有写权限”，x代表“具有可执行权限”（即可以执行里面的程序），-代表“不具备该位置上的权限”

对于文件，读、写和执行三个操作的含义就是字面意义；
对于目录，读取权限意味着“允许你查看文件夹中有哪些内容”，
写入权限意味着“你能够重命名、新建或删除目录里面的文件”（这意味着如果你仅有文件的读入权限而无目录的，那么该文件能被清空而不能被删除），
执行权限意味着“你能进入这个目录进行‘搜索’”：如果你想访问目录中某个文件或是打开、读取、写入这个目录，甚至是cd到这个目录，你都必须要有*该目录及其所有父目录的执行权限*

所以drwxr-xr-x中，d指示该条目是一个目录，后面的九个字符分别代表：文件所有者具有读写执行三个权限、用户组具有除了写之外的两个权限、其他所有人也具有除写以外的两个权限

```
**除了d以外，第一个字符还可以是：-（表示普通文件）； l（表示符号链接文件）；c（表示字符设备文件）；b（表示块设备文件）；p（表示管道文件）；s（表示套接字文件）

**2.在此之后，几个以空格分开的条目分别代表：
```
以drwxr-xr-x 1 34382 197609        0 Jun 16  2023 'Saved Games'/为例
在drwxr-xr-x之后的1代表着文件或目录的硬连接数(hard link)

随后的34382的位置的数据是 文件或目录的所有者的用户名

197609的位置的数据是 文件或目录的所属组名（group）

0的位置的数据是 以字节为单位的文件大小（对于文件来说）或 占用的磁盘块数（对于目录来说）

Jun 16  2023的位置的数据是 最后修改日期和时间

'Saved Games'/的位置的数据是 文件或目录的名称
```

#### 一些趁手的命令
**1. mv命令**
我们可以使用`mv`命令来**重命名文件**或**移动文件至新路径**，它的帮助列表显示用法如下：
```
Usage: mv [OPTION]... [-T] SOURCE DEST
  or:  mv [OPTION]... SOURCE... DIRECTORY
  or:  mv [OPTION]... -t DIRECTORY SOURCE...
Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.
```
**`mv`命令接受两个参数，靠前的一个是原有路径或原文件名，靠后的那个是目标路径或新文件名，例如：**
移动文件 file.txt 到目录 /path/to/directory/
```
mv file.txt /path/to/directory/
```

重命名文件oldfile.txt为newfile.txt
```
mv oldfile.txt newfile.txt
```

把/path/to/source/oldfile.txt移动到/path/to/target/并重命名为newfile.txt
```
mv /path/to/source/oldfile.txt /path/to/target/newfile.txt
```

多个文件的移动：把file1.txt 和 file2.txt 移动到/path/to/target/
```
mv file1.txt file2.txt /path/to/target/
```

移动目录
```
mv /source/dir1  /target/  （最后有斜杠）
```
将目录dir1移动到/target/下成为子目录/target/dir1
如果目标目录target不存在，则会新建一个同名target目录

移动并重命名目录
```
mv /source/dir1  /target/dir2  （最后无斜杠）
```
更多用法见帮助目录，例如mv还可接受一个选项 mv [OPTION]... SOURCE... DIRECTORY
进行额外的操作，例如
```
OPTION可以是：  
  
1.-i：在移动文件之前进行确认，如果目标文件已存在则提示确认覆盖。  
2.-f：强制移动文件，不进行提示，覆盖已存在的目标文件。  
3.-v：显示详细信息，即移动过程中每个文件的名称。
```

**2.cp命令**
我们可以使用`cp`命令**进行文件或目录的拷贝**。
```
Usage: cp [OPTION]... [-T] SOURCE DEST
  or:  cp [OPTION]... SOURCE... DIRECTORY
  or:  cp [OPTION]... -t DIRECTORY SOURCE...
Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.
```
**cp命令也接受两个参数，前面的是源文件，后面的是目标文件或目录。将要复制的源文件复制到目录位置，如果第二个参数是目标文件名，则源文件被复制并重命名为该目标文件名

复制文件 file.txt 到目录 /path/to/directory/
```
cp file.txt /path/to/directory/
```

复制并重命名文件
```
cp oldfile.txt newfile.txt
```

cp命令也支持使用选项：cp [OPTION]... SOURCE... DIRECTORY
```
OPTION可以是：  
  
1.-i：在复制文件之前进行确认，如果目标文件已存在则提示确认覆盖。  
2.-f：强制复制文件，不进行提示，覆盖已存在的目标文件。  
3.-r, -R：递归复制，用于复制目录及其所有内容（子目录和文件）。  
4.-v：显示详细信息，即复制过程中每个文件的名称。
```

递归拷贝目录下的子目录以及所有其中的文件至
```
cp -r /path/to/source/directory /path/to/target/
```

**3.rm命令**
我们可以使用rm命令**移除或删除一个文件。**
```
Usage: rm [OPTION]... [FILE]...
Remove (unlink) the FILE(s).
```
可以向rm命令直接传递一个文件名或一个路径指向的文件，删去该文件：
```
rm food.md  或 rm /path/to/source/food.md
```

默认的rm命令是**非递归的**，我们**不能直接删除一个多文件的目录**
但是在选项中，我们可以选择使用执行递归移除的**flag -r**，然后传递想移除的路径，它就会移除目录下的所有内容：
```
rm -r /path/to/directory
该命令删除directory目录下的所有文件和子目录，要谨慎使用
```
也有**rmdir命令**让你可以**移除目录**，不过它**只允许移除空目录**，防止扔掉一些重要文件

**4.mkdir命令**
可以让你**创建一个新目录（文件夹）**。
```
Usage: mkdir [OPTION]... DIRECTORY...
Create the DIRECTORY(ies), if they do not already exist.
```
例如
```
mkdir "My Photos"
```

**5.man程序**
即manual，该程序**接受其他程序的名字作为一个参数，然后显示它的说明书**
*需要自己安装，非自带*
其效果类似于--help，不过更易阅读

**6.一些快捷键**
ctrl + c : 中断正在运行的命令
ctrl + d：从终端退出或结束输入
ctrl + l：相当于clear指令，清屏
tab：自动补全命令或文件名（会给出所有可能选项）
```
34382@Normist MINGW64 ~
$ l
Display all 147 possibilities? (y or n)
L2SecHC.dll
LAPRXY.DLL
LangCleanupSysprepAction.dll
LanguageComponentsInstaller.dll
......
```

#### shell的真正本领！
目前为止，我们只是分开地介绍了各个程序，但shell真正的本领在于**将不同的程序连接在一起/与文件进行交互/在各个程序之间操作文件**
我们借助一个叫做**流（stream）** 的概念完成：**流是指数据在程序之间传输的方式和通道**
1.**大于号>表示重定向左侧程序的输出流，变为输出到右侧对象中，例如：**
```
34382@Normist MINGW64 ~
$ echo hello > hello.txt
34382@Normist MINGW64 ~
$ ls
 AppData/
'Application Data'@
/* 省略 */
 hello.txt
......
即新建了一个hello.txt，并且把echo hello的结果输出到了hello.txt里
```
可以用**cat指令==输出文件内容==来验证：**
```
34382@Normist MINGW64 ~
$ echo hello > hello.txt

34382@Normist MINGW64 ~
$ cat hello.txt
hello
```
同理，**对于cat来说，其输出是将输入的文件的内容打印，它的输出也可以进行重定向**

**2.小于号<代表左侧程序输入流的重定向，重定向到从右侧对象读取输入**
以cat为例，该指令本质上是打开参数所给出的文件，从其中读取内容输入，再把文件内容进行输出（打印），可以将其写为：
```
cat < hello.txt
```
也是相同的效果：cat从hello.txt中获得输入，执行打开文件+输出内容的工作。
重定向操作也可以连用，比如用以下方式代替cp指令：
```
cat < hello.txt > hello2.txt
```
cat的输出被重定向到hello2.txt，shell会新建一个hello2.txt并把hello.txt的内容输出到hello2.txt中

**3.输出有两种模式：追加（向文件尾部继续添加内容）和覆写（清空文件，再添加内容）
单大于号>是覆写文件，而双大于号>>则是追加文件
```
34382@Normist MINGW64 ~
$ cat < hello.txt >> hello2.txt

34382@Normist MINGW64 ~
$ cat hello2.txt
hello

34382@Normist MINGW64 ~
$ cat < hello.txt >> hello2.txt

34382@Normist MINGW64 ~
$ cat hello2.txt
hello
hello
```
**4.管道符 |
它允许我们在程序之间传递数据：管道符左侧程序的输出将成为右侧程序的输入
```
34382@Normist MINGW64 ~
$ ls | grep ".txt"
hello.txt
hello2.txt
mumu_boot.txt

34382@Normist MINGW64 ~
$
```
这里**grep命令用于筛选并打印输入中所有含".txt"的项目**，而ls输出的当前目录下的所有文件成为grep命令的输入
对于多个命令也是类似的，左侧输出为右侧输入，单向流动
使用管道符将命令连接在一起，可以实现文本操作的许多特技，更重要的，**它不仅仅适用于文本数据，还可以拿来处理（二进制）图片、视频文件等等，这在后面会学到。**

#### 终端的更高级用法！（windows不适用）
**root 用户：** 一类在类Unix系统中非常特殊的用户。类似于windows中的管理员Administrator，有值为0的用户ID。**根用户几乎不受任何限制，他可以创建、读取、更新和删除系统中的任何文件（包括不可读写的文件）**。
大多数情况下，我们并不会以根用户的身份直接登陆系统，而是以类似于34382@Normist的普通身份操作电脑，这样更安全。
**因为这些参数是以文件形式展露的，所以我们可以对它们使用我们之前学到的所有工具对它们进行操作**。
例如，sys/class/backlight中含有包括屏幕亮度brightness在内的参数，我们可以通过cat得到他们，如果直接对其进行修改，那么会提示Permission denied 无权限，**要修改内核的参数，就得使用管理员权限**

**要注意，在重定向的时候，如果我们只在最前面加了一个sudo，那么shell只是用管理员权限运行了命令，而对后面打开文件时用的还是普通权限，仍然无法进行更改：
```
sudo echo 500 > brightness
bash:brightness:Permission denied
```
**此时解决问题的一个方法是：将自己的终端切换至root终端，通过下列命令实现：
```
sudo su
exit
```
此时显示符从$切换为#，用户名也变为root
通过exit命令退出

**另一个解决方法是使用管道符
```
echo 1060 | sudo tee brightness
```
==tee命令接受输入，并且同时将输入给输出到文件和标准输出流（打印到屏幕上）中==，这里使用管理员权限运行sudo命令，它接受echo输出的参数作为输入，并且修改brightness。

对内核的探究十分有意思，可以改变很多你电脑的配置（**注意安全！！**），包括键盘LED灯的亮度，邮箱是否有邮件，等等

> [!NOTE] windows操作系统的内核文件
>在 Windows 操作系统中，访问内核文件（例如调节亮度、LED 等参数）不像在某些类 Unix 系统（如 Linux）中那样直接暴露给用户。Windows 通过其系统接口和驱动程序模型提供了访问硬件和系统设置的途径，而不是直接通过文件系统暴露这些控制接口。

# 第2讲 Shell 工具和脚本
## 2.1 编写Shell脚本
**shell 脚本针对 shell 所从事的相关工作进行了优化。因此，创建命令流程（pipelines）、将结果保存到文件、从标准输入中读取输入，这些都是 shell 脚本中的原生操作，这让它比通用的脚本语言更易用。
### 2.1.1 shell的变量语法
定义一个变量，使用=号，不能有空格
可以使用 $变量名 的方法访问变量的值：**
```
34382@Normist MINGW64 ~
$ foo=bar

34382@Normist MINGW64 ~
$ echo $foo
bar
```
**空格是用于分隔参数的字符，所以foo = bar 是在告诉shell，调用foo程序，第一个参数是"="，第二个参数是"bar"**

**定义字符串：使用双引号""或单引号''
```
34382@Normist MINGW64 ~
$ echo "genshin launch"
genshin launch
34382@Normist MINGW64 ~
$ echo 'i love arknights'
i love arknights
```
对于***纯文本字符串***，**单引号与双引号等效，但是有些情况下则不同：**
```
34382@Normist MINGW64 ~
$ echo "value is $foo"
value is bar
```
双引号中将$foo展开为字符串，替换为shell中变量"foo"的值，而
```
34382@Normist MINGW64 ~
$ echo 'value is $foo'
value is $foo
```
单引号中"$foo"**不会被展开**

### 2.1.2 流程控制（定义函数、for、while循环等）
之前我们只演示了通过管道运输多个命令的操作，但很多时候我们希望先执行一件事，然后再做另一件事。
**和其他大多数的编程语言一样，`bash`也支持`if`, `case`, `while` 和 `for` 这些控制流关键字。同样地， `bash` 也支持函数。**
函数的定义等在脚本中完成，我们可以使用自己喜欢的文本编辑器来编写脚本，**一个内置的编辑器是vim，通过以下命令来打开：**
```
vim filename
```
filename是你要编辑的文件名。**如果文件不存在，那么Vim将会创建一个新的空文件。**
**脚本通常以.sh结尾，但windows中也可以是.bash结尾或无后缀的文件名**
**（vim的操作方法在讲完流程控制后叙述）**

#### 1.函数定义
以下面的函数为例：
```
mcd () {
    mkdir -p "$1"
    cd "$1"
}
```
该函数创建一个文件夹，并且使用cd命令进入该文件夹。
这里“**$1**"是脚本的第一个***参数***，与其他脚本语言不同，**bash使用了很多特殊的变量来表示参数、错误代码与相关变量。
```
- `$0` - 脚本名
- `$1` 到 `$9` - 脚本的参数。 `$1` 是第一个参数，依此类推。
- `$@` - 所有参数
- `$#` - 参数个数
- `$?` - 前一个命令的退出状态码，如果正常退出则返回0，非零值则是发生错误，可以用在判断语句中
- `$$` - 当前脚本的进程识别码
- `!!` - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 `sudo !!`再尝试一次。
- `$_` - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 `Esc` 之后键入 . 来获取这个值。
```
**在编写脚本时，我们可以使用"$1”来访问第1个参数，"$0"访问脚本名字，等等。
而其他的如“$?"、”!!"等对命令的变量就可以直接用了，节省代码的输入，例如
```
sudo !!
即用管理员权限执行一次上一条命令
```

我们可以通过source命令来在当前shell环境下执行一个脚本文件
```
source filename.sh
（这里filename.sh文件要存在）等价于直接
filename.sh
```
以mcd.sh为例，我们使用source命令执行mcd脚本并新建文件夹testMCD并进入
```
34382@Normist MINGW64 ~
$ vim mcd.sh

34382@Normist MINGW64 ~
$ source mcd.sh

34382@Normist MINGW64 ~
$ mcd testMCD

34382@Normist MINGW64 ~/testMCD
$
```

#### 2.标准错误流
一个进程可以通过不同的方式与其他进程或命令进行通信，除了标准输出输入流，还有例如标准错误流的其他方式。
**标准错误流用于在程序编写时输出错误信息，错误代码用于报告程序的整体运行情况。
例如，在“$?"这个参数中，它显示上一条命令的退出状态
```
34382@Normist MINGW64 ~/testMCD
$ echo "$0"
/usr/bin/bash

34382@Normist MINGW64 ~/testMCD
$ echo "$?"
0
```
和其他编程语言一样，正常退出返回0，反之返回非0值
```
34382@Normist MINGW64 ~
$ grep genshin mcd.sh

34382@Normist MINGW64 ~
$ echo $?
1
```
我们试图在文件mcd.sh中寻找字符串"genshin"且没有找到，因此grep命令返回状态为1。如果没找到这个文件，返回状态会是2

**特殊错误代码的命令：
1.true   错误代码始终为0
2.false  错误代码始终为1
和C语言一样，bash支持逻辑运算，即退出码可以搭配 `&&`（与操作符）和 `||`（或操作符）使用，用来进行条件判断，决定是否执行其他程序。它们都属于短路运算符（即先检测左边的退出码，根据情况决定要不要检测右边的退出码）**。
```
34382@Normist MINGW64 ~
$ false || echo "wow"
wow
```
这里检测到左边的退出码为1，因此或运算需要检测右边退出码，**同时执行了echo命令，因此打印出了wow。**
而如果左侧退出码为0，比如
```
34382@Normist MINGW64 ~
$ true || echo "oops"

```
这样就不会执行echo命令了，自然也没打印出任何东西
同理，**对于&&运算符，左侧对象返回码为0时才会检测运行右侧命令，否则不会**

**同一行的多个命令，可以使用 ”；“分隔，从左到右执行
```
34382@Normist MINGW64 ~
$ echo "genshin" ; echo "launch"
genshin
launch
```
标准错误流的重定向与标准输出流有所不同

#### 3.将命令的输出存储入变量
通过类似于"**$( )**"的方式，可以**将命令的输出存储入变量**
```
34382@Normist MINGW64 ~
$ foo=$(pwd)

34382@Normist MINGW64 ~
$ echo $foo
/c/Users/34382
```
更一般地，我们可以**将它放入字符串中来执行”***命令替换***“，**即在一个命令的输出中嵌套另一个命令**
```
34382@Normist MINGW64 ~
$ echo "we are in $(pwd)"
we are in /c/Users/34382
```
这里pwd的输出被嵌套进echo的输出了，这是一个常用的技巧

另一个小众的工具称为***进程替换***，类似于命令替换，**进程替换将除第一个命令外的后续命令用圆括号括起来，用<连接，在内部执行各个后续命令，将其输出放入一个类似于临时文件的对象中，并将文件标识符提供给<左边的命令，传输各个文件给最左侧命令
```
34382@Normist MINGW64 ~
$ cat <(echo "huhu") <(echo "haha")
huhu
haha
```
cat连接起各个临时文件，把它们的内容连接在一起然后输出

#### 4.通配符
有时候我们需要一些**表示一个或任意个字符的字符，来进行小范围内的匹配**。这时就可以使用通配符，这里介绍**通配符”$*$“和”？“以及花括号"{}"**
```
通配符*表示任意个任意字符，与给定字符连用，表示所有满足该位置是给定字符的字符串
34382@Normist MINGW64 ~
$ ls *.sh
mcd.sh
这里*.sh表示所有以.sh结尾的文件名
```

```
通配符?表示一个任意字符
file?.txt就表示如file1.txt、file2.txt...等所有满足相应位置是给定字符，余下那一个位置为任意字符的字符串
```

```
通配符..可以用于有序序列，例如
1..4 等同于 1 2 3 4
a..c 等同于 a b c
```

```
另一个常用的模式是使用花括号{}
花括号用于扩展和生成多个选项，花括号内的内容会被扩展为多个字符串序列或命令序列：
file{1..3}.txt  等同于  file1.txt file2.txt file3.txt
file{.txt,.bak}  等同于  file.txt file.bak
多个花括号，它们会作笛卡尔积
{1,2}kk{1,2,3}  等同于 1kk1 1kk2 1kk3 2kk1 2kk2 2kk3
通配符与花括号也是可以连用的

假设我们有一个png格式的图像image，我们想把它转换为jpg格式，可以使用convert命令：
convert image.png image.jpg
convert命令可用于图像格式转换、尺寸调整、旋转翻转、添加水印和滤镜等图像文件操作
使用convert image.{png,jpg}更简洁
```

### 2.1.3 使用其他语言的脚本与shell交互
目前为止我们只看到了bash脚本，但对于某些任务，使用bash或许会比较棘手。实际上，**我们可以用许多不同语言来实现与shell交互的脚本，比如以下的python脚本：
```
#!/usr/local/bin/python
import sys
for arg in reversed(sys.argv[1:]):
    print(arg)
```
python在默认情况下不会与shell交互，因此要引入sys库。
sys库承担了与系统交互的桥梁角色，提供了访问命令行参数、环境变量等系统级别的功能**

第一行的魔法行称为**shebang**，**展示了运行这个脚本的程序所在的路径**，**它让shell知道应该如何运行这个脚本：

```
不加魔法行，我们可以在shell中使用python命令来运行该脚本并提供参数：
python script.py a b c
c
b
a

而shebang展示的路径，让shell知道该脚本必须使用python作为解释器，因此加了魔法行后就可以直接在shell中调用脚本了:
./script.py a b c
c
b
a
```
不同的机器可能会把python放在不同的地方，我们也许无法提前知道python或其他解释器安装在哪，此时我们可以使用**env命令**
**env命令用于操作和管理环境变量，它会利用PATH来进行定位**：
```
#!/usr/bin/env python
```
因为我们知道**对于几乎所有系统来说，解释器都在usr/bin中，它里面有许多二进制文件。调用env并以python作为参数，它将在该路径中搜索python二进制文件，然后用它来解释该脚本文件，提高了脚本的可移植性**

> [!NOTE] shebang
> 当使用带有shebang的文本文件时，将它视为类Unix系统的可执行文件，基本语法为
> 		       #!_interpreter_ \[_optional-arg_]
> 其中interpreter解释器的地方应该是一个**可执行程序的路径**，**加载时加载器执行该解释器程序，将运行脚本时==最初使用的路径==传递给它，然后解释器程序找到该文件作为输入数据**


bash内置的功能并不现代化，它并不提供内置的故障警报，因此推荐使用**shellcheck**这个工具，他能为你提供错误的警告以及推荐写法
shellcheck的用法是直接以脚本文件名作为参数：
```
shellcheck example.sh
然后会在下方打印出错误产生的位置及产生原因
```

在编写bash脚本或函数时，**“直接运行脚本或函数”和“载入shell的脚本或函数”是有区别的，这在后面会细说**
**但总的来说，如果你对你所在路径进行更改，比如cd到一个bash脚本并且只执行该bash脚本，此时该脚本文件不会移动到shell当前所在路径；而如果你将代码加载到shell中，他会直接在你当前的路径执行。对于shell中定义的变量也同理
- 函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。
- 函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 [`export`](https://man7.org/linux/man-pages/man1/export.1p.html) 将环境变量导出，并将值传递给环境变量。
- 与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。
### 2.1.4 处理shell时非常好用的工具
**1. ripgrep工具：和grep命令类似，用于搜索文件中的内容，具有彩色编码，查找速度快，以及支持许多有用的flag

**2. imagemagick与ffmpeg
分别用于处理图像与视频，具体方法可以看man页

**3. tldr工具(社区贡献的说明手册)
有时候手册内容太过详实，让我们难以在其中查找哪些最常用的标记和语法。 [TLDR pages](https://tldr.sh/) 是一个很不错的替代品，它提供了一些案例，可以帮助您快速找到正确的选项。

## 2.2 如何查找文件？
查找文件 的一个简单粗暴的方法是**不断ls，直到看到需要的文件夹和文件为止**
但如果我们**已经知道我们要查找的所有文件夹的名字**，比如我们要查找所有名为'src'的文件夹，那么有更好的命令来完成这个任务：使用==**find命令**==
find的帮助界面长这样：
```
$ find --help
Usage: find [-H] [-L] [-P] [-Olevel] [-D debugopts] [path...] [expression]

Default path is the current directory; default expression is -print.
Expression may consist of: operators, options, tests, and actio
```
比较难读，先看看以下几个使用示例
**1.查找类型为文件夹(d)的，名字为'src'的对象**
```
34382@Normist MINGW64 ~
$ find . -name src -type d
./AppData/Local/Microsoft/Office/SolutionPackages/57de9bda114a47d3e978d6dc4b662330/PackageResources/assets/src
find: ‘./AppData/Local/Microsoft/Windows/INetCache/Low/Content.IE5’: Permission denied
find: ‘./AppData/Local/Temp/WinSAT’: Permission denied
./AppData/Roaming/LarkShell/PC_Gadget/7288186406151766020/app/cli_9cb844403dbb9108/2.16.2528/_/_/shared/src
```
如前所述，这里'.'代表的是当前文件夹**这里'.'代表的是当前文件夹里'.'代表的是当前文件夹**。

**2.查询特定格式的文件路径
```
34382@Normist MINGW64 ~
$ find . -path '**/test/*.py' -type f
find: ‘./AppData/Local/Microsoft/Windows/INetCache/Low/Content.IE5’: Permission denied
find: ‘./AppData/Local/Temp/WinSAT’: Permission denied
```
使用通配符，配合上具体路径，我们就可以查找到该路径下所有符合要求的对象，此处对象类型f代表文件

当然，**还可以使用路径或类型之外的标志flag：
```
34382@Normist MINGW64 ~
$ find . -mtime -1
......太多了，省略
```
该命令查询我们过去一天所有被修改过的文件并打印
除了mtime，还有例如大小、所有者、权限等各种其他的标志和选项可以使用

**3.在找到文件时执行一些操作
```
find . -name "*.tmp" -exec rm {} \;
```
使用-exec参数，让find命令在查找到以.tmp为后缀的文件时，对这些文件执行rm命令，这是个非常强大的参数

find命令的使用比较繁琐，如果我们想要使用功能简单一些的短命令，可以使用**fd程序**：
**fd命令默认使用正则表达式，能够直接进行搜索，但是需要自己安装拓展包
```
fd ".*py"
```
它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。**
下面是值得参考的`fd`指令tldr文档：
```
 - Recursively find files matching a specific pattern in the current directory:
    fd "string|regex"

  - Find files that begin with foo: (以foo开头的文件)
    fd "^foo"

  - Find files with a specific extension: (拓展名为txt的文件)
    fd --extension txt

  - Find files in a specific directory:
    fd "string|regex" path/to/directory

  - Include ignored and hidden files in the search:
    fd --hidden --no-ignore "string|regex"

  - Execute a command on each search result returned:
    fd "string|regex" --exec command

```

或许会认为"find"可能只是实际上在遍历目录结构并寻找内容，但如果我需要进行多次find该怎么办？**采用数据库方法并首先构建出一个索引，然后让该索引以某种方式更新**是否会更好？
事实上，**大多数Unix系统已经通过==locate==命令完成了这一点**，
locate命令的帮助列表：
```
$ locate --help
Usage: locate [-d path | --database=path] [-e | -E | --[non-]existing]
      [-i | --ignore-case] [-w | --wholename] [-b | --basename]
      [--limit=N | -l N] [-S | --statistics] [-0 | --null] [-c | --count]
      [-P | -H | --nofollow] [-L | --follow] [-m | --mmap] [-s | --stdio]
      [-A | --all] [-p | --print] [-r | --regex] [--regextype=TYPE]
      [--max-database-age D] [--version] [--help]
      pattern...
Please see also the documentation at [https://www.gnu.org/software/findutils/].
You can report (and track progress on fixing) bugs in the "locate"
program via the GNU findutils bug-reporting page at
https://savannah.gnu.org/bugs/?group=findutils or, if
you have no web access, by sending email to <bug-findutils@gnu.org>.

```
**locate命令使用一个由updatedb负责更新的数据库，来查找你的文件系统中包含你想要的子字符串的路径**
```
34382@Normist MINGW64 ~
$ locate -i .txt

34382@Normist MINGW64 ~
$ echo "$?"
1
（这里没找到）
```
它有几个选项，例如-i忽略大小写等

有时候，**我们关心的是文件的内容，此时我们可以使用grep命令查找。当然可以使用find加上选项-exec，也可以使用grep的R选项，在目录下递归查找；或者使用上面提到的ripgrep


> [!NOTE] grep
> `grep` 有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有 `-C` ：获取查找结果的上下文（Context）；`-v` 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， `grep -C 5` 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 `-R` 会递归地进入子目录并搜索所有的文本文件。
> 但是，我们有很多办法可以对 `grep -R` 进行改进，例如使其忽略`.git` 文件夹，使用多CPU等等。
> 因此也出现了很多它的替代品，包括 [ack](https://beyondgrep.com/), [ag](https://github.com/ggreer/the_silver_searcher) 和 [rg](https://github.com/BurntSushi/ripgrep)。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep (`rg`) ，因为它速度快，而且用法非常符合直觉。例子如下

```

# 查找所有使用了 requests 库的文件
rg -t py 'import requests'
# 查找所有没有写 shebang 的文件（包含隐藏文件）
rg -u --files-without-match "^#!"
# 查找所有的foo字符串，并打印其之后的5行
rg foo -A 5
# 打印匹配的统计信息（匹配的行和文件的数量）
rg --stats PATTERN

```

## 2.3 在目录之间高效地切换
在使用shell时，我们经常需要找到想要执行命令的目录，因此寻找到我们经常访问的目录就非常重要。
我们介绍chocolatey上的**zoxide**工具，**它和fasd工具相同，支持对目录使用针对频率和时效的排序，通过`z`指令切换到匹配的最常使用的目录，并且对其使用`cd`指令**：
例如：
```
z foo    # cd到使用频率最高的，带有foo的目录
z foo bar  # cd到使用频率最高的带有foo和bar的目录
z foo/   # cd到该相对路径
z ~/foo   # 和普通cd指令一样工作
z ..   # cd到上一级目录
z -   # cd到之前所在的目录

```

## 2.4 shell脚本基本语法
### 2.4.1 指定采用的命令解释器
在shell脚本的开头，我们需要**指定采用哪种命令解释器**，使用魔法行shebang，以`#!`开头：
```
#!/bin/bash
```
因为基本所有的解释器文件都会被放在二进制文件夹bin中，所以只需要用这条路径就行
### 2.4.1 shell的基本语法
1. shell脚本和cpp类似，都使用`;`分号进行语句的分隔：
   ```
   cd / ; ls ; pwd ;
   ```
记得空格，因为shell根据空格判断参数

2. **变量的使用**
   shell脚本定义变量有多种格式：
   定义一个变量：`变量名=变量值`，**中间不要有空格**，例如
   ```
   a=123
	```

   **将一个命令的执行结果赋给变量**：使用`$()`或`''`
   ```
   letc=$(ls -l/etc)
   letc='ls -l/etc'
	```
   使用`unset`对一个变量取消赋值：
   ```
   unset test_var
	```

  **默认变量的作用范围为当前终端，对父进程和子进程不生效**；使用`export`导出变量之后就可以对子进程产生影响：**子进程可以获得父进程的变量名称**
  ```
  export test_ver
```

# 第3讲 编辑器
## 3.1 使用vim
Vim是一个功能强大、广受程序员欢迎的基于命令行的编辑器，它的上手难度不高，只需大概20小时就能很好地使用；但对它的精通则需要很长时间的使用。
**模态编辑器的“模态（mode)”意味着Vim有多个操作模式，这是源于编程时经常需要做不同类型的事情所做的考量**

当我们启动vim时，编辑器处于**normal mode**，该模式下**不同的按键及其组合都有特定含义**，切换为不同的模式会改变按键组合的含义
**normal mode用于移动光标、阅读内容、实现从文件到文件之间的跳转等，此处按下的键不会进入==文本缓冲区==**
在normal mode下按下'i'键，就进入了**insert mode**，**插入模式是我们键入文本的地方，在此处按下的大多数键将进入==文本缓冲区==**
除此以外，还有以下模态：
**replace mode: 普通模式下键入‘r'键进入，用于覆盖文本而非插入文本，其中的差别在后面会演示**

**visual mode:  普通模式下键入’v'键进入，用于选择文本
在可视模式下又有以下模式：
visual line: 键入'shift - v'进入
visual block: 键入'ctrl - v'进入**

**command-line mode命令行模式：通过键入':'进入**
**通过‘Esc'键可以从其他模式回到普通模式**

下面我们可以试着实践使用vim了：
**打开vim的方法就是在命令行中运行’vim'程序**：
```
vim vimProjA
```
它会自动在对应目录下创建一个vimProjA文件
![[Pasted image 20240906172646.png]]
当我们打开vim时，处于**普通模式**，不妨试试键入`x`，我们发现左上角的光标并不会有任何反应，**字符没有被插入==文本缓冲区==**，因为此时的`x`代表**删除一个字符**
键入`i`键，即可进入插入模式：
![[Pasted image 20240906173113.png]]
此时输入的字符就可以被插入文本缓冲区了：
![[Pasted image 20240906173249.png]]
如果我们不想往里面插入字符了，就键入`esc`回到普通模式，此时字符会被留在上面。

vim认为使用鼠标的效率很低，所以**所有的vim功能都能通过键盘实现，这需要通过==命令行模式==完成**
在普通模式下，键入`:`就可以进入命令行模式了：
![[Pasted image 20240906173803.png]]
此时光标跳转到左下角，并显示':'
现在就可以输入命令了。类似于我们之前学习的类Unix Shell，这里本质上就是vim自己的shell，因此需要输入vim shell自己的命令

有很多命令可以帮助你实现想要的功能：
- `:q` 退出（关闭窗口）
- `:w` 保存（写）
- `:wq` 保存然后退出
- `:e {文件名}` 打开要编辑的文件
- `:ls` 显示打开的缓存
- `:help {name}` 打开帮助文档
    - `:help :w`   : 打开 `:w` **命令**的帮助文档
    - `:help w`    :  打开 `w` **移动**的帮助文档，是普通模式下按下的`w`
 - `:` + `esc`  ：返回到普通模式


(记得**别漏掉开头的':'**)

**注意，普通模式下并不是所有键都有特殊含义，例如`backspace`就没有，它的好处在于在浏览代码的过程中还能进行些许的修改**

## 3.2 Vim的缓冲区、窗口与选项卡
**Vim维护了一组打开的==缓冲区==（也就是打开的文件），同时还可以有多个==标签页==，每个标签页可以有一个==窗口==**，最大的特点在于**缓冲区和窗口之间不一定是一对一的对应关系**
因此，我们完全可以**创建一个不同的窗口，打开同一个文件（缓冲区）**，这可以通过在命令行模式下使用命令`:sp`做到：
![[Pasted image 20240906190957.png]]
它的好处在于能够让我们**在编写下面的代码时看到上面的代码，做到查看文件的两个不同部分**
要记住Vim有一种理念：**可以有多个标签页，每个标签页可以有多个窗口，每个窗口对应一个缓冲区，不同窗口对应的缓冲区可以相同，也可以没有窗口对应一个缓冲区**
而我们前面提到的`:q`命令则确切来说是**关闭当前所在窗口，没有更多窗口时退出vim**，所以当我们使用多个窗口时，**输入`:q`就能关闭当前所在窗口，，输入`:qa`则关闭所有打开窗口，退出vim**

## 3.3 普通模式究竟是用来干什么的？
Vim本身就是一种**基于命令的编程语言**，**普通模式下，不同的键位产生的不同效果可以被我们结合在一起，使得编辑文件的速度跟上思考的速度**
我们可以看看**普通模式下的按键组合**能带来什么样的效果：

* **移动（也叫"==名词=="）：使用命令在缓存中导航，它们指向文字块**
	- **基本移动: `hjkl` （左， 下， 上， 右）**
	- 词： `w` （下一个词）， `b` （词初）， `e` （词尾）
	- 行： `0` （行初）， `^` （第一个非空格字符）， `$` （行尾）
	- 屏幕： `H` （屏幕首行）， `M` （屏幕中间）， `L` （屏幕底部）
	- 翻页： `Ctrl-u` （上翻）， `Ctrl-d` （下翻）
	- 文件： `gg` （文件头）， `G` （文件尾）
	- 行数： `:{行数}<CR>` 或者 `{行数}G` ({行数}为行数)
	- 杂项： `%` （找到配对，比如括号或者 /* */ 之类的注释对）
	- 查找： `f{字符}`， `t{字符}`， `F{字符}`， `T{字符}`
     **查找对当前行生效**：f是转到本行第一个{字符}；F是当前位置之前的{字符}；t则是跳转到{字符}前一个位置；T则是{字符}的后一个位置
    - `,` / `;` 用于导航匹配
	- 搜索: `/{正则表达式}`, `n` / `N` 用于导航匹配

* **编辑（也叫”==动词==“）：普通模式下操纵编辑文本的指令，可以施动于名词**
	-  `i` 进入插入模式，直接开始编辑文本
    
	- `O` / `o` 在本行之上/之下插入行
    - 删除指令`d`键**需要与移动命令连用**：`d{移动命令}`  ，表示**删除到哪里**
    - 例如，`dw` 删除所在的整个词, `d$` 删除到行尾, `d0` 删除到行头。
     它也可以连用，`dd`代表删除所在行
	- 改变指令`c`键也需要与移动命令连用：`c{移动命令}` ，**删除并进入编辑模式使得我们可以对删除的部分进行修改**
	 它同样可以连用：`cc`代表删除所在行并进入编辑模式
    - 比如 `d{移动命令}` 再 `i`
	- `x` 删除字符（等同于 `dl`）
	- `s` 替换字符（等同于 `xi`）
	- 可视化模式 + 操作：键入`v`进入
	    - 该模式下，使用移动命令产生位置变化时，**vim会选中初始位置和最后位置两点间的所有文本块**。我们可以使用指令对它们进行编辑
	    - 键入大写`V`进入**行可视模式，它一次性选择一整行**
	    - 键入`ctrl-V`进入**块可视模式**，它支持选择**矩形块文本**
	- `u` 撤销上次更改（**进入编辑模式所作的所有更改都只算一次**）, `<C-r>` 重做
	- `y` 复制 / “yank” （其他一些命令比如 `d` 也可以复制）
	 `yy`复制当前行，`yw`复制当前单词......
	- `p` 粘贴
	- 更多值得学习的: 比如 `~` 反转选中字符的大小写

- **计数：给操作一个数字，告诉它需要执行多少次来代替多次点击**
	-  `3w` 向后移动三个词
	- `5j` 向下移动 5 行
	- `7dw` 删除 7 个词
	- 等等...

- **修饰符：稍微改变==移动命令==的含义**
	- 修饰符`i`，表示**内部**，例如`ci[`就是对'\[]'**内部的所有文字**执行`c`指令，不包括括号
	- 修饰符`a`，表示**周围**，它和`i`的区别在于**会把括号一起包括进去执行**

因此，通过结合不同的动词、名词、修饰符和计数等等，Vim编辑器的编辑速度可以达到非常惊人的程度

# 第4讲 数据整理
## 4.1 ssh
数据整理就是**把一种格式的数据转换为另一种格式的数据的过程**，在之前的课程中，我们已经接触到一些数据整理的基本技术，实际上当我们使用管道运算符的时候，就是在进行某种形式的数据整理

数据整理最典型的应用场景在于系统日志处理，我们经常需要在日志中查找某些信息，此时系统日志就是一个数据源
例如命令`journalctl`输出全部的服务器上的系统日志，我们可以使用管道符链接`grep`命令：
```
journalctl | grep -i intel
```
来获得所有包含intel（不区分大小写）的系统日志，这也是一种数据整理的过程

`ssh`是一个**加密网络协议**，主要用于**在不安全的网络上（通过命令行）安全地访问远程计算机**，例如：
```
ssh myserver journalctl
```
表示通过`ssh`协议连接到名为`myserver`的远程计算机，并且在上面运行`journalctl`命令来查看其系统日志
通过下面的方式，可以将命令日志中所有含"ssh"的项目筛选出来：
```
ssh myserver journalctl | grep ssh
```
这样的命令流程上是**将所有的系统日志信息传到电脑中，然后进行过滤**，这样就产生了额外的开销：我们不需要无关的部分，因此我们可以**直接在服务器上运行整个命令**，这需要**将命令部分用额外的引号括起来**：
```
ssh myserver 'journalctl | grep sshd | grep "Disconnected from"' | less
```
在Unix操作系统上，命令行工具`less`提供了**允许用户更方便地对大量数据进行逐页查看的方式**，我们将输出传给less，使其提供一个更好的阅读方式
我们也可以提前把信息存储到日志文件`ssh.log`，便于之后的处理
```
ssh myserver 'journalctl | grep sshd | grep "Disconnected from"' < ssh.log
```

## 4.2 sed与正则表达式
也许这样简单筛选过后我们发现还是有很多不需要的垃圾信息，这时一个名为`sed`的**流编辑器**工具就派上用场了
**`sed`是一个强大的文本处理工具**，它允许你**修改流的内容**（可以视为**文本替换**，但是是**运作在输入流**上的）
例如，当进行文本替换时，`sed`接受一个类似于`s/old-text/new_text/...`的表达式和一个文件名，表示将文件中第一次出现的`old-text`替换为`new-text`，`...`是可选的一些额外选项
当我们**希望`sed`进行批量处理时，使用管道符将数据传递给`sed`即可**：
```
cat ssh.log | sed 's/.*Disconnected form//'  #替换为空，即删除
```
这里使用到了正则表达式来匹配文本，`.`**表示任意单个字符，`*`表示匹配零次或多次前面的那个字符，因此`.*`就是任意多个字符的以上**
默认情况下，这样的正则表达式每行只会匹配一次，执行一次`sed`的替换；**若希望一行内进行多次匹配，在输入`sed`的表达式后面增加一个`g`选项**：
```
echo 'bcbzac' | sed 's/[ab]//g'
czc
```
`[]`表示执行内部任意一个元素的一次匹配，传给使用`g`的sed后就被多次执行这样的匹配了

`sed`在默认情况下只是将处理后的文本打印到标准输出，使用选项`-i`就可在源文件中进行更改了：
```
sed -i 's/a/c/g' filename.txt
```

`sed`是一个比较古老的工具，默认情况下可能无法对一些现代匹配语法进行匹配，此时使用`-E`选项使其使用现代语法：
```
echo 'abcaab' | sed -E 's/(ab)*//g'
ca
```
其中`(ab)*`中的`()`具有特殊含义：整体代表匹配多个'ab'字符串，在一些较老的工具中，它可能会把`()`视为要匹配的对象，此时需要为它们增加转义符`\(ab\)`才可能成功
正则表达式是贪心匹配的，即尽可能匹配更多的字符，在前面

正则表达式中，任何带有`()`的内容都是捕获组，括号内的内容会被保存，并且
正则表达式会很复杂，例如`(ab|bc)*`表示匹配一个或多个ab或bc，等等。因此我们需要一个**正则表达式调试工具**来帮助我们编写它们
一个在线的正则表达式工具是`regular expressions`，它支持进行正则表达式的编写、解释与报错，同时允许我们提供一些测试字符串，在原字符串上面使用不同颜色标注出匹配上的内容和捕获组

这里关于正则表达式也仅仅是简单介绍，想要掌握并熟练运用还是需要系统地对其语法进行理解学习，它是一个非常强大的工具
`sed`是逐行操作的，正则表达式也是逐行匹配的，以换行符为默认分界

## 4.3 使用其他编程语言进行数据分析
让我们回到数据整理，我们可以使用`wc`工具来进行输入文本的单词的计数，为其提供`-l`选项就是对行数进行计数
`sed`对于插入和替换功能来说是一个很好的工具；但是某些情况下其作为一个编程语言非常糟糕，因此**实际应用要结合多个工具进行使用**
例如：对于行数很多，且原数据杂乱无章，有许多重复项目的情况。
**`sort`工具帮助我们将输入的每一行按照开头的字母以字典顺序进行排列，而`uniq`工具删去重复行，为其提供`-c`选项还能进行重复行的计数**

有一个可以让我们抛弃掉`sed`和`grep`，实现很多我们需要的数据整理操作的**编程语言**是`awk`，它对于字符串处理的功能非常全面，尽管有时候不如使用其他的程序
`awk`程序接受一个可选的模式块，以及一个代码块，来指定当模式匹配时应该执行什么操作：
在代码块中，**`$0`表示整行的内容**，而一整行内容**被一个域分隔符划分为多个区域**，域分隔符默认是空格，可以通过`-F`选项进行修改；**而`$1`到`$n`就表示一行内n个区域**
模式块使用引号`''`包围，而代码块使用`{}`包围，例如：
```
#数据输入 | awk '$1 == 1 && $2 ~ /^c[^ ]*e$/ { print $2 }' | wc -l
```
代表要求匹配的该行文本第一个区域的内容为1，第二部分则必须满足`~`后面的正则表达式，对其进行代码块中的操作：打印出第二部分的内容
打印的结果作为wc计数器的输入，进行行数的统计

既然`awk`是一门编程语言，我们可以使用它进行文本的批量处理：
```
BEGIN { rows = 0 }
$1 == 1 && $2 ~ /^c[^ ]*e$/ { rows += $1 }
END { print rows }
```
这里BEGIN和END也是一种**模式块**，匹配**输入的开头和结尾**，并且执行操作：在开头定义变量`rows`，在结尾输出它
然后对每个匹配上模式块的行的第一部分进行操作，这里是累加第一部分至`rows`变量

我们还可以**对数据进行数学运算**，使用伯克利计算器程序`bc`，将一个多行数字的输出传递给`paste`程序进行合并，这需要**提供`-s`选项以进行多行数据的合并**。我们还希望合并后的结果以'+'为分隔，用来传递给计算器进行运算，于是**为`paste`提供`-d`以指定分隔符**：
```
#数据输出 | pase -sd+ | bc -l
```
这就将输出的内容进行求和

当然，还可以进行更加复杂的表达式求值，例如：
```
echo "2*($(data | paste -sd+))" | bc -l
```
求和后还增加了倍增操作

**R语言也可以被用于命令行的数据处理**，这是一门需要单独去学习的数据分析和绘制图表的语言，如果已经安装R语言程序，通过下面的命令：
```
 | awk '{print $1}' | R --slave -e 'x <- scan(file="stdin", quiet=TRUE); summary(x)'
```
其中`summary`可以打印一个向量的统计结果，将数据存放在R语言的向量中后，我们可以使用其自带的各种函数来获取许多统计信息，`summary`打印出包括最小值、中位数、最大值等的常用统计值

如果想在命令行中进行简单的数据图表绘制，可以使用`gnuplot`工具，它提供了一些能用于出图的操作：
```
#数据输出 | gnuplot -p -e 'set boxwidth 0.5; plot "-" using 1:xtic(2) with boxes'
```
这是绘制一张直方图，并且打印到标准输出

我们所讨论的数据不仅仅是文本数据，对于二进制文件的处理也非常有用
例如，下面是使用`ffmpeg`从相机中获取一张图片，将其使用`convert`转换为灰度图并压缩后通过SSH发送到远程服务器，在那里解压、存档并显示 的操作：
```
ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 -
 | convert - -colorspace gray -
 | gzip
 | ssh mymachine 'gzip -d | tee copy.jpg | env DISPLAY=:0 feh -'
```

# 第5讲 命令行环境
## 5.1 任务控制
目前为止我们使用shell的方式比较单一：输入命令，命令执行，获得某种输出
但是如果我们希望同时运行几个东西或是停止程序的运行，这样单一的使用方式就很难实现了

`ctrl+c`快捷键允许我们**停止当前正在执行的进程**，它使用到了一种名为==**信号**==的unix通信机制，当我们键入`ctrl+c`时，终端向程序发送了一个“`SINGINT`”信号，告诉它停止自己
在unix系统上使用`man signal`可以看到各种信号的描述，这里介绍几个需要知道的信号：
- `SIGQUIT`：这也是终端上**退出程序**执行的信号，键入`ctrl+/`来输出
- `SIGTERM`：在大多数情况下效果等同于`SIGINT`和`SIGQUIT`，**但并不由终端发送**
- `SIGHUP`：挂起，**如果终端被关闭时仍然在运行某些进程，那么程序会发送该信号来关闭所有这些进程**
- `SIGSTOP`：**暂停**程序的执行，键入`ctrl+z`发送
- `SIGCONT`：继续执行程序，键入`

单独讲解信号可能比较抽象，不妨看到下面这个对信号进行捕获的python程序：
```
#!/usr/bin/env python
import signal, time

def handler(signum, time):
    print("\nI got a SIGINT, but I am not stopping")

signal.signal(signal.SIGINT, handler)
i = 0
while True:
    time.sleep(.1)
    print("\r{}".format(i), end="")
    i += 1
```
它导入`signal`库来处理**异步事件**（如信号），具有一个信号处理函数`handler`，它的第一个参数`signum`是一个`int`类型，表示接收到的信号的编号，例如输入`ctrl+c`时发送的`SIGINT`编号为2，用于对不同信号采取不同措施；第二个参数`time`位置上是一个`frame`类型对象，用于获取关于程序执行状态的更多细节信息，比如这里就是时间`time`
可以看见这个信号处理函数实际上并没有使用到这两个参数，它只是输出一个“接收到信号，但没有停止”的信息而已
`signal.signal()`方法则用于**正式对信号处理程序进行注册：当程序接收到函数第一个参数表示的信号时，执行第二个参数提供的函数（函数指针）**
其他的代码则很简单了：覆盖地输出递增的i来表示增长的时间
对于这种情况，输入`ctrl+c`无法停止程序，因为该信号`SIGINT`已经被程序获取了；如果输入`ctrl+/`输出`SIGQUIT`信号，这时是可以正常停止的

有些信号是无法被程序捕获的，例如`SIGKILL`，它无论如何都会禁止程序的进行，但这并不一定是好事：如果一个进程具有多个正在进行的子进程，将该进程kill掉会导致子进程变为孤儿进程，在无父进程的情况下继续执行，这会导致很奇怪的错误

当我们运行一个进程，在最后面增加一个`&`标志时：
```
nohup sleep 2000 &
```
这代表**我们希望这个程序在后台运行**，通常与`nohup`命令一起使用：**`nohup`命令确保即使我们关闭终端，进程也会持续执行**，两个结合就说明**即使在终端关闭后，进程依然在后台持续执行**
前面提到信号`SIGSTOP`，它用于暂停我们的进程，输入`ctrl+z`发送：
```
34382@Normist MINGW64 /
$ sleep 1000

[1]+  Stopped                 sleep 1000

```
下面显示了该sleep进程被中断，前面的`[1]`是任务的编号，
使用`jobs`命令，可以获取当前所有执行或暂停的进程列表：
```
34382@Normist MINGW64 /
$ jobs
[1]+  Stopped                 sleep 1000
[2]-  Running                 nohup sleep 2000 &

```
如果我们希望**继续前面被暂停的==后台==进程**，使用指令
```
bg %n
```
其中n是希望继续的进程的编号，例如
```
34382@Normist MINGW64 /
$ bg %1
[1]+ sleep 1000 &

34382@Normist MINGW64 /
$ jobs
[1]-  Running                 sleep 1000 &
[2]+  Running                 nohup sleep 2000 &

```
这里`[1]`号进程处于running状态下了。`bg`指令相当于是**向程序发送一个继续执行的信号**
另一个相对的指令是`fg`，用于**将程序恢复到==前台==并重新连接到标准输出**
（标准输出就是前台程序打印到控制台上的这段输出）

如果我们希望停止所有或某个进程，使用`kill`指令：
```
 usage: kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... 
 or 
 kill -l [sigspec]
```
例如，不完全杀死一个进程，而是进行暂停：
```
kill -STOP %1
```
将一个进程进行挂起（删除）：
```
kill -HUP %1
```
这个指令对于使用`nohup`封装的命令不起效果，它忽略一切的挂起命令，当然其他形式的删除信号是可以的，例如
```
kill -KILL %1
```

## 5.2 终端多路复用
很多时候，我们希望一个窗口放置编辑器，另一个窗口跑程序，而且还能在另一个标签页看到各种资源消耗，虽然这可以通过打开多个窗口实现，但使用像`tmux`这样的**终端复用器**可以让你创建不同的工作空间，更快速地重新排列环境和拥有不同的会话
另一个古老的命令是`screen`，和`tmux`效果类似

`tmux`的主要思想是：会话包含窗口，窗口包含面板，这是一个层次关系
首先要记住其快捷键，它们都是类似于`ctrl+b` + `x`的组合，即需要先按下`ctrl+b`，**松开后**再按下`x`(默认情况下是b，也可以自定义映射到其他键)

当我们在命令行中直接键入
```
tmux
```
`tmux`就会启动一个新的shell，这个tmux进程与原始shell进程是分开的
进入`tmux`进程后，我们可以按住`ctrl+b+d`来暂离该会话：
```
normist@Normist:~$ tmux new -t hello
[detached (from session hello-0)]
```
输入`tmux a`即可**回到最后一个会话**，可以使用`-t`选项来指定具体的会话
```
tmux a -t hello
```

快捷键`ctrl+a+d`则是直接关闭会话，而不是暂离
```
tmux
[exited]
```

可以通过`tmux new`的形式创建一个新的会话：
```
tmux new -t foobar
```
其中`foobar`是新会话的名字，自定义

使用`tmux ls`来查看当前所有被唤起的会话
~~狗日的，快捷键时好时坏，为什么~~

## 5.3 dotfile
别名：某件事你可能需要做很多次，例如反复查看目录下文件，这时候**别名可以映射长命令为一个短的字符串 ，这将会内置在你的shell中**
别名的语法类似于：
```
alias ll="ls -lah"
```
将`ls -lah`映射为`ll`，现在你输入`ll`就能调用这个命令了。`*=*`之间不要有空格，因为`alias`只接受一个参数而不是三个
通过别名，你可以把经常打错的命令/太长的命令/命令+选项定义成一个别名，更好地满足使用的需求

关闭终端后，之前设置的别名就会失效。想要持久化别名到我们当前的环境中，需要对shell进行一些配置
许多shell程序**使用基于文本的配置文件，这些文件往往以`.`开头，因此称为`dotfile`**
**配置文件必须放在我们的`home`目录下，因此配置shell文件应该以下面这样的形式进行：**
```
vim ~/.bashrc
```
这里我们把bash的配置文件`.bashrc`用vim打开，我们可以在里面输入
```
alias sl=ls
```
这样保存以后，使用
```
bash
```
重新开始一个bash会话以后就会使用该配置文件进行配置，可以直接使用别名了

除了别名，我们还可以对配置文件使用其他配置，例如环境变量的配置
**Shell是高度可配置的，不仅仅是shell，在vim和tmux等也以文本文件的形式进行配置，你可以访问它们进行很多自定义的配置**
事实上，很多人在github上进行了配置文件的分享，我们可以查看帮助文档

对于配置文件，有些工具脚本采用**符号链接**的方式，就像我们在CSAPP中经常见到的符号解析使用的技巧那样，把外部配置文件放在同一个文件夹中，然后改变符号解析，告诉系统每当有人想要对一个文件进行读取或修改时，把请求转移到文件夹下的同名文件，通过这种方式进行dotfile的批量配置
符号链接的语法通常是：
```
ln -s <想要创建的文件的路径> <想要创建的符号链接>
```
符号链接

## 5.4 与远程服务器的交互
熟悉如何与远程服务器进行交互非常重要
处理远程服务器的主要命令是`ssh`，它就像一个安全的shell，负责将我们送到想要到达的地方或在那里打开会话
```
ssh jjgo@192.168.246.142
```
符号`@`前的部分是我们的用户名，后面则是**远程服务器的IP地址或域名**，这里使用的是IP地址
当然，我们也可以在一些**具有DNS名称**的远程服务器中使用用户名访问一个服务器，例如
```
ssh jjgo@foobar.mit.edu
```

这样输入以后，他会要求我们输入密码，输入后就为我们打开了一个shell界面
这个shell是远程服务器的shell，界面的**本质是把远程shell正在显示的内容转发到当前的界面**，这样一来我们就可以**在远程执行我们的命令了**
```
ssh jjgo@192.168.246..142 ls -la | grep primes
```
注意，使用管道和重定向时，若无像上一讲中在所有命令外增加一对引号`''`的操作，那么重定向和管道符号后面的是本地命令，意思是**将远程服务器的命令传输到本地然后进行处理**

如果多使用几次ssh，我们会发现每条指令都需要输入一次密码，这样太麻烦了，我们可以使用**ssh密钥**，它使用**非对称加密**进行创建，创建一对**公钥和私钥**，可以将公钥给服务器，从而每次进行身份验证时不使用密码，而是使用私钥
创建一对密钥：
```
ssh-keygen -o -a 100 -t ed25519
```
然后会询问你想将密钥存储在哪个文件中，默认是
```
*/.ssh/id_*
```
其中`id_*`后的星号是你输入的，这里也出现了dotfile`.ssh`，用于配置ssh
然后会要求你输入一个密码，用于加密私钥，防止私钥被泄露
私钥其实并不是复杂的二进制文件，它只是一个**文本文件**，包含公钥和一些别名，通过它我们可以知道公钥是什么

`ssh`通过`.ssh/authorized_keys`来确认哪些用户可以被允许登录。我们使用下面的命令把公钥拷贝到远程服务器的这里就可以了：
```
cat ~/.ssh/id_ed25519.pub | ssh jjgo@192.168.246.142 tee .ssh/authorized_keys
```

将本地文件上传到服务器，要通过复制实现，一个方法是使用`scp`：
```
scp note.md jjgo@192.168.246.142:foobar.md
```
把`note.md`复制到服务器上的`foobar.md`，都可以替换为文件的路径

如果需要复制多个文件，使用`rsync`指定三个选项`-avP`更好：
```
rsync -avP . jjgo@192.168.246.124:
```


# 第6讲 版本控制Git
版本控制系统是用来跟踪源代码或其他文件的更改记录的工具，帮助跟踪文件的修改历史，支持多人协作，在开发中十分重要
版本控制系统使用一系列**快照**跟踪记录文件的修改，我们可以抓拍到文件夹的所有内容，每个快照包含最高层目录的所有内容
除了修改记录以外，版本控制系统还会维护一些元数据，比如作者和提交时间
无论是团队协作还是个人开发，版本控制都是很有用的工具，它甚至可以自动识别，通过二分的方式帮你找到你的项目在经过哪次修改后导致原来能通过的测试现在不能了，非常强大

git是版本控制工具的行业标杆，我们主要介绍的就是它，我们要摆脱“我不知道git是什么工作机制，我只知道我记住几个shell命令就可以进行团队协作了”这样的思想

git的顶层抽象做得不是很好，通过命令来学习它不是一个很好的选择，虽然命令丑陋，但它的**底层设计思想**很优美，我们通过这些规整的**底层设计模型**来自下而上地进行学习它的各种概念与连接关系，从而更好地了解git

## 6.1 git的模型
git将**历史记录**建模为**某个顶层目录中的文件和文件夹的集合**，类似于我们电脑的文件目录
更正式地说，**git将一个文件夹称为树tree，而文件称为blob**，树可以包含子树和文件，即文件夹下还可以有文件夹和文件
历史则是这些内容的快照，类似于带时间戳的文件夹副本
但git用到的并不是这样的线性模式：**git使用有向无环图来模拟历史**
在git中，**每个快照被视为一个结点，每个结点都有一个父节点**，这模拟了开发时的顺序，也就是所谓的”有向“。
因为开发过程有可能是有分支的，我们可能在某个阶段有两个不同的任务，它们并行进行，从而生成两个不同的结点，各自完成了一个任务而没有做另一个任务
在完成所有分支的任务后，我们把文件的更改进行合并，合并成为一个版本，于是最后一个结点的父结点是前面分支时的多个结点
但是合并时又可能出现错误：某些情况下，git自动尝试把所有的更改合并在一起时，它不知道应该怎么进行合并，就会报出**合并冲突**的错误，来让程序员自己决定怎么合并
git也有一些工具帮助解决这些问题
在图中，也会维护一些作者、提交时间等元数据以供获取相关信息

**上面所说的”快照“的更正式名字是==提交commit==**
## 6.2 更底层的讨论
git在底层是如何**表示这些数据结构**的？用伪代码的形式来表示：
- blob是一堆字节，表示为字节数组`blob = array<byte>`
- 树则是目录名到实际内容的一个映射，表示为`tree = map<string, tree or blob>`
- 提交(图的结点)有一系列属性，1. （一个或多个）的父结点，用commit的数组表示；2. 作者名； 3. 一系列元数据；4. 快照，也就是一棵**代表相应顶层目录的树**

这就是git的历史模型，继续深入，**git如何对实际数据进行存储和寻址**？
一个对象可能是blob、tree或commit，在git中，**所有的对象都是内容寻址的**，git在磁盘上存储一系列对象，它们被保存在一个**哈希表`Objects = map<string, object>`** 中。存储一个对象就是把它的哈希值和它的指针存在这个哈希表中
**上面所说的所有”对象object“其实都是指针（索引对象真实的内存位置）**，通过哈希值在哈希表中找到该对象的指针，进而找出它在磁盘中的真实值，这就是git的磁盘数据存储
所以，**哈希值id其实也是一种引用手段，相当于是把指针用简短的方式书写。==git中不同对象之间的引用都是通过它们的id实现的==**
```
// 文件就是一组数据
type blob = array<byte>

// 一个包含文件和目录的目录
type tree = map<string, tree | blob>

// 每个提交都包含一个父辈，元数据和顶层树
type commit = struct {
    parents: array<commit>
    author: string
    message: string
    snapshot: tree
}

```
上面的`byte`、`commit`等等 **“对象”其实都是”对象的id值“**
哈希函数采用`SHA-1`哈希，它是一个160位的哈希函数，返回值为40个字符长的16进制字符串，

哈希完成的id不具备人类可读的性质，为了让我们能够理解一个对象是什么，**git在维护一组对象的同时还会维护一组==引用==——一个字符串到字符串的哈希表**
`reference = map<string, string>`
引用映射出人类可读的名字形式，我们可以通过为其**命名**进行映射的创建，例如为某次提交命名，从而为其提供一个自己能够理解的名字

**git维护的整个有向无环图是不可变的，我们只能在后面添加结点（提交）而不能改变以前的结点，但是以前的结点的引用是可变的**

## 6.3 使用git
概括地说，**所有的git命令都是对引用或对象的操作**，下面我们要介绍一下这些git命令

将当前目录转换为git仓库，在该目录下使用`git init`命令即可：
```
34382@Normist MINGW64 /d/shelllessontest/demo
$ git init
Initialized empty Git repository in D:/shelllessontest/demo/.git/

34382@Normist MINGW64 /d/shelllessontest/demo (master)
$

```
将`demo`变为一个git仓库，如果输入`ls -a`进行**查看隐藏文件夹**，可以看到：
```
34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ ls -a
./  ../  .git/
```
有一个名为`.git`的隐藏文件夹。
使用`ls .git`就能看见**磁盘上git存储的所有内部数据**了：
```
34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ ls .git
HEAD  config  description  hooks/  info/  objects/  refs/

```
其中`objects`和`refs`是两个目录，代表对象数据和引用数据

一个需要记住的命令是`git help`，它接受一个git指令名字作为输入，**打开一个显示该git指令的用法的网页**，例如
```
git help init
```

一些指令用于**查看仓库的状态**，例如`git status`告诉你仓库目前处于什么状况：
```
34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ git status
On branch master

No commits yet   #代表还没有任何提交（历史记录）

nothing to commit (create/copy files and use "git add" to track)

```

我们为这个空文件夹增加一个文件，然后**给此目录的当前状态拍一张快照，作为仓库的第一个状态**，git为创建快照提供了更加自由的接口，我们可以**自由选择需要上传哪些更改**
为此，git建立了一个称为==**暂存区**==的概念，**暂存区告诉git在下一次创建快照时应该包含哪些更改**
在创建完新的文件后，使用`git status`查看仓库状态时，会出现一个额外提示`Untracked files`：
```
34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ echo "this is just a test file" > hi.txt

34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ git status
On branch master

No commits yet

Untracked files:   #没有被追踪的文件提示
  (use "git add <file>..." to include in what will be committed)
        hi.txt

nothing added to commit but untracked files present (use "git add" to track)

```
这意味着**git注意到当前目录有一个新文件，但下一个快照会忽略掉它**
如果希望**某个文件被追踪**，那就使用`git add`指令：
```
34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ git add hi.txt

```
使用`git status`查看文件状态可以发现：
```
34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   hi.txt

```
新文件被加入了追踪，所以我们创建的下一个快照就会把加入追踪的文件添加进去了

使用`git commit`指令**添加新的快照（提交）：**
```
34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ git commit
```
这会**弹出一个文本编辑框，用于输入与本次提交相关的信息**，编写一个有用的提交信息很重要：
```
###在这一行进行提交信息的编写
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch master
#
# Initial commit
#
# Changes to be committed:
#       new file:   hi.txt
#

```
编写完以后就会提示：
```
34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ git commit
[master (root-commit) 10908c7] I just taking the Lecture 6 of The Missing Semester!
 1 file changed, 1 insertion(+)  #这里就是刚才编写的提交信息
 create mode 100644 hi.txt

```
本讲结尾会有一小节教你如何编写好的提交信息

注意到添加提交后的信息中的这一行：
```
[master (root-commit) 10908c7]
```
先不管前面的部分，后面这个十六进制数`10908c7`就是这个提交的哈希值，这个提交下又有诸如文件`hi.txt`的哈希值等内容

如果对某个结点感兴趣，使用`git cat-file -p`+哈希值 指令获得这个结点的信息：
```
34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ git cat-file -p 10908c7
tree de888c45dfce36984ac2862270b58eb56995d9e4  #这个树代表该提交下面的整体目录
author Zhihan Zeng <3438252006@qq.com> 1729848839 +0800
committer Zhihan Zeng <3438252006@qq.com> 1729848839 +0800

I just taking the Lecture 6 of The Missing Semester!

```
如果希望深挖，我们再对`tree`这一行的哈希值使用该指令，就能看见本次提交下的所有目录和文件的哈希值了

在add中使用`:/`，**添加当前仓库自顶而下的所有内容：**
```
git add :/
```
**不进行`git add`，直接就当前所有追踪了的文件进行新一轮提交的更新，使用`git commit -a`：**
```
git commit -a
```

使用`git log`指令**可视化提交历史，看到过去的提交日志：**
```
34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ git log
commit 10908c78f602600163c79c97c01e441049ec6904 (HEAD -> master)
Author: Zhihan Zeng <3438252006@qq.com>
Date:   Fri Oct 25 17:33:59 2024 +0800

    I just taking the Lecture 6 of The Missing Semester!

```
尽管提交是一个图，但是该指令还是**会线性地进行展示**，这往往会使人有些疑惑
不妨再往下进行一步修改+提交：
```
34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ echo "poor englis" >> hi.txt

34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ cat hi.txt
this is just a test file
poor englis

34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ git commit
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   hi.txt

no changes added to commit (use "git add" and/or "git commit -a")

```
显示`no changes added to commit`，因为**我们没有把新的修改加入暂存区，git不知道这次修改需要被记录**，因此还需要add一下：
```
34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ git add hi.txt

34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ git commit
[master 932e34c] i am taking an amazing lesson!
 1 file changed, 1 insertion(+)

```

在这以后，我们使用`git log`就能看见两次的提交了。
如果希望提交日志以一种更美观直白的形式展示，使用下面的用法
```
git log --all --graph --decorate
```

下面介绍提交中的一些信息：
`master`是初始化仓库时**默认创建的一个引用**，它通常代表**项目的最新版本**
```
34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ git log --all --graph --decorate
* commit 932e34c8e74b92db9f06da9dc8480b01f07fa3c3 (HEAD -> master) #指针
| Author: Zhihan Zeng <3438252006@qq.com>
| Date:   Fri Oct 25 18:12:23 2024 +0800
|
|     i am taking an amazing lesson!
|
* commit 10908c78f602600163c79c97c01e441049ec6904
  Author: Zhihan Zeng <3438252006@qq.com>
  Date:   Fri Oct 25 17:33:59 2024 +0800

      I just taking the Lecture 6 of The Missing Semester!


```
我们可以将` (HEAD -> master)`中的`master`视为一个**指向`master`分支最新一次提交的指针，随着后面提交的添加而改变为指向最后的提交**，也被叫做`main`，是一个**分支指针**
而`HEAD`则是指向**当前工作目录的指针**，也是一个引用
两者的关系是：**`HEAD`在未“分离”时，指向当前的分支（不一定是`master`，也有可能跳回去后进行分支的建立），然后这个分支指向最新的提交，相当于`HEAD`指向最新的提交；在“分离”后，它就会指向具体的某个提交了。而`master`永远指向这个`master`分支，这个分支又指向最新的提交**

差距还是有一些难以理解，往后面看就知道了
## 6.4 基本命令
一个有用的命令是`git checkout`，它的一个作用是**让你在历史记录中移动**
**为`git checkout`提供某个提交的哈希值的前几个字符，它就会找到这个提交，并且==改变当前目录工作状态==到这个指定的提交：**
```
34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ git checkout 10908c
Note: switching to '10908c'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at 10908c7 I just taking the Lecture 6 of The Missing Semester!

34382@Normist MINGW64 /d/shelllessontest/demo ((10908c7...))
$

```
下面提示的大意是：
```
你处于“分离的HEAD”状态。您可以查看四周，进行实验性更改并提交它们，并且可以通过切换回分支来丢弃在此状态下所做的任何提交，而不会影响任何分支。
如果希望创建一个新的分支来保留你所做的更改，你需要使用switch命令加上-c选项：

git switch -c <新的分支名>

或者使用下面的命令撤销该操作：

git switch -
```

和提示所说的那样，**现在的目录为你跳转到的那个提交所处于的状态**，比如输出一下这时的`hi.txt`：
```
34382@Normist MINGW64 /d/shelllessontest/demo ((10908c7...))
$ cat hi.txt
this is just a test file
```
可见它的状态还是我们这次提交时的状态。使用`git log`检查一下就会发现：
```
34382@Normist MINGW64 /d/shelllessontest/demo ((10908c7...))
$ git log --all --graph --decorate
* commit 932e34c8e74b92db9f06da9dc8480b01f07fa3c3 (master)
| Author: Zhihan Zeng <3438252006@qq.com>
| Date:   Fri Oct 25 18:12:23 2024 +0800
|
|     i am taking an amazing lesson!
|
* commit 10908c78f602600163c79c97c01e441049ec6904 (HEAD)  #注意这时的HEAD指针位置！
  Author: Zhihan Zeng <3438252006@qq.com>
  Date:   Fri Oct 25 17:33:59 2024 +0800

      I just taking the Lecture 6 of The Missing Semester!

```
`HEAD`指针指向我们所在的这个提交了，而`master`指针依然没动，前者指向我们当前处于的提交，后者指向最新的提交
如果想回到最新的提交，只需要`git checkout`+引用名即可：
```
git checkout master
```

`git checkout`实际上**会改变你当前工作目录的内容，它有可能会非常危险**，例如当你改变当前工作目录下的一个文件后进行跳转，此时它会提示你有文件被更改未保存。
若直接使用`git checkout -f`，代表忽略这些提示，强行跳转，这会导致你的更改被丢失

另一个基本命令是`git diff`，该命令**显示当前目录自上次快照以来发生了什么变化**，这在开发时帮助你了解上一次的变化
它的一个用法是：
```
git diff <结点id或引用> <希望了解差别的文件或目录>
```
例如，通过下面的方式**了解当前目录与最新版本的差别**：
```
34382@Normist MINGW64 /d/shelllessontest/demo ((10908c7...))
$ git diff master hi.txt
diff --git a/hi.txt b/hi.txt
index 1a811ce..d54a444 100644
--- a/hi.txt
+++ b/hi.txt
@@ -1,2 +1 @@
 this is just a test file
-poor englis  #显示额外增加了一行
```

或是直接`git diff <希望了解差别的文件或目录>` 来**比较当前工作目录自上一次快照以来发生了什么变化**，也就是说：**比较当前工作目录与`HEAD`指向的提交中的该文件或目录的差异**

`git diff`还能**被传入另一个哈希值或引用，代表输出==前者相比后者==所指向提交中该文件或目录的区别：**
```
git diff <hashA or referA> <hashB or referB> <file or dik> 
```

如果没有差异，它不会输出任何内容

一个值得注意的区别是：**`HEAD`指向的对象不等于当前工作目录，==当前工作目录独立于任何历史记录存在==，对当前工作目录的修改不会修改历史记录中的任何一个结点**
所以即使通过某哈希值来到当前工作目录，然后为`git diff`提供该哈希值进行查询，在你修改了当前工作目录的前提下，`git diff`也会给出差异展示：
```
34382@Normist MINGW64 /d/shelllessontest/demo ((10908c7...))
$ echo "well" >> hi.txt

34382@Normist MINGW64 /d/shelllessontest/demo ((10908c7...))
$ git diff HEAD hi.txt
warning: in the working copy of 'hi.txt', LF will be replaced by CRLF the next time Git touches it
diff --git a/hi.txt b/hi.txt
index d54a444..6a4ad5d 100644
--- a/hi.txt
+++ b/hi.txt
@@ -1 +1,2 @@
 this is just a test file
+well

```
下面的分支与合并一节会让我们更加清晰地了解：`HEAD`、`master`和当前工作目录的区别

## 6.5 分支与合并
在我们的工作目录下使用`git checkout <file or dik>`，会**丢弃该文件，并且把该文件的内容设置回`HEAD`所指向的快照的状态**
```
34382@Normist MINGW64 /d/shelllessontest/demo ((10908c7...))
$ git checkout hi.txt
Updated 1 path from the index

34382@Normist MINGW64 /d/shelllessontest/demo ((10908c7...))
$ cat hi.txt
this is just a test file

```
可以看见`hi.txt`的后面没有我们之前加的"well"了

回到`master`指向的提交状态，编写下面的程序`vim animal.py`
```
import sys

def default():
    print("hello")

def main():
    default()

if __name__ == '__main__':
    main()

```
它只输出一个hello，现在我们把它加入暂存区并生成快照
```
git add animal.py
git commit
[master 7c0699b] this is the second part of today's lesson
 1 file changed, 11 insertions(+)
 create mode 100644 animal.py
```

所以我们目前的历史记录结构类似于`O->O->O <-master&HEAD`，下面演示如何**通过Git的分支实现==并行开发==：**
**`git branch`命令用于访问分支，不加任何选项和参数地运行它会列出本地仓库中存在的所有分支：**
```
34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ git branch
* master
```
在后面使用`-vv`选项会提供更详细的信息

**为`git branch`提供一个分支名，它会创建一个新的分支：**
```
34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ git branch cat

34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ git branch
  cat
* master

```
这个名字是**指向我们当前所在位置的快照的==引用**==
此时，调用`git log`会显示：
```
 commit 7c0699b0b74b67ceb0d2c7b392845f692da3cd93 (HEAD -> master, cat)
```
**由于`HEAD`指向当前工作目录的分支，分支指向最新的提交，所以我们处于`master`分支时出现`HEAD->master`**
而若我们跳转到`cat`分支：
```
34382@Normist MINGW64 /d/shelllessontest/demo (master)
$ git checkout cat
Switched to branch 'cat'

34382@Normist MINGW64 /d/shelllessontest/demo (cat)
$ git log --all --graph --decorate
* commit 7c0699b0b74b67ceb0d2c7b392845f692da3cd93 (HEAD -> cat, master)

```
这里就有`HEAD->cat`了，可见 **`HEAD`指向当前工作目录所在分支** 的性质，且**即使是同一位置，所在分支也会不同**

现在，让我们在`cat`分支下修改一下`animal.py`：
```
import sys

def cat():
    print('meow')

def default():
    print("hello")


def main():
    if sys.argv[1] == 'cat':
        cat()
    else:
        default()

if __name__ == '__main__':
    main()

```
进行了命令行参数的判断，输入`git diff`查看当前目录与上次提交的不同之处可以看出这个信息
然后加入缓冲区，将其作为提交更新：
```
git add animal.py
git commit
```
让我们再使用一次`git log`：
```
34382@Normist MINGW64 /d/shelllessontest/demo (cat)
$ git log --all --graph --decorate
* commit 7768f2d931fbfd4c7097cbfad9146271be34a552 (HEAD -> cat)
| Author: Zhihan Zeng <3438252006@qq.com>
| Date:   Fri Oct 25 22:20:50 2024 +0800
|
|     add a cat
|
|     meow
|
* commit 7c0699b0b74b67ceb0d2c7b392845f692da3cd93 (master)
| Author: Zhihan Zeng <3438252006@qq.com>
| Date:   Fri Oct 25 22:02:55 2024 +0800
|
|     this is the second part of today's lesson
|
* commit 932e34c8e74b92db9f06da9dc8480b01f07fa3c3
| Author: Zhihan Zeng <3438252006@qq.com>
| Date:   Fri Oct 25 18:12:23 2024 +0800
|
|     i am taking an amazing lesson!
|
* commit 10908c78f602600163c79c97c01e441049ec6904
  Author: Zhihan Zeng <3438252006@qq.com>
  Date:   Fri Oct 25 17:33:59 2024 +0800

      I just taking the Lecture 6 of The Missing Semester!
```
**过长时自动使用`less`阅读器，输入`q`退出**
在之前的基础上增加一个`-oneline`选项，让我们简单地了解：
```
34382@Normist MINGW64 /d/shelllessontest/demo (cat)
$  git log --all --graph --decorate --oneline
* 7768f2d (HEAD -> cat) add a cat
* 7c0699b (master) this is the second part of today's lesson
* 932e34c i am taking an amazing lesson!
* 10908c7 I just taking the Lecture 6 of The Missing Semester!

```
可以看见目前`HEAD`指向`cat`，现在回到`master`分支，编写`dog`分支：
