# Lecture 1.  概述（CSAPP中有更详细的介绍）
## 1.1 向量化操作
想象这样一种新的指令类别，它可以一次在8个值上执行操作处理，这就是所谓的SIMD扩展所支持的操作。（SIMD：单指令多数据流技术）
它们被称为**AVX：高级向量扩展**，我们主要讨论单精度浮点数，这样的指令可以一次处理8个这样的4字节值（一共$8\times 4\times 8=256$位）
在代码中使用相关的语法，本质上是通过程序告诉编译器它应该生成的汇编语言和机器指令是什么，例如：
使用泰勒展开计算sinx的值
```c
#include <immintrin.h>

void sinx(int N, int terms, float* x, float* result) {
    float three_fact = 6; // 3的阶乘
    for (int i=0; i<N; i+=8) {  //每次从x中取出8个值，因此步长为i8
        __m256 origx = _mm256_load_ps(&x[i]);  //从内存中加载8个32位浮点数到向量寄存器，每个值是给出的内存地址开始连续的8*4=32字节中所存储的8个四字节数
        __m256 value = origx;   //__m256代表包含8个4字节浮点数的向量
        __m256 numer = _mm256_mul_ps(origx, _mm256_mul_ps(origx, origx));
        //将两个向量寄存器（__m256）中的值相乘
        __m256 denom = _mm256_set1_ps(three_fact);
        float sign = -1;

        for (int j=1; j<terms; j++) {
            // value += sign * numer / denom
            __m256 tmp = _mm256_div_ps(_mm256_mul_ps(_mm256_set1_ps(sign), numer), denom);
            value = _mm256_add_ps(value, tmp);

            numer = _mm256_mul_ps(numer, _mm256_mul_ps(origx, origx));
            denom = _mm256_mul_ps(denom, _mm256_set1_ps((2*j+2) * (2*j+3)));
            sign *= -1;
        }

        _mm256_store_ps(&result[i], value);
    }
}
```

这里对于数据的衡量单位是位数而不是字节数，因此`__m256`代表的就是$8\times 4 \times 8 = 256$位的向量（一个向量有8个数）
后面的各种形如`__mm256_add_ps`、`__mm256_mul_ps`等操作都是对于这样的向量数据类型而言的操作扩展，允许我们在向量的每一位上执行例如加法、乘法的操作

它产生的汇编代码类似于：
```
vloadps  xmm0, addr[r1]
vmulps   xmm1, xmm0, xmm0
vmulps   xmm1, xmm1, xmm0
...
...
vstoreps addr[xmm2], xmm0
```
执行操作的`vmulps`使用两个寄存器作为源，第三个寄存器作为目的，实现向量乘法。XMM寄存器是一个完全独立的寄存器集，用于处理这些向量操作
不过从CSAPP相应章节中也可以看出，现在的浮点数操作也会使用XMM寄存器，但只使用该寄存器的低4或8个字节

我们可以让像GCC这样的编译器自动进行向量化处理优化，加上一系列的提示或者别的标志来让它把你的代码向量化，但是**只有非常结构化，精心编写的代码才能被自动地向量化**，编译器对于这样的优化是很保守的

像上面那样，对于向量中每个值都执行一样的操作的代码很容易被向量化。但如果在这些操作中加入了一些条件判断呢？
例如，在执行操作前对某个值进行判断，根据是否满足条件，执行两种不同的操作
```c
float x = A[i];
if (x > 0) {
	float tmp = exp(x, 5, f);
	tmp *= kMyConst1;
	x = tmp + kMyConst2;
}
else {
	float tmp = kMyConst1;
	x = 2.f * tmp;
}
```
在SIMD技术中，它会**为向量中的每一位数据生成一个01掩码，代表该位置上的数值经过条件判断后是否正确**，然后使用这组掩码来决定每个位置上的执行：**对于掩码为真的地方，继续执行下面的操作，而不执行else中的操作；对于掩码为假的地方，禁止执行下面的操作，但执行else中的操作**
（对执行if下面的和else下面的语句的控制其实是通过反转一次掩码实现的）

最坏的情况下，八个位置上的元素情况各不相同，我们无法跳过条件控制的任何一个语句块，这时候就浪费了其中$\frac{7}{8}$的计算能力，不过经过这样的分支之后，它们被合并在一起继续运行，保持原有的并行性
这就是所谓的“一致性”，代表每个数值作相同操作的程度。而任何偏离这些相同的操作的行为都称为分歧

向量这样的结构允许我们对给定字节数进行字节级别的操作，例如与或，算术和条件判断。对于`__m256`这个大小的向量，可以同时对4个双精度浮点数或8个单精度浮点数执行操作，而对于更后推出的例如AVX512，向量的位数越来越长，不过普遍认为512位就是足够的长度了
无论如何，要记住**必须明确告知硬件执行这些向量操作**，这需要聪明的编译器或耐心的程序员
也可以检查`.s`文件的反汇编器生成的代码来确保代码被向量化了


## 1.2 GPU
GPU提供了一种被称为SPMD单程序多数据的模型，和单指令多数据类似，它代表**程序的不同部分可以做不同的事情**，底层上还是通过SIMD来执行大部分逻辑的
GPU的SIMD在更大层面——数据上进行操作，它会计算如何将值分配到每个块中，现代GPU中的块往往由32个值组成，这样的块的大小也称为SIMD宽度，范围从8到32不等，往往是32

## 1.3 延迟和吞吐量
目前为止，我们能够让芯片上的数据操作执行得更快，内存变得更大，但有一件事情随着时间变化并没有获得很大改善：从内存中获取一个字节到处理器中所需的时间，这就是所谓的延迟和吞吐量所评判的对象

一个典型的问题是硬件层面上，如果我们试图读取一个不在离得最近的缓存中的数据，这就会产生停顿，它停止处理器直到数据被传送到缓存中，这样的问题就是延迟问题
缓存的思想也正出于此，我们将数据取到更小的缓存中，较大的缓存用于共享，较小的缓存往往是私有的，我们基于这样的内存结构在多个不同核心之间传递数据，这能改善延迟和带宽问题

## 1.4 预测
硬件领域经常做的一件事是预测你将要做些什么，例如对于一个数据的读请求，它会基于这个击中的内容，预测你还会取到内存位置在它附近的地方的数据，然后将它预取到缓存中，以降低以后读取的延迟

在需要等待读取的时间里，对于一个进程中的不同线程，我们完全可以交织处理的过程，在延迟时执行其他线程的指令
为了实现这样的切换，我们需要有：足够多的ALU（算术逻辑单元）、存储执行上下文（寄存器状态、栈状态等信息）的存储器
这样一来，通过在等待的空白时间中进行其他指令流的复用，能够有效减少延迟带来的性能损失，这也就是所谓的**提高吞吐量以降低延迟**，前者更容易实现

操作系统通过线程的映射来将这些调度传递给硬件，同时硬件也会执行一些低级的判断

# Chapter 2. 并行计算的软件实现

## 2.1 ISPC并行语言

ISPC是英特尔开发的一门并行语言，可以在其Github主页[ISPC](http://ispc.github.com/)上进行下载，它提供了一种称为**SPMD单程序多数据**的抽象
SPMD意味着你有一段相同的代码，被一些逻辑上的“线程”执行或不执行，我们只是为它们提供代码，这些独立的“线程”会单独地在不同的数据片段上执行它，这就是一种常见的编写并行代码的方式

以使用泰勒展开计算多个sin函数值的程序为例，我们希望同时计算多个：
```c?
--------------sinx.ispc  //文件后缀为ispc
export void sinx(
	uniform int N,
	uniform int terms,
	uniform float* x,
	uniform float* result)
{
	for (uniform int i = 0; i < N; I += programCount) {
		int idx = i + programIndex;
		float value = x[idx];
		float numer = x[idx] * x[idx] * x[idx];
		uniform int denom = 6;
		uniform int sign = -1;

		for (uniform int j = 1; j <= terms; j++) {
			value += sign * numer / denom;
			numer *= x[idx] * x[idx];
			denom *= (2*j + 2) * (2*j + 3);
			sign *= -1;
		}
		result[idx] = value;
	}
}
```
看上去使用ISPC编写的代码和c代码差不多，它们被保存在`.ispc`为扩展名的文件中，这样的文件可以