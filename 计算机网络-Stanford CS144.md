# Lecture 1.  网络程序

## 1.1 双向可信比特流连接
连接指的是两台不同位置上的计算机（包括手机、服务器等等）能够互相传输数据
现代计算机中主要采取的通信模式模型是**双向可信比特流连接**，在两台计算机之间传输数据：
- 一方可以阅读另一方所写的内容
- 双向通路
- 除非连接被破坏，否则都是可信的
![[Pasted image 20250901214519.png]]
当然，还有其他的通信模式，会在课程的后续部分进行介绍，但这种通信模式是最常用的

### 1.1.1 万维网（HTTP）
在了解通信模式后，World Wide Web万维网就是一个例子，它采取超文本传输协议HTTP进行通信（URL中的`http://`部分就指示了这一点）
关于HTTP的细节在后面的课程中会讲解，现在概述来说，http被设计为一种以文本为中心的程序通信方式，例如在浏览器中输入`http://www.stanford.edu`，它就会向名为`www.stanford.edu`的服务器打开连接并发送一个获取站点根页面的请求
即：在http中，客户端打开与服务器之间的连接，然后向服务器发送命令，最常见的是`get`，它请求一个页面；
而服务器则接收请求，检查它是否有效以及用户是否可以访问，并且向`get`发送一个**用数字代码标识的响应**，例如代码200标识请求已被接受，代码
同时，服务器的响应还包括了用于描述主页面的超文本，例如`put`，`delete`，`info`等等

因为http是以文档为核心的，它全部由ascii编码，人类可读，例如
```http
response: "HTTP/1.1 200 OK"
```

## 1.2 BitTorrent
bittorrent是一个允许人们共享和交换大文件的程序，与Web不同，在Web中，客户端从服务器请求文档；而在bittorrent中，客户端从其他客户端中请求文档，因此单一客户端可以并行地从许多其他客户端中请求。
bittorrent将文件分解成被称为“片段chunk”的数据块，当一个客户端从另一个客户端下载数据块时，另一个客户端需要告诉它“我有你需要下载的文件”
这些协作客户端的集合被称为“群组swarms“

除了群组，BitTorrent的传输方式和HTTP相同，都是双向可信比特流，但是会更加复杂一些：当客户端想要下载文件时，它必须具有一个称为torrent（种子）文件的东西，使用这个文件进行下载。torrent文件具有你要下载的数据文件的一些信息，它还向bittorrent指示了谁是该torrent的跟踪器tracker
跟踪器tracker是一个持续跟踪的节点，用于跟踪信息：当你是与其他客户端建立连接的客户端时，只需要向跟踪器请求，它就会向你返回一个客户端的列表（群组）。当一个新客户端加入群组时，跟踪器也会向你报告

## 1.3 Skype
skype是一个专有系统（系统内部细节曾经加密，但是被反向工程得出了），用于流行的语音、聊天和视频服务。
在最简单的模式下，当我们在skype中向别人呼唤(call)时，是一个简单的客户端-服务器交换，类似于HTTP：呼唤者向接受者请求打开连接，接受者向呼唤者打开连接后就可以交换数据了。
然而，和网络不同，在Skype中，并不是客户端-服务器，而是客户端-客户端，即没有专用服务器，而是两台个人电脑之间互相传送数据。
这个区别重要地影响了skype的使用方式，它的复杂性源于**NAT：网络地址转换器**，它是现在随处可见的一种设备，例如小型家用无线路由器就是
当手机连接到互联网时，手机实际上是在NAT之后的（后面会详细介绍），我们只需要有一个“只要通过NAT，我们就可以打开到互联网的连接，但互联网上的其他节点无法轻易与我们建立连接

因此，在skype中，两台个人电脑由于安全原因，均会处于NAT之后，此时需要一个中继服务器（不经过NAT，暴露在网络中的）进行申请的中继

# Lecture 2. 四层网络模型

在第一讲中，我们看到了很多网络应用程序，创建可靠的通信模型需要许多组件协同工作，而不同程序的信息类型、数据传输速度也各不相同。但是，在传输方式方面，所有的网络程序都在发送和接收数据层面上存在相似之处，并且都希望和数据在互联网上真实的传输路径相隔离

早期的互联网先驱创建了四层互联网模型，以描述其组成互联网的层次结构，从而应用程序可以直接使用已有的部分，而无需从头开始创建。所有的四层都是为了最终实现应用程序，进行可靠的主机间通信而存在的
![[Pasted image 20251019195858.png]]
每一层都负责不同的部分，并且每一层都建立在下面一层的服务之上，因此我们自底向上进行介绍

1. Link层：互联网由终端主机（end hosts）、链路（links）和路由器（routers）组成，数据沿着链路和其转向进行逐跳（hop）传输。数据传输的形式是数据包，它是一个自包含的单元，含有需要传输的数据。数据包头部的信息告诉网络应该将数据包传递到哪里，以及它来自哪里等 
		链路层的工作是每次在一个链路上传输数据，最典型的例子是以太网和wifi
2. 网络层：其工作是端到端地传递数据包，从数据来源到其在互联网上的目的地。数据包是网络中的重要组成块，它的头部储存了关于数据包的源和目的的信息
		网络层将数据包交给链路层，让链路层传输数据包，一个link的另一端就是路由器router，路由器的链路层接受来自链路的数据包并将其传递给路由器内部的网络层，路由器内部的网络层会检查数据包的目的地址，然后将数据包逐跳路由到目的地（传输回链路层，传递给下一个路由器，直到它到达目的地的网络层）
		网络层无需关心链路层是如何通过连接发送数据包的，实际上每种设备的链路层的工作方式也不同，就像是wifi和以太网的链路层工作完全不同，只是提供了相同的接口以供上一层使用
		当我们向互联网中发送数据包时，需要使用互联网协议（IP），它会尽可能地将数据从一端运输到另一端，但是**并不作任何保障**，并且可能会丢失数据包、顺序改变、损坏数据包等，没有安全保证
3. 传输层：**IP并不负责保证数据包的有序安全**，传输层是运行在IP之上的协议，负责将数据包按顺序且无损地传递到应用程序中。最常见的传输层是**TCP传输控制协议**，确保数据包从互联网的一端按顺序正确地传输到另一端的应用程序，若网络层出现了数据包的丢失，那么TCP会在需要的情况下**多次进行传输**，并且把数据包**按照正确的方式排列**（出现乱序或者重复的原因是数据包沿着不同路径被传输到应用程序中了）；
	一些应用**无需可靠的传输**，例如视频会议更注重实时性，则可以使用更简单的**用户数据包协议UDP**，它是一种将应用程序数据捆绑在一起进行传输的传输层，**只提供顺序的保障**
4. 应用层：许多不同的应用程序通过使用明确定义的方式API重用传输层，它们通常需要两个端点之间的一个**双向可靠字节流**，使用应用程序自己的协议来定义数据字节流的语法和语义。
	例如，在web客户端向web服务器请求页面时，客户端发送GET请求，这个请求命令是**超文本传输协议HTTP**的命令之一，它规定GET命令与URL一起作为ASCII字符串发送给正在请求的页面，从应用层角度上来看，GET命令会直接发送给另一端的Web服务器应用程序，无需知道底层重新传输了多少次；从整体上看，该命令被交给传输层的TCP，调用更加底层的API进行
![[Pasted image 20251212134210.png]]

另外，一些需要注意的地方：
1. IP经常被称作互联网的薄弱环节，我们想使用互联网就必须使用互联网协议；但链路层link的选择却不止一种，IP可以在不同的链路层上运行，例如以太网、WIFI、DSL、3G4G5G等等；IP之上的传输层也可以使用多种类型的，除了TCP以外还有UDP、RTP等；同样地，应用层除了http，也有ssh、smtp、ftp等协议可以选择
2. 在早期，ISO提出了七层网络模型，但如今已经被四层模型替代了（但仍有人会使用），它们之间的对应关系如图
![[Pasted image 20251212134800.png]]

如前所述，网络模型的每一层都向上层提供服务，为了正确使用它们，我们必须深入了解每一层所提供的服务和其所依赖的服务
## 互联网协议（IP）底层服务
网络层是互联网中最重要的一层，实际上它就是互联网，因为我们使用互联网时必须通过互联网协议IP进行数据传输和接发，这一节介绍IP所提供的底层服务
IP Datagrams（互联网协议数据报）由一个数据头和一些数据组成。当传输层有数据需要发送时，传输层会将传输段数据传递给网络层，由网络层将其封装为IP数据报（内的传输段），并加上**目的IP地址**，IP的目的是把数据报传输到互联网的另一端
接着，IP首先需要找到通向第一个路由器的链接link，为此IP将数据报发送到链路层，将其放入链接框架中（例如：以太网数据包），将链接框架（link frame）发送到第一个路由器
![[Pasted image 20251212194353.png]]


IP服务从源主机到目的主机发送数据报，传输过程是不可靠的，**网络不保存任何与数据报相关的底层流状态**，它可以通过以下四个特性来描述：
1. 数据报服务：当请求IP为我们发送一些数据时，它会首先创建一个数据报，将数据放入其中。一个数据报是基于其报头信息在网络上单独路由的数据包，它是自包含的。
	报头包含**目的主机的IP地址**，简称为**IPDA**，每个路由器的转发决策都基于该IPDA；此外，数据报头还包含一个IP源地址，简称IPSA，表示数据包来自的地方。
	数据报在网络中**逐跳路由**，从一个**路由器**到下一个路由器，沿着源地址到目的地址的路径传输，**每个路由器都有一个独特的IP地址**，各自包含一个**转发表**，通过匹配表上给定的目标地址确定下一步要发送数据报的位置
	路由器并不知道整个传输地址，只使用数据报的目的地址来索引自己的转发表以使其能够将数据报转发到下一跳

2. IP是**不可靠**的：IP无法保证数据包会被传送到目的地，数据包的传输可能出现延迟、顺序错乱或压根没有送达，或是因为路由器的问题导致重复传送
3. IP会尽力进行传输：它不会因为传输过程中的问题就随意丢弃数据包，**只在必要时可能丢弃**，如路由器的数据包队列因堵塞填满时不得不丢弃下一份到达的数据包。请注意，这时IP不会告诉源地址数据包被丢弃了，因为IP不保证错误不会发生，也并不检测它们
4. 通信服务的无连接性：**IP不维护没有任何与通信相关的状态**，我们称该通信服务是无连接的，因为它不通过建立与通信相关的端到端状态来开始，只是进行路由转发

IP地址非常简单，因为互联网上的每次通信都需要使用IP服务，需要保持网络**简单、最小化、快速且维护成本低**，通过将专用硬件使用简单的形式构造，以使其易于更新和维护
**端到端原则**：只关注能否**正确地在端点处实现功能**，将功能和智能主要放置在**端点处**（源计算机和目的计算机），从而使得改进主要发生在软件上，而非硬件上。
端到端原则应用范围很广，例如传输层中端点在不可靠的IP网络服务上建立可靠的通信服务的方式（后续内容）
另外，IP服务也**需要允许从多种可信或不可信的服务中被构建使用**，如果强制要求IP在出现问题时重传，其泛用性反而不理想，因为实时应用更加追求时效性而非可靠性；且IP需要被各种链路层进行使用，因此其基于的假设和要求必须很少

### IP服务模型的额外细节
除了基本的、不可靠的、无连接的尽力数据报服务之外，IP也提供了一些其他的精心选择的服务，它们在最基本的服务之上进行了适当的拓展，本节会介绍其中的五个
1. IP会试图**防止数据包永远循环**。我们知道IP路由器通过转发表逐跳地跨越互联网转发数据包，此时转发表可能出现错误，导致数据包的转发路径出现循环。与其复杂地阻止循环的出现，IP选择在数据包中添加一个跳数字段，位于数据包的头部，称为**TTL（生存时间）字段**，从类似128的数字开始起算，每经过一个路由器就被递减，若TTL字段到达0，IP认为该数据包进入了循环，直接**丢弃该数据包**
2. IP在数据包过长的时候会**将其分成片段**：IP被设计为能够在各种链接上运行，大多数链接类型都有它们能够传输的数据包大小的限制，例如以太网只能传输小于1500字节的数据包，若一个应用程序需要发送大于1500字节的数据，则需要在发送IP数据报走之前将其分割为1500字节大小的数据块。然而，在数据报传输的路径中，它**可能又要经过一个传输限制更小的链接**，此时**连接两个链接的路由器**需要将数据分成更小的数据报。IP提供一些头部字段来帮助路由器将数据报分割成两个自包含的IP数据报，并且能够提供主机能将数据重新组装的信息。（后续会详细介绍）
3. IP使用头部校验来减少数据报被路由到错误目的地的概率：IP数据报头中包含一个校验和字段来试图保证数据报被传送到正确的目的地中，以避免数据安全问题
4. 目前有两个版本的IP正在被使用，这两个不同的IP在后续会学习到：
	1. IPv4：被超过90%的主机使用，使用32位地址，在地址逐渐被用尽之后，逐步过渡到IPv6
	2. IPv6：使用128位地址
5. IP允许向数据报头添加新的字段，这是个具有双面性的功能，它一方面允许添加原始协议没有的额外的重要特征，但因为处理新的字段需要路径上的路由器具有额外的功能，打破了简单最小转发路径的原则

### IPv4数据报头
IPv4数据报头组成示意图如下所示，字段长度存在不同，但头部总长必须是四字节的倍数。将其使用32位的字进行绘制，其中位0是最先被发送到导线上的数据：
![[Pasted image 20251218205717.png]]
1. 灰色部分就是数据报头部结构，其中具有许多不同的字段：
	1. Destination/Source IP Address：目的IP地址和源IP地址
	2. Protocol ID：协议ID，它用于指示上层协议是什么（例如TCP协议=6），从而告诉我们数据字段Data中包含什么内容。本质上允许了目的主机对到达的数据包进行解复用处理（将数据分发到不同协议的处理模块代码中进行处理），不同传输协议具有各自唯一的协议ID
	3. Version：IP协议的版本号，只有IPv4和IPv6
	4. Total Packet Length：总数据包长度，报头和数据的总字节长度
	5. TTL：时间生存字段，避免数据包的分发进入循环，TTL到达0时该数据包被销毁
	6. 第二行Packet ID - Flags - Fragment Offset：当一个数据包的长度大于链路的最大接收长度时，需要进行分段，此时路由器会基于数据包ID - 标志 - 片段偏移量，将IP数据包分割位更小的自包含片段，分段的具体工作原理在后续会学到
	7. Type of Service：服务类型，向路由器指定该数据包的优先级和服务质量
	8. Header Length：数据报头长度，数据报头可能会有可选的额外字段
	9. checksum：首部校验和，检测头部是否发生传输错误
	10. Option：可选的额外选项；PAD：填充，以确保头部长度是四字节的倍数

# Lecture 3. 数据包的一生
互联网四层模型中，应用层发送和接收数据流；传输层将数据流分成可靠传递的数据段，用于传输给另外一台电脑上运行的应用程序；网络层则将传输层的数据段传递给另外一台计算机

来看一个实际例子：网络浏览器和服务器之间的数据传输
![[Pasted image 20251218215004.png]]
传输层使用TCP传输控制协议，在它的典型操作中，存在一个客户端和服务器：服务器监听连接请求；客户端发送连接请求，由服务器对此做出响应以建立连接。
这个过程的具体操作不详细说明，但事实上，整个交换流程需要三条报文，称为**三次握手**：
1. SYN：客户端发送同步报文到服务器，请求建立连接
2. SYN ACK：服务器确认客户端的同步请求，同时发送自己的同步请求
3. ACK：客户端确认收到服务器的同步请求，连接建立完成

网络层负责将数据包传递到计算机，传输层负责将数据传递给应用程序，因此从网络层的角度来看，在同一台计算机上发送到不同应用程序的数据包都是相同的，这意味着要向另一个程序打开TCP流需要两种地址：
1. IP地址：网络层所使用的地址，网络层需要它来将数据包传递给目的计算机
2. TCP端口：它告诉计算机软件应该将数据传递到哪个应用程序中
web服务器通常在TCP端口80（TCP port: 80）上运行，因此当打开与Web服务器的连接之后，我们将IP数据包发送到运行Web服务器的计算机上，此时目的地址是计算机的IP地址；而IP数据包具有TCP段，它标志着TCP端口的值，也就是80

在这之后，由于不可能有直接连接两台计算机的路径，我们需要让客户端连接到一台中间计算机——路由器，而该路由器本身又连接着其他的路由器，我们使用“跳”来描述两个路由器之间的链接

当我们的客户端正在使用WIFI网络时，第一跳就是无线设备到WIFI接入点，接入点通过有线连接来与更广泛的互联网相连，所以它又沿着这个有线的跳转发客户端的数据包
一个路由器可以连接多个链路，当数据包到达时，由路由器决定将其发送到哪个链路上，而且路由器也具有IP地址，它有可能就是接收方，因此也有可能直接交付给它自己的软件（例如，使用TCP登录到自己的路由器上的时候）

路由器通过**转发表**来决定将数据包分发到哪个链路上：
![[Pasted image 20251218221619.png]]
转发表由一组**IP地址模式**和**传输到每个模式的链路**组成，其中，**默认路由default**在边缘网络中格外有用：一个路由器的默认路由链接着通向更大范围网络的链路，其他链路则规定了一个特定范围，当目的IP地址不在这个范围内，路由器就应该将其发送到更大范围的互联网中。
具体来说，转发表的匹配遵循**最长前缀匹配**原则：路由器会选择与目的IP地址匹配度最高（前缀最长）的条目。只有当所有具体条目都不匹配时，才使用默认路由（前缀长度为0）。

我们可以使用一个叫做wireshark的**网络抓包工具**来看到网络浏览器是如何向目标web服务器使用三次握手打开tcp链接，然后使用HTTP GET请求服务器的数据响应。
当发生数据包交换之后，使用traceRoute工具，能够看到数据包通过互联网的路径
```bash
traceroute -w 1 [网址]
```
一个数据包传输的时间很短，这些工具让我们能够看到互联网上实时发生的运行情况

# Lecture 4. 分组交换理论
## 4.1 分组交换定义
分组交换理论是互联网构建早期一个简单而又革命性的理论，在本节会从高层次介绍其理论和优势

数据包：一个自包含的数据单元，携带了到达目的地所需的必要信息
分组交换：将数据分成离散、自包含的数据块，一个数据块就是一个数据包，它们每个都携带足够的信息使得网络可以将该数据包传递到其目的地
![[Pasted image 20251223194831.png]]
在最简单的分组交换形式中，每个分组（数据包）是单独独立地进行路由的，即路由器会单独根据每个分组的信息进行分发
分组交换的简单定义：对于每个到达的分组，独立地选择其外向链路，若对应链路空闲，直接发送它；否则保留该分组，之后再使用

自路由/源路由：每个分组都包含了一个明确的路由，它指定了沿途每个数据包交换机的ID，直到目的地，源指定了路由的每一跳
![[Pasted image 20251223200511.png]]
互联网支持源路由策略，但通常会关闭它，因为它会带来安全问题
源路由的一种简单的优化方式，也是今天互联网主要采样的方式，是在每个交换机中放置少量的状态，从而告诉交换机下一跳应该将数据包发送到哪个链路
具体来说，每个交换机保留一个目的地址和下一跳的表，当它接收到一个数据包时，在表中查找地址并将数据包发送到适当的下一跳，从而使得数据包只需要携带目的地址

## 4.2 性质
分组交换具有两个很好的性质：
1. 简化转发过程：交换机可以为每个数据包做出个体化、本地化的决策，它不需要在检查数据包时保存额外的数据包中的状态；也不关心不同数据包之间的关系，即使许多数据包同为某更大的传输或协议的一部分。它们只需要转发
2. 多方能够共享链路：多个数据源或目的可以共享一条链路，例如两台电脑共享同一个无线路由器，链路尽管根据使用情况会出现速度不同，但仍然被共享

流：通信时往往不止发送一个数据包，流是属于同一**端到端通信**的数据报集合，例如：TCP连接
分组路由不需要交换机了解和保存每个流的状态，因为这会导致大量状态的难以管理和保存，性能不佳且昂贵；同时确保交换机不会因为端点出故障时影响其行为，它只负责接收和转发

数据流量是突发性的，用户可能随机地在不同时间不同地点进行数据传输，因此发送和接收数据速率并不固定，使用量会随着时间推移而跳跃、波动、升降
整体来看可能存在一些规律，例如下午高峰凌晨低峰，但从小时间尺度上看，突变通常是独立随机发生的
统计复用（异步时分多路复用）：将单一资源使用概率或统计方式分享给多个用户。具体来说，每个用户根据其他用户的使用情况，能够获得资源的统计份额，即只对需要传送数据的终端分配时隙以提高信道的利用率

# Lecture 5. 分层原则与封装原则
## 5.1 分层原则
在四层网络模型中我们看到很多次分层原则，这是一种在计算机网络出现以前就存在的设计原则

分层：将系统组织成若干个独立功能组件或层次的组织方式，每一层分层且按顺序进行通信，即只与直接上下层有通信接口，每一层向上层提供明确定义的服务，并使用下层提供的服务，具有自己的私有处理
优势：
- 模块化
- 服务定义和抽象清晰
- 可复用、可持续独立发展改进
- 关注点分离
- 能够支持**点对点通信**

> [!NOTE]
> 层次设计在计算机系统中应用很广泛，一个典型的例子是程序代码的编译（以C语言为例），代码的编辑-编译-连接-执行分属不同的层，它的好处在于各层执行功能时相互独立，所使用的工具可以替换，例如编译器选择clang或gcc都可以；然而有时候也需要牺牲分层带来的灵活性，例如在c代码中使用内联汇编进行优化，这是一种跨层优化

NAT（网络地址转换）是一个非常具有代表性的例子，它是一种很有用的工具，但也让向互联网添加新的传输协议变得不可能。

## 5.2 封装原则
封装是结合了分层和分组交换之后产生的结果，我们希望将数据包分成多个分组，而每个数据包中又包含了来自多个层的数据，例如当发送TCP段时，它首先位于IP数据包中，并且又放置在以太网帧中，这是通过遵循封装原则进行信息组织实现的，封装原则使得数据包能够保持层次结构，同时内容共享

封装是让我们使用协议层并使其能够更简单地在数据包内共享存储的原则，是**分层在实际数据表示中的体现方式**
它的工作方式是每个协议层都有一些头部header，随后是有效载荷和一些页脚。
例如，IP数据包的头部保存源地址和目的地址，使用IP发送一个TCP段时，我们**将TCP段作为IP数据包的有效载荷**
```
┌─────────────────────────────────────────────────┐
│              应用层数据 (HTTP, FTP等)             │
└─────────────────────────────────────────────────┘
                        ↓ 封装
┌──────────┬──────────────────────────────────────┐
│ TCP头部  │         应用层数据（TCP的Payload）      │
└──────────┴──────────────────────────────────────┘
                  ↑ 这整个就是 TCP Segment（TCP段）
                        ↓ 封装
┌──────────┬──────────────────────────────────────┐
│ IP头部   │         TCP段（IP的Payload）           │
└──────────┴──────────────────────────────────────┘
                  ↑ 这整个就是 IP Packet（IP数据包）
                        ↓ 封装
┌──────────┬──────────────────────────────────────┬─────────┐
│ 帧头部    │       IP数据包（帧的Payload）          │ 帧尾部    │
└──────────┴──────────────────────────────────────┴─────────┘
                  ↑ 这整个就是 Frame（数据帧）
```
因此，IP数据包封装了TCP段，并且IP不需要知道它的有效负载是什么，只需要根据自己的头部将数据包传递到目的主机上，由目的主机查看有效负载，知道是一个TCP段，然后相应处理

对于更完整的使用情况也是相同的：
假设你正在使用通过wifi无线以太网连接的计算机浏览网络，网络浏览器会生成一个`HTTP GET`请求，这个`GET`请求就作为TCP段的有效载荷：**TCP封装`HTTP GET`的段成为有效载荷，随后IP数据包进一步封装了TCP段（其中包含`HTTP GET`请求），该IP数据包又是WIFI链路帧的有效载荷**

> [!NOTE]
> 
> ![[Pasted image 20251224105626.png]]
> 
> 上图中是一种绘制数据包的方式，头部在右侧，尾部在左侧，从右往左数据包的位数上升。此时向路由器或交换器传送数据包的方向也是从左到右移动，因此最右边的位先到达并离开路由器
> 软件领域则经常反过来，头部在左侧，尾部在右侧，例如IETF文档或很多协议规范。因为遵循地址从左往右递增的原则

在wireshark工具中，一个数据包看起来像是如下这样的：
![[Pasted image 20251224112332.png]]
最上方告诉我们该数据包是一个以太网帧，其中包含了下两行`Internet Protocol Version 4`开头的部分所描述的IP数据包；而IP数据包中又包含了它下一行`Transmission Contorl Protocol`开头描述的TCP段；TCP段中又包含了最下面的`HTTP`段，其中包含`HTTP GET`请求

wireshark能够将每一部分在数据包实际字节中的位置标注出来：
![[Pasted image 20251224112754.png]]

这就是非常简单的将协议封装在数据包内部的方法，网络四层模型并不是静态的，封装的过程会随着数据包的传输行为而变化，**虚拟私人网络VPN**就是一个很典型的例子：
虚拟私人网络VPN的用途是**与你信任的网络建立一个安全的连接**，例如使用**TLS传输层安全性协议**，当使用互联网发送IP数据包时，**首先将流量转发到这个VPN连接中，然后由这个私人网络正常进行路由**，从而使得网络资源像在私人网络中私有受保护一样，只需要关注一个服务的保护（VPN网关）
在VPN的例子中，假设我们正在访问公式内部的网站，我们的网络浏览器生成了一个`HTTP GET`请求，它首先被放置在TCP段中，然后嵌套在IP数据包中，**此时IP的目的是公司内部的Web服务器（受保护）**。
此时，由于需要保护私有网络的安全性，不能直接与内部web服务器通信（私人网络），而是将IP数据包放入一个TLS段中（前面提到的传输层安全性协议），该协议通过加密保护信息，TLS段也具有它自己的头
加密完成之后，这个TLS-IP-TCP-HTTP结构的数据包（TLS段）需要先被发送到VPN网关才能进入，因此外层将其放置在另一个TCP段和IP数据包中，流的目的是VPN网关。在最外层，则是放在链路层的**ETH（以太网）帧**中，然后通过链路层运输到当前路由器的下一跳中：
![[Pasted image 20251224133529.png]]

# Lecture 6. 内存、字节序和数据包格式
数据以字节形式在不同主机之间传输，因此需要对消息包含哪些字段，这些字段的字节排列格式、信息表示方法达成一致
在生成要发送的消息时，软件通常需要先在内存中创建一个消息的副本，这个副本会经过网络卡进行发送；而在接收一条消息时，网络卡将消息放在内存中，由软件之后访问它们

## 6.1 计算机内存模型
让我们从一个简单的计算机内存模型开始
![[Pasted image 20251224161444.png]]
大多数计算机以字节形式组织内存，1字节=8位，一个程序拥有自己的地址空间，从地址0开始，现代电脑的地址长度通常为64位，因此最大存储量为$2^{64}$字节
$2^{30}$字节等于1GB，在上图中计算机内存为8GB，即$2^{33}$字节。软件可以访问内存中的每一个字节或按组访问字节（例如加载一条从8个连续字节中读取64位整数的机器指令时）
多字节值，例如数字1024（0x0400占两个字节）的**字节顺序**则非常重要，0x0400和0x0004是截然不同的两个值。现代计算机中存在两种字节顺序：**小端序LSB和大端序MSB**。（数字表示中，低地址在左，高地址在右）
- LSB：最小的有效字节在地址最低的地址，例如1024的字节表示中0x00位于低地址，0x04位于高地址，即0x0004
- MSB：最大的有效字节位于最低的地址，例如1024的大端序表示就是0x0400

> [!NOTE] 不使用计算器看出一个十进制数的十六进制表示是什么字节顺序
> 本质上是看十进制和十六进制的转换，先将原十六进制数两位两位地看，对于四位

## 6.2 网络字节序
因此，若两台计算机需要互相通讯，它们的处理器使用小端序还是大端序就很重要，而且可能会不同。例如x86是小端序，而arm是大端序
我们不希望计算机关心另一边使用什么字节顺序，因此协议规范机构规定所有互联网协议使用大端序
但如果一个互联网数据包是大端序，但接收它的处理器是小端存储，会出现什么情况？
假设数据包的TCP段中的端口号是80（即HTTP端口），这个数字使用两个字节存储。这个端口号在数据包的固定偏移量处使用大端序存储，如果使用小端序主机直接读取它，那么就会读出截然不同的端口号

为了避免这种问题，C的网络库提供了主机和网络之间的顺序转换函数：
- `h2ns()`：接受一个16位的主机上的短整型short值，将这个值用符合网络字节顺序的方式输出
- `n2hs()`：将网络短整型转换为主机短整型short值
- `h2nl()` `n2hl()`：和前两个一样，只是转换32位长整型long值
所以网络程序读取数据时需要通过类似于`ntohs(packet->port)`的方式来安全地进行

**要小心地处理任何网络数据**，在进行网络数据和主机数据之间的转换时要格外小心，它会导致协议出现各种意想不到的问题

## 6.3 数据包格式
我们知道了互联网使用网络顺序（以大端序为标准）布置多字节值，接下来就可以查看各个网络协议是如何描述它们的数据包格式的了
网络协议使用纯ASCII符号文本编写，下面展示了直接摘自RFC 791的文字块：
![[Pasted image 20251225105630.png]]
它规定了IPv4的数据包规范，在顶部可以看到显示了0-31的位号，这是因为网络协议文档编写标准规定了头部字段使用4字节对齐描述
因为IPv4的数据包头至少有五行，所以其长度至少有20字节。并且可以看到IPv4数据报的Total length总长字段的长度是16位，意味着它最大可以表示65535字节，即数据包的长度不能超过65535字节；数据包的所有数据以大端序存储

在wireshark中，我们可以看到网络浏览器使用`HTTPS`协议进行安全连接，它其实就是HTTP+TLS/SSL，使用TLS或SSL协议进行加密和身份验证，然后由TCP段指定默认端口为443（记住，端口用于区分同一台计算机上的不同服务），代表HTTPS加密网络浏览服务，这个TCP段就位于IPv4头内部：
![[Pasted image 20251225114401.png]]
尽管HTTPS对数据包经过了加密，但是使用wireshark我们可以看到IPv4头内部的情况
![[Pasted image 20251225114530.png]]
这里显示Total Length为1230，在下面数据包实际字节中显示是`04 ce`，这意味着使用大端序时就是0x04ce=1230，数据包使用大端序作为字节顺序

# Lecture 7. IPv4命名和地址
互联网协议通过网络传递数据，网络底层是很多链路，它们通过地址来进行导航：路由器根据数据包的目的地址决定应该将流量转发到哪条链路上，直到目的主机。因此我们需要详细了解IPv4地址的样式、格式化和分配方法

网络协议的目的是把不同的网络集合在一起，协议需要一种独立于所在的网络，且是唯一的引用方式来引用计算机，这样一台连接了路由器或串口线的计算机就能进行通信了
实际上今天的IPv4地址由于很多特殊情况和用途并不完全唯一，但我们在这里假设它们是唯一的

## 7.1 IPv4地址、子网掩码
一个IPv4地址长度为32位，通常将每八位分离出来，成为四个八位的字节，书写形式为：
```
A.B.C.D
171.64.64.64
128.30.76.82
...
```
通过IPv4连接的设备都具有一个IPv4地址，IP层将目的为该地址的数据报传递到该设备

除了地址以外，设备通常还具有**子网掩码**
子网掩码用于告诉你哪些IP地址是**本地的**、哪些是**位于同一链路上的**、哪些是**位于同一网络上的**、哪些**需要通过IP路由器到达**，这样位于同一网络的设备能够直接进行传输，路由器也能够知道应该转发的方向

子网掩码的长度和地址相同，都是32位，它是一串从最高有效位开始连续的1值，注意1是连续的，只要出现了0之后就没有1了(?)。
例如，我们知道$(11111111)_2=2^8-1=255$，那么设备的子网掩码`255.255.255.0`就代表前24位（前三个字节）都是1，最后一个字节都是0，这意味着**一个IP地址的前24位值和该设备匹配上的设备与它在同一个网络下**
当然，并不是一个字节内的每一位都必须相同，例如`255.128.0.0`，其中$128=(1000000)_2$，就是前一个字节加一位的值都是1，匹配上这9位的设备与其在同一个网络下

计算机通过**将设备的主机地址与子网掩码进行==按位与==操作**来计算设备的**网络地址**

