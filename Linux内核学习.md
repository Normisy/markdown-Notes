# Chapter 1.  内核基本常识
## 1.1 内核安装和编译

linux内核官方网站中可以获取最新版本的源代码，可以是完整的压缩形式，也可以是增量补丁形式：[LINUX](http://www.kernel.org)
Linux的内核源代码可以通过git获取：
```
git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git
```

在我们的Linux系统中，内核源码一般安装在`/usr/src/linux`目录下，但这个源码树不要用于开发，因为编译C库所使用的内核版本是链接到这个树的，不能对其进行修改

## 1.2 使用增量补丁

Linux内核社区中，人们以补丁的形式发布和接收对代码的修改，只需要在旧版本中打上补丁就可以对内核进行更新：
```
$ patch -pl < ../patch-x.y.z
```
这里`patch-x.y.z`代表补丁的版本，一般比当前内核版本后一个版本
在后面章节还会进一步介绍创建和应用补丁的方法

## 1.3 内核源码树与编译

内核源代码`/usr/src/linux`由很多目录及子目录组成，是一个树状结构：
![[Pasted image 20250225194823.png]]

将内核源代码进行编译是很简单的，内核提供了许多工具进行，最简单的是使用`make`命令：
```
make config
```
它会逐个遍历所有配置项，要求用户逐个选择`yes`、`no`或`module`，这样非常浪费时间，我们可以使用以下基于`ncurse`和`gtk+`的图形工具：
```
make menuconfig
```
```
make gconfig
```

它们会把配置项的情况分类，例如按照处理器类型区分，可以按照类别进行移动浏览和修改
或者通过使用以下命令配置默认选项（据说是Linus的配置）：
```
make defconfig
```

配置项可以在根目录下的`.config`文件中找到并直接修改，修改完成后，需要验证和更新配置才可使用：
```
make oldconfig
```

## 1.4 内核开发

相比在用户空间内进行的程序开发，对内核的开发有一些需要注意的不同之处，最重要的差异有：
- 内核编程时**不能访问C库和标准的C头文件**
- 内核编程时使用的C语言必须是**GNU C**
- 内核编程时**没有内存保护机制，需要小心**
- 内核编程时**浮点运算非常困难，尽量不要使用**
- 内核分配给每个进程的内存只有一个很小的**定长堆栈**
- **内核支持中断、抢占和SMP**，因此需要注意**同步和并发问题**

### 1.4.1 内核无libc库和标准头文件

**内核无法链接使用标准C函数库，或其他的库**，最主要的原因是对于内核来说完整的库太大且低效了
但是大部分常用的函数在内核中都得到了实现，并且放置在`lib`中，例如字符串操作函数组就放置在`lib/string.c`文件中，只需要包含`<linux/string.h>`头文件就可以被使用

在本书中谈论的头文件，都是组成内核源代码树的内核头文件，不包含任何外部头文件和库
基本的头文件位于内核源代码树的根目录下的`include`目录中，例如`<linux/inotify.h>`对应内核源代码树的`include/linux/inotify.h`
另外，体系结构相关的头文件集合则位于内核源代码树的`arch/<architecture>/include/asm`目录下，例如若编译的是x86体系结构，则体系结构相关的头文件就是`arch/x86/include/asm`，内核代码以`<asm/*>`的形式包含这些头文件

例如，内核提供的`printk()`函数的功能几乎与`printf()`相同，它负责将格式化后的字符串拷贝到内核日志缓冲区上，`syslog`程序通过读取该缓冲区来获取内核信息
其使用方式也和`printf`一样，但是它允许通过指定一个标志来设置优先级，这个优先级可以让`syslog`程序决定在什么地方显示这条消息：
```
printk(KERN_ERR "this is an error\n");  // 注意标志和字符串之间没有逗号
```

### 1.4.2 GNU C

内核实际上并不完全符合ANSI C的标准，内核开发者总是需要用到gcc所提供的c语言扩展特性，基于iso C99的标准进行扩展，下面是扩展中让人感兴趣的部分

#### 内联函数inline
C99和GNU C都支持内联函数，函数会在它所调用的位置上展开，这样可以消除函数调用和返回带来的开销（函数调用和返回意味着寄存器状态的存储与恢复），同时，编译器的优化是将调用函数那部分的代码和函数本身放在一起，同时进行优化，所以也可能更好地进一步优化代码
然而，代价在于：每个inline的地方进行展开后的代码会变得很长，占用更多内存空间或指令缓存。因此，开发者通常将对时间要求高，且自身比较短的函数定义为内联函数；对于会被反复调用且比较长的函数，并不建议做成内联函数

定义内联函数时，必须使用`static`作为关键字，且使用`inline`限定它：
```
static inline void wolf(unsigned long tail_size)
```

内联函数必须在使用该函数的代码之前就定义好，而不能只是声明，不然编译器无法进行展开。
一般来说，是在头文件中定义内联函数，因为使用`static`进行了限制，所以编译时不会为内联函数单独建立一个函数体

内联函数用于替代复杂的宏，以维持类型安全和易读性

#### 内联汇编
gcc编译器支持在C函数中嵌入汇编指令，当然，不同体系结构的汇编指令是不一样的，所以必须在知道对应的体系结构的基础上才能使用内联汇编

下面是一条用于执行x86处理器的`rdtsc`指令的内联汇编指令，用于返回时间戳`tsc`寄存器的值。其中，两个整数`low`和`high`存储64位时间戳的低32位和高32位
```c
unsigned int low, high;
asm volatile("rdtsc" : "=a" (low), "=d" (high))
```

Linux内核混合了C和汇编，在贴近体系结构的底层和对时间要求严格的地方使用了汇编语言

#### 分支声明
对于条件选择指令，gcc允许我们进行优化：对于一个会经常出现的条件，或者一个很少出现的条件，可以通过下面的指令提示编译器，进行优化：
对于条件选择：
```c
if (error) {
// ...
}
```

若条件error绝大多数情况都是`false`，认为该if分支很少会发生，使用`unlikely()`：
```c
if (unlikely(error)) {
// ...
}
```

若该分支条件通常都是真，分支经常会被进入，使用`likely()`：
```c
if (likely(error)) {
// ...
}
```

使用这样的优化之前，必须对分支条件的发生频率有非常清楚的认知，否则会造成反效果。也正是因此，用于标记条件不经常发生的`unlikely()`会比`likely()`更常使用，因为它只涉及到一条分支，而后者抢占了其他分支的执行可能性

### 1.4.3 没有内存保护机制

在用户程序中试图进行非法内存访问时，内核会发现该错误并且发送`SIGSEGV`信号，结束整个进程；而在内核自己非法访问内存时，就没办法控制了
所以内核不应该访问非法内存地址、引用空指针等等，它可能会直接死掉而不发出任何通知
另外，内核中的内存都不分页，所以每使用一个字节，物理内存就会少一个字节，因此内核的增量功能也要考虑这一点

### 1.4.4 不要轻易使用浮点运算

在用户空间中进行浮点运算时，当碰到浮点指令，它会触发一个设备不可用（\# NM）异常，陷入内核，此时异常处理进程会检查例如"浮点处理单元FPU上次归属者“等信息，若归属者不是当前进程，内核将FPU的当前状态加载至归属者进程的PCB，然后恢复将要执行进程的FPU状态或清除出一个初始状态

而在内核空间中，由于内核本身是无法陷入的，内核进程的权限级别CPL=0，是最大的，