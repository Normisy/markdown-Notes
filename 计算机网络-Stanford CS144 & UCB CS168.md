# Lecture 1.  网络程序

## 1.1 双向可信比特流连接
连接指的是两台不同位置上的计算机（包括手机、服务器等等）能够互相传输数据
现代计算机中主要采取的通信模式模型是**双向可信比特流连接**，在两台计算机之间传输数据：
- 一方可以阅读另一方所写的内容
- 双向通路
- 除非连接被破坏，否则都是可信的
![[Pasted image 20250901214519.png]]
当然，还有其他的通信模式，会在课程的后续部分进行介绍，但这种通信模式是最常用的

### 1.1.1 万维网（HTTP）
在了解通信模式后，World Wide Web万维网就是一个例子，它采取超文本传输协议HTTP进行通信（URL中的`http://`部分就指示了这一点）
关于HTTP的细节在后面的课程中会讲解，现在概述来说，http被设计为一种以文本为中心的程序通信方式，例如在浏览器中输入`http://www.stanford.edu`，它就会向名为`www.stanford.edu`的服务器打开连接并发送一个获取站点根页面的请求
即：在http中，客户端打开与服务器之间的连接，然后向服务器发送命令，最常见的是`get`，它请求一个页面；
而服务器则接收请求，检查它是否有效以及用户是否可以访问，并且向`get`发送一个**用数字代码标识的响应**，例如代码200标识请求已被接受，代码
同时，服务器的响应还包括了用于描述主页面的超文本，例如`put`，`delete`，`info`等等

因为http是以文档为核心的，它全部由ascii编码，人类可读，例如
```http
response: "HTTP/1.1 200 OK"
```

## 1.2 BitTorrent
bittorrent是一个允许人们共享和交换大文件的程序，与Web不同，在Web中，客户端从服务器请求文档；而在bittorrent中，客户端从其他客户端中请求文档，因此单一客户端可以并行地从许多其他客户端中请求。
bittorrent将文件分解成被称为“片段chunk”的数据块，当一个客户端从另一个客户端下载数据块时，另一个客户端需要告诉它“我有你需要下载的文件”
这些协作客户端的集合被称为“群组swarms“

除了群组，BitTorrent的传输方式和HTTP相同，都是双向可信比特流，但是会更加复杂一些：当客户端想要下载文件时，它必须具有一个称为torrent（种子）文件的东西，使用这个文件进行下载。torrent文件具有你要下载的数据文件的一些信息，它还向bittorrent指示了谁是该torrent的跟踪器tracker
跟踪器tracker是一个持续跟踪的节点，用于跟踪信息：当你是与其他客户端建立连接的客户端时，只需要向跟踪器请求，它就会向你返回一个客户端的列表（群组）。当一个新客户端加入群组时，跟踪器也会向你报告

## 1.3 Skype
skype是一个专有系统（系统内部细节曾经加密，但是被反向工程得出了），用于流行的语音、聊天和视频服务。
在最简单的模式下，当我们在skype中向别人呼唤(call)时，是一个简单的客户端-服务器交换，类似于HTTP：呼唤者向接受者请求打开连接，接受者向呼唤者打开连接后就可以交换数据了。
然而，和网络不同，在Skype中，并不是客户端-服务器，而是客户端-客户端，即没有专用服务器，而是两台个人电脑之间互相传送数据。
这个区别重要地影响了skype的使用方式，它的复杂性源于**NAT：网络地址转换器**，它是现在随处可见的一种设备，例如小型家用无线路由器就是
当手机连接到互联网时，手机实际上是在NAT之后的（后面会详细介绍），我们只需要有一个“只要通过NAT，我们就可以打开到互联网的连接，但互联网上的其他节点无法轻易与我们建立连接

因此，在skype中，两台个人电脑由于安全原因，均会处于NAT之后，此时需要一个中继服务器（不经过NAT，暴露在网络中的）进行申请的中继

# Lecture 2. 网络模型

## 2.1 协议
协议是一组用于**规范人们如何通信**的规则，可以将其分为**语法和语义**两部分：
- 语法：消息的含义，消息就是一串二进制位，如何对二进制位进行解码获取其中的信息，就是语法
- 语义：当接收到一条消息时，应该如何响应这些消息进行对应行动

## 2.2 四层网络模型

在第一讲中，我们看到了很多网络应用程序，创建可靠的通信模型需要许多组件协同工作，而不同程序的信息类型、数据传输速度也各不相同。但是，在传输方式方面，所有的网络程序都在发送和接收数据层面上存在相似之处，并且都希望和数据在互联网上真实的传输路径相隔离

早期的互联网先驱创建了四层互联网模型，以描述其组成互联网的层次结构，从而应用程序可以直接使用已有的部分，而无需从头开始创建。所有的四层都是为了最终实现应用程序，进行可靠的主机间通信而存在的
![[Pasted image 20251019195858.png]]
每一层都负责不同的部分，并且每一层都建立在下面一层的服务之上，因此我们自底向上进行介绍

1. Link层：互联网由终端主机（end hosts）、链路（links）和路由器（routers）组成，数据沿着链路和其转向进行逐跳（hop）传输。数据传输的形式是数据包，它是一个自包含的单元，含有需要传输的数据。数据包头部的信息告诉网络应该将数据包传递到哪里，以及它来自哪里等 
		链路层的工作是每次在一个链路上传输数据，最典型的例子是以太网和wifi
2. 网络层：其工作是端到端地传递数据包，从数据来源到其在互联网上的目的地。数据包是网络中的重要组成块，它的头部储存了关于数据包的源和目的的信息
		网络层将数据包交给链路层，让链路层传输数据包，一个link的另一端就是路由器router，路由器的链路层接受来自链路的数据包并将其传递给路由器内部的网络层，路由器内部的网络层会检查数据包的目的地址，然后将数据包逐跳路由到目的地（传输回链路层，传递给下一个路由器，直到它到达目的地的网络层）
		网络层无需关心链路层是如何通过连接发送数据包的，实际上每种设备的链路层的工作方式也不同，就像是wifi和以太网的链路层工作完全不同，只是提供了相同的接口以供上一层使用
		当我们向互联网中发送数据包时，需要使用互联网协议（IP），它会尽可能地将数据从一端运输到另一端，但是**并不作任何保障**，并且可能会丢失数据包、顺序改变、损坏数据包等，没有安全保证
3. 传输层：**IP并不负责保证数据包的有序安全**，传输层是运行在IP之上的协议，负责将数据包按顺序且无损地传递到应用程序中。最常见的传输层是**TCP传输控制协议**，确保数据包从互联网的一端按顺序正确地传输到另一端的应用程序，若网络层出现了数据包的丢失，那么TCP会在需要的情况下**多次进行传输**，并且把数据包**按照正确的方式排列**（出现乱序或者重复的原因是数据包沿着不同路径被传输到应用程序中了）；
	一些应用**无需可靠的传输**，例如视频会议更注重实时性，则可以使用更简单的**用户数据包协议UDP**，它是一种将应用程序数据捆绑在一起进行传输的传输层，**只提供顺序的保障**
4. 应用层：许多不同的应用程序通过使用明确定义的方式API重用传输层，它们通常需要两个端点之间的一个**双向可靠字节流**，使用应用程序自己的协议来定义数据字节流的语法和语义。
	例如，在web客户端向web服务器请求页面时，客户端发送GET请求，这个请求命令是**超文本传输协议HTTP**的命令之一，它规定GET命令与URL一起作为ASCII字符串发送给正在请求的页面，从应用层角度上来看，GET命令会直接发送给另一端的Web服务器应用程序，无需知道底层重新传输了多少次；从整体上看，该命令被交给传输层的TCP，调用更加底层的API进行
![[Pasted image 20251212134210.png]]

另外，一些需要注意的地方：
1. IP经常被称作互联网的薄弱环节，我们想使用互联网就必须使用互联网协议；但链路层link的选择却不止一种，IP可以在不同的链路层上运行，例如以太网、WIFI、DSL、3G4G5G等等；IP之上的传输层也可以使用多种类型的，除了TCP以外还有UDP、RTP等；同样地，应用层除了http，也有ssh、smtp、ftp等协议可以选择
2. 在早期，ISO提出了七层网络模型，但如今已经被四层模型替代了（但仍有人会使用），它们之间的对应关系如图
![[Pasted image 20251212134800.png]]

如前所述，网络模型的每一层都向上层提供服务，为了正确使用它们，我们必须深入了解每一层所提供的服务和其所依赖的服务
要注意的是，**模型并不是完美的**，并不是所有东西都能归纳到这些层中，一些协议可能在层与层之间或者跨越层，**层次模型只是一种设计原则**。
### 2.2.1 互联网协议（IP）底层服务
网络层是互联网中最重要的一层，实际上它就是互联网，因为我们使用互联网时必须通过互联网协议IP进行数据传输和接发，这一节介绍IP所提供的底层服务
IP Datagrams（互联网协议数据报）由一个数据头和一些数据组成。当传输层有数据需要发送时，传输层会将传输段数据传递给网络层，由网络层将其封装为IP数据报（内的传输段），并加上**目的IP地址**，IP的目的是把数据报传输到互联网的另一端
接着，IP首先需要找到通向第一个路由器的链路link，为此IP将数据报发送到链路层，将其放入链路框架中（例如：以太网数据包），将链路帧（link frame）发送到第一个路由器
![[Pasted image 20251212194353.png]]


IP服务从源主机到目的主机发送数据报，传输过程是不可靠的，**网络不保存任何与数据报相关的底层流状态**，它可以通过以下四个特性来描述：
1. 数据报服务：当请求IP为我们发送一些数据时，它会首先创建一个数据报，将数据放入其中。一个数据报是基于其报头信息在网络上单独路由的数据包，它是自包含的。
	报头包含**目的主机的IP地址**，简称为**IPDA**，每个路由器的转发决策都基于该IPDA；此外，数据报头还包含一个IP源地址，简称IPSA，表示数据包来自的地方。
	数据报在网络中**逐跳路由**，从一个**路由器**到下一个路由器，沿着源地址到目的地址的路径传输，**每个路由器都有一个独特的IP地址**，各自包含一个**转发表**，通过匹配表上给定的目标地址确定下一步要发送数据报的位置
	路由器并不知道整个传输地址，只使用数据报的目的地址来索引自己的转发表以使其能够将数据报转发到下一跳

2. IP是**不可靠**的：IP无法保证数据包会被传送到目的地，数据包的传输可能出现延迟、顺序错乱或压根没有送达，或是因为路由器的问题导致重复传送
3. IP会尽力进行传输：它不会因为传输过程中的问题就随意丢弃数据包，**只在必要时可能丢弃**，如路由器的数据包队列因堵塞填满时不得不丢弃下一份到达的数据包。请注意，这时IP不会告诉源地址数据包被丢弃了，因为IP不保证错误不会发生，也并不检测它们
4. 通信服务的无连接性：**IP不维护没有任何与通信相关的状态**，我们称该通信服务是无连接的，因为它不通过建立与通信相关的端到端状态来开始，只是进行路由转发

IP地址非常简单，因为互联网上的每次通信都需要使用IP服务，需要保持网络**简单、最小化、快速且维护成本低**，通过将专用硬件使用简单的形式构造，以使其易于更新和维护
**端到端原则**：只关注能否**正确地在端点处实现功能**，将功能和智能主要放置在**端点处**（源计算机和目的计算机），从而使得改进主要发生在软件上，而非硬件上。
端到端原则应用范围很广，例如传输层中端点在不可靠的IP网络服务上建立可靠的通信服务的方式（后续内容）
另外，IP服务也**需要允许从多种可信或不可信的服务中被构建使用**，如果强制要求IP在出现问题时重传，其泛用性反而不理想，因为实时应用更加追求时效性而非可靠性；且IP需要被各种链路层进行使用，因此其基于的假设和要求必须很少

#### IP服务模型的额外细节
除了基本的、不可靠的、无连接的尽力数据报服务之外，IP也提供了一些其他的精心选择的服务，它们在最基本的服务之上进行了适当的拓展，本节会介绍其中的五个
1. IP会试图**防止数据包永远循环**。我们知道IP路由器通过转发表逐跳地跨越互联网转发数据包，此时转发表可能出现错误，导致数据包的转发路径出现循环。与其复杂地阻止循环的出现，IP选择在数据包中添加一个跳数字段，位于数据包的头部，称为**TTL（生存时间）字段**，从类似128的数字开始起算，每经过一个路由器就被递减，若TTL字段到达0，IP认为该数据包进入了循环，直接**丢弃该数据包**
2. IP在数据包过长的时候会**将其分成片段**：IP被设计为能够在各种链接上运行，大多数链接类型都有它们能够传输的数据包大小的限制，例如以太网只能传输小于1500字节的数据包，若一个应用程序需要发送大于1500字节的数据，则需要在发送IP数据报走之前将其分割为1500字节大小的数据块。然而，在数据报传输的路径中，它**可能又要经过一个传输限制更小的链接**，此时**连接两个链接的路由器**需要将数据分成更小的数据报。IP提供一些头部字段来帮助路由器将数据报分割成两个自包含的IP数据报，并且能够提供主机能将数据重新组装的信息。（后续会详细介绍）
3. IP使用头部校验来减少数据报被路由到错误目的地的概率：IP数据报头中包含一个校验和字段来试图保证数据报被传送到正确的目的地中，以避免数据安全问题
4. 目前有两个版本的IP正在被使用，这两个不同的IP在后续会学习到：
	1. IPv4：被超过90%的主机使用，使用32位地址，在地址逐渐被用尽之后，逐步过渡到IPv6
	2. IPv6：使用128位地址
5. IP允许向数据报头添加新的字段，这是个具有双面性的功能，它一方面允许添加原始协议没有的额外的重要特征，但因为处理新的字段需要路径上的路由器具有额外的功能，打破了简单最小转发路径的原则

#### IPv4数据报头
IPv4数据报头组成示意图如下所示，字段长度存在不同，但头部总长必须是四字节的倍数。将其使用32位的字进行绘制，其中位0是最先被发送到导线上的数据：
![[Pasted image 20251218205717.png]]
1. 灰色部分就是数据报头部结构，其中具有许多不同的字段：
	1. Destination/Source IP Address：目的IP地址和源IP地址
	2. Protocol ID：协议ID，它用于指示上层协议是什么（例如TCP协议=6），从而告诉我们数据字段Data中包含什么内容。本质上允许了目的主机对到达的数据包进行**解复用处理（将数据分发到不同协议的处理模块代码中进行处理）**，不同传输协议具有各自唯一的协议ID
	3. Version：IP协议的版本号，只有IPv4和IPv6
	4. Total Packet Length：总数据包长度，报头和数据的总字节长度
	5. TTL：时间生存字段，避免数据包的分发进入循环，TTL到达0时该数据包被销毁
	6. 第二行Packet ID - Flags - Fragment Offset：当一个数据包的长度大于链路的最大接收长度时，需要进行分段，此时路由器会基于数据包ID - 标志 - 片段偏移量，将IP数据包分割位更小的自包含片段，分段的具体工作原理在后续会学到
	7. Type of Service：服务类型，向路由器指定该数据包的优先级和服务质量
	8. Header Length：数据报头长度，数据报头可能会有可选的额外字段
	9. checksum：首部校验和，检测头部是否发生传输错误
	10. Option：可选的额外选项；PAD：填充，以确保头部长度是四字节的倍数

## 2.3 从物理层面理解网络层次模型
网络面对的最底层的问题是如何将二进制位跨越空间传输，这需要一些物理技术。在计算机网络课程中，我们只需要知道通过电线、光纤、无线电信号等物理方式，能够实现从地理位置上的A点传输二进制位到B点。这就是它的最底层的组成单元，类似于一名邮递员在快递公司中的作用

链路Link就是两点之间连接的那条电线/光纤/......，两点通过这条链路进行信息的交流。然而，在网络使用的人数规模增大时，在全世界每个人之间都拉一条电线是不现实的
![[Pasted image 20251225211331.png]]
因此，类似于邮局派发信件，我们只需要在一个区域内设置管理这片区域信件派送的邮局，并且只在这两个邮局之间连接通讯线路，就可以更简单地进行通讯了
![[Pasted image 20251225211600.png]]

“邮局”会有很多，将它们互相连接起来，就是互联网了（看起来像是”网络的网络“，因为每个”邮局“自身管理一片网络）：
![[Pasted image 20251225211837.png]]
这里：
- 圆形的“居民”代表终端主机，通信的端点
- 矩形的“邮局”代表路由器/交换机，只负责转发数据包
这样就形成了层次结构，我们发现上面的叙述中本质上包含了物理层-链路层-网络层三层结构，它们使用下层提供的服务的同时为上层提供服务，并且只在意下层提供的抽象，因此类似于“连接的方式是电线还是无线电波“这样的问题对于物理层上层是不需要考虑的，可以替换：
![[Pasted image 20251225212857.png]]

这三层提供的是”尽力而为“的服务模型，也就是说它无法保证数据包不会丢失/寄错等，这就是前面提到的IP服务了

尽力而为的服务是不能被直接使用的，我们需要进行重新发送/顺序组织等功能以确保数据能够按照预想地到达目的地，这就是传输层了。在传输层中，

# Lecture 3. 理解计算机网络
## 3.1 TCP的三次握手
互联网四层模型中，应用层发送和接收数据流；传输层将数据流分成可靠传递的数据段，用于传输给另外一台电脑上运行的应用程序；网络层则将传输层的数据段传递给另外一台计算机

来看一个实际例子：网络浏览器和服务器之间的数据传输
![[Pasted image 20251218215004.png]]
传输层使用TCP传输控制协议，在它的典型操作中，存在一个客户端和服务器：服务器监听连接请求；客户端发送连接请求，由服务器对此做出响应以建立连接。
这个过程的具体操作不详细说明，但事实上，整个交换流程需要三条报文，称为**三次握手**：
1. SYN：客户端发送同步报文到服务器，请求建立连接
2. SYN ACK：服务器确认客户端的同步请求，同时发送自己的同步请求
3. ACK：客户端确认收到服务器的同步请求，连接建立完成

网络层负责将数据包传递到计算机，传输层负责将数据传递给应用程序，因此从网络层的角度来看，在同一台计算机上发送到不同应用程序的数据包都是相同的，这意味着要向另一个程序打开TCP流需要两种地址：
1. **IP地址**：**网络层**所使用的地址，网络层需要它来将数据包传递给目的计算机，在IP段的头部中存储
2. **TCP端口**：它告诉**目的主机上的软件**应该将数据传递到哪个应用程序中，端口号在TCP段的头部中存储
web服务器`HTTP`协议通常在TCP端口80（TCP port: 80）上运行，因此当打开与Web服务器的连接之后，我们将IP数据包发送到运行Web服务器的计算机上，此时目的地址是计算机的IP地址；而IP数据包具有TCP段，它标志着TCP端口的值，也就是80

在这之后，由于不可能有直接连接两台计算机的路径，我们需要让客户端连接到一台中间计算机——路由器，而该路由器本身又连接着其他的路由器，我们使用“**跳**”来描述**两个路由器之间的链接**

当我们的客户端正在使用WIFI网络时，第一跳就是无线设备到WIFI接入点，接入点通过有线连接来与更广泛的互联网相连，所以它又沿着这个有线的跳转发客户端的数据包
一个路由器可以连接多个链路，当数据包到达时，由路由器决定将其发送到哪个链路上，而且路由器也具有IP地址，它有可能就是接收方，因此也有可能直接交付给它自己的软件（例如，使用TCP登录到自己的路由器上的时候）

路由器通过**转发表**来决定将数据包分发到哪个链路上：
![[Pasted image 20251218221619.png]]
转发表由一组**IP地址模式**和**传输到每个模式的链路**组成，其中，**默认路由default**在边缘网络中格外有用：一个路由器的默认路由链接着通向更大范围网络的链路，其他链路则规定了一个特定范围，当目的IP地址不在这个范围内，路由器就应该将其发送到更大范围的互联网中。
具体来说，转发表的匹配遵循**最长前缀匹配**原则：路由器会选择与目的IP地址匹配度最高（前缀最长）的条目。只有当所有具体条目都不匹配时，才使用默认路由（前缀长度为0）。

我们可以使用一个叫做wireshark的**网络抓包工具**来看到网络浏览器是如何向目标web服务器使用三次握手打开tcp链接，然后使用HTTP GET请求服务器的数据响应。
当发生数据包交换之后，使用traceRoute工具，能够看到数据包通过互联网的路径
```bash
traceroute -w 1 [网址]
```
一个数据包传输的时间很短，这些工具让我们能够看到互联网上实时发生的运行情况

## 3.2 计算机网络设计原则
在设计计算机网络的过程中，人们尝试了多种不同的方案，有些成功了，有些则没有成功，现代许多系统设计经营，例如云训练等分布式系统，都从互联网的设计中汲取了经验，因此网络构建的设计原则是很珍贵的经验，并且可以用于其他系统的构建中。
在互联网的设计过程中出现了七条设计原则，它们是人们在设计构建互联网中所得到的最佳实践，是一种**指导性的原则**：
1. **去中心化控制**：互联网并不是由单独的一台电脑控制的，它是**分布式**的，每一个网络设备、路由器和主机都在独自思考并与其他邻居交流
2. **尽力而为的服务模型**：在底层**物理层、链路层和网络层**，我们说它提供了尽力而为的服务，而不是确保数据包一定会被正确发送
3. 绕开问题：在网络中，单一设备/路由器/主机等出现了故障时，整个互联网不应该因此而停摆，网络必须能够**处理故障**，若路由器出现了故障，网络必须能够寻找到**另外一条路径**进行传输
4. 愚蠢的基础设施，将智能放置在端点上：路由器只负责“愚蠢地”进行数据包的转发，并不关心数据包内部的内容，在网络模型中（尤其是七层网络模型），**所有提供准确性保障的层都放置在终端主机上，路由器仅仅保留底部“尽力而为”的几层**
5. **端到端原则**：将大部分的层次功能实现在终端主机上，而不是路由器上。和第四条是一体的，是本节重点内容
6. **分层原则**：每一层利用其下一层提供的接口和抽象实现自己的功能，并向上一层提供服务。从而使得每一层只需要关注自己的行为，不会互相影响依赖（当然，存在打破这条原则的协议，会将两个不接近的层视为一体）
7. Narrow-Waist原则（**窄腰原则**）：所有人应该就前三层的协议和抽象达成一致，就像“使用同一种语言”那样

### 3.2.1 Narrow-Waist理论与解复用
网络模型中很重要的一点是：每一层中可以使用的协议类型都有很多。如果将每一层可以使用的协议类型都列出来，我们会发现：
![[Pasted image 20251227150458.png]]
无论应用层、传输层或其他层存在多少种不同的选择，**在网络层中，我们没有选择，只能使用互联网协议(IP)**，这就是“窄腰原则”的来由：**互联网本质上是不同公司/设备/终端之间的交流，必须具有一种相同的语言将它们联系起来**，IP协议的目的就是这个，每个人都使用IP来转发信息，从而能够在不同用户之间达成一致

在第2节和3.1节的时候我们看到了IPv4数据包头中用于“解复用处理”的**协议ID字段**，之后会看到的TCP段中**端口号**的存在，上面的这张图就很好地说明了它们的作用：在终端主机**自底向上接收数据包**时，在网络层之上的传输层、应用层，都可能有**不止一个的可选路径**，需要在头部使用字段指明唯一的路径：
![[Pasted image 20251227152852.png]]
之后会看到的TCP端口号的使用目的也是一样的，在明确使用TCP协议之后，需要通过端口号**确定数据包应该流向哪个具体的应用程序**
![[Pasted image 20251227153434.png]]
端口号实际上在所有的机器中都存在，不仅仅是私人终端，在公共服务器中也存在端口号，此时这些端口号应该具有一个所有人公认的标准，必须是固定的
（注意，逻辑端口和物理端口（即插入电缆等硬件设备的实际插口）都简称端口，这里我们指的是逻辑端口）

### 3.2.2 端到端原则：在终端主机上实现层
#### 层次之间组成了“硬件-操作系统-用户层”的结构
如果真的在你的电脑上查看程序是在哪里运行TCP或应用程序的协议的，能够大概看到的结构如下：

![[Pasted image 20251227155126.png]]
- 在最底层，有一个硬件：网络接口卡，是一个实际存在的计算机芯片，负责发送和接收数据包，接收无线电01信号，或是通过电线发送二进制信号
- 往上就是软件部分，例如TCP协议本质上就是一段可运行的代码，在你的操作系统上都包含了TCP的实现，以操作系统级别运行
- 而应用层的应用程序也在电脑上运行，以用户级别在用户空间中运行

在最底层，硬件部分**以数据包为单位进行思考**，它只负责一团01信号数据包的独立处理，而不负责思考每个数据包之间的联系
而在最顶层（第七层或应用层），应用程序**以连接为维度进行思考**，例如打开网页浏览器浏览网站时，浏览器认为电脑已经与网站建立的连接，并且正在交换数据
因此，中间的两层就像是**连接数据包与长程连接两种抽象概念的桥梁：接收单一数据包，并且将其组装成为长程连接**，这两层属于操作系统内核，所以整体上也符合“硬件-操作系统-用户层”的分层结构

#### 端到端原则
之前我们说过，物理层-链路层-网络层是“尽力而为”的，路由器不会考虑重新传送和修复出现损坏的数据包，**并不承诺数据包会一定被正确地进行传送**
尽管现在我们还没有深入了解到每个协议的具体内容，但我们知道传输层的一些协议负责确保数据包被正确、可靠地进行传输，我们思考一个最简单的可靠性保证协议，它只在意**数据包是不是全部都被送到了**：**ALL OR NOTHING**，只有在目的主机收集到所有数量的数据包时宣告传输成功，否则都是传输失败

对于这样的协议，假设我们将它放到路由器上而非两个终端上，若路由器检测没有通过协议，就不进行转发，主机信任来自路由器的一切数据；在这种情况下，路由器本身可能会出现问题，完全信赖路由器是不合适的，主机依然需要检查一次协议的正确性。既然如此，路由器本身的检查就成了没有必要且拖累性能的了——不如只让主机进行协议的检查

端到端原则：某些特性（例如刚才所说的可靠性）必须在终端主机上进行实现和检查，才能保证正确性
当然，端到端原则依然只是一个指导性的原则，实际实践中可能存在打破端到端原则的情况，例如某个协议让路由器每次转发都重复两次，以避免链路丢包严重的问题，从而提高传输的性能

## 3.3 资源共享设计问题
互联网是共享的，即一台路由器（一条链路）不仅仅只为一个人服务，而是会被多个不同的流共享。
这时就会出现资源共享的问题：如何确定每个流获得多少带宽？
大致来说，存在两种不同的方式向用户提供共享资源（实际上，不仅仅是路由器带宽，cpu使用率等其他资源共享问题也是适用的）：
1. 静态分配：每个用户获得的资源量是相等的
2. 统计复用：根据用户的需求进行动态分配，分配的资源量随着需求动态变化而变化
![[Pasted image 20251227173740.png]]
网络资源是基于统计复用而分配的
从数学角度，静态分配所需的资源峰值量是所有用户使用峰值之和（Aggregate of peak），而统计复用本质上是先把资源使用需求随时间变化的曲线聚合在一起，然后进行峰值分析，即需求总数的峰值（Peak of aggregate）：
![[Pasted image 20251227175000.png]]
显然，$\max(\sum f_i) \leq \sum max(f_i)$，统计复用能产生更少的资源浪费

那么，如何进行统计复用并决定动态分配的资源？这也基本存在两种不同的模式：
1. **电路交换**：当建立连接时，显式声明你有一个连接，并且说明需求量是多少，在连接期间这些资源就是你的，使用完后再释放（类似于预订制餐厅），它能够为用户提供可预测和可控制的资源
2. **分组交换**：持续发送数据包，先到先得，如果数据包太多，其他数据包只能排队或者被拒绝。也是一种尽力而为的模式，不要求路由器为你预订资源，只是反复重新发送，每个路由器独立处理每个数据包或丢弃

这两种方式都是统计复用，进行资源的动态分配。在现代计算机网络中，选择使用**分组交换**的方式进行统计复用，主要原因是：电路交换性能不佳，用户往往不一定知道自己需要预留多少资源，而且当后来的用户预订资源时，很有可能资源已经被其他用户占用了，本质上还是先到先得

这来源于用户使用的突发性，突发性被定义为**峰值需求量与平均需求量的比值**，突发性低的场合使用电路交换非常合适，例如电话通话时连接相当顺畅，没有很明显的峰值，因此可以预先留下合适的音频带宽空间并保证一段时间内被充分使用；而网络访问的突发性很强，因为用户往往是先下载资源（占用大量流量）到本地，然后在本地进行阅读浏览（这期间不消耗资源），更适合使用分组交换的方式，以应对突发性流量

分组交换还具有更好的错误处理性能，当链路出现问题时，我们需要寻找另外一条路径进行数据传输，然而对于电路交换来说，将预定好的流量取消然后申请另外一条路径的流量非常困难，因为主机还得知道这条链路出现了问题，才能重新申请，而且无法分辨哪个预定是有问题的（这需要往后发送确认数据包，太低效了）。而对于分组交换来说，事情就简单很多了，路由器直接向其他链路进行数据包的反复发送即可

## 3.4 链路
在第2.2.1节的时候我们看到了IP协议下的链路层的链路，一条链路本质上就是**两个设备之间的连接**，它具有以下的性质与指标
### 3.4.1 基本性质
链路的一个基本衡量指标是**带宽**，它决定了该链路每单位时间可以发送多少比特的数据，或接收多少比特的数据，即**单位时间内链路能够传输的数据量（以比特计）**，单位是bps（比特/秒），Mbps（兆比特/秒）。\[注意不是字节，而是比特（二进制位数），差了8位]，用于衡量链路的“宽度”，即链路每次传输可以传输多少比特的二进制位

另一个指标是**传播延迟**，即**一个比特从发送的那一刻起到离开该链路被另一个设备接收需要多少时间**，用于衡量链路的“长度”，单位就是s秒。它不仅取决于物理长度，还取决于构筑链路的方式，例如电线或无线电信号

**带宽延迟乘积**则结合了链路的“宽度”和“长度”，即**带宽和传播延迟的乘积**，根据两个指标的单位可以发现带宽延迟乘积的单位就是比特，可以理解为“链路的容积”，即能够承载比特数的上限。

根据这些基本性质就能计算一条链路的基本性能指标
![[Pasted image 20251227211256.png]]
![[Pasted image 20251227211334.png]]
**传输数据包的延迟 = （数据包的大小 / 链路带宽）+ 链路的传播延迟**
数据包的大小 / 链路带宽 也叫做**传输延迟**，形象上解释就是数据包的第一组带宽数量的比特位被加入链路中，到最后一组比特位进入链路之间的时间

链路的带宽和传播延迟数据用于衡量链路的不同方面的性能，一个链路是否好无法取决于单一指标，而取决于你要发送数据的类型和需求进行权衡
- 若发送的数据包很小，带宽（传输延迟）对它来说就不是性能瓶颈，性能主要取决于传播延迟，需要传播延迟更低的链路
- 若数据包大到需要花很多时间将其塞入链路中，即传输延迟为主要瓶颈，则应该选择带宽更大的链路
![[Pasted image 20251228110130.png]]
这就是带宽和传播延迟的形象化表示，一次性运输的比特（长条形图案）数就是带宽，长条形图案的数量（数据包的“宽度”）就是传播延迟
### 3.4.2 链路过载
宏观上来说，路由器接收数据包并且选择一条链路来转发它们，并且**一个路由器不止接收一条链路上的数据包**，也不止需要处理一个数据包，当**两条不同链路上的两个数据包同时到达**时：
![[Pasted image 20251228161330.png]]
此时路由器将会**维护一个队列**，其中存储接下来需要处理的数据包
![[Pasted image 20251228161425.png]]
路由器会优先处理当前到达的数据包，而在空闲时按顺序处理队列中的数据包
![[Pasted image 20251228161621.png]]

这是**瞬时过载**，也就是短时间内同时到达多个数据包，路由器先将无法同时处理的数据包暂存到队列中，在空闲时处理

然而有时也会出现**队列无法放下所有待处理数据包**的情况，此时路由器会将多余的数据包直接忽略丢弃， 这就是**持续过载**
![[Pasted image 20251228164941.png]]

#### 排队延迟
数据包在传输过程中就可能会遇到路由器出现过载的情况，此时它们在队列中等待的时间造成了传输过程中的排队延迟（若数据包没有被丢弃）。
因此在更细致的传输延迟计算中，还需要加入这个排队产生的延迟，或是丢包（数据包被丢弃）导致的时间损失

## 3.5 网络与路由问题
在接下来的讲解中，我们认为互联网由以下两种设备组成：
- 终端主机：发送和接收数据包至其他终端主机，不负责转发数据包
- 路由器：只负责向前转发数据包，并且假设不为它们自己发送或接收数据包
并且将网络建模为一张图，其中每个链路只连接两台设备（两个端点确定一条链路）
![[Pasted image 20251228202939.png]]
网络图的拓扑结构会不断变化，因此需要在拓扑结构发生变化的第一时刻就能做出路径改变的选择；并且由于系统是分布式的，每个路由器无法知道它们的直接邻居以外的结点的情况，且每个路由器只能做到很小一段的规划（而不是全局的解决方案）；另外，链路是尽力而为地进行传输的，这意味着数据包和一些信息有可能会丢失

这些都是通用互联网的**路由问题**
### 3.5.1 路由协议
在思考路由问题的时候，我们将网络视为“网络的网络”，即存在很多不同的互联网运营商，各自运营着自己的本地网络，本地网络相互连接形成了整个互联网
![[Pasted image 20251228205946.png]]
**并不是每个网络都使用相同的路由协议**，我们可以将所有路由协议分为以下两类：
1. 域内路由协议（Intra-domain routing protocols）：不考虑其他网络，只解决单一特定网络内部的设备的路由问题的协议，也称为**内部网关协议IGPs**，每个网络可以选择自己的域内路由协议
2. 域间路由协议（Inter-domain routing protocols）：不考虑每个本地网络内部的


# Lecture 4. 分组交换理论
## 4.1 分组交换定义
分组交换理论是互联网构建早期一个简单而又革命性的理论，在本节会从高层次介绍其理论和优势

数据包：一个自包含的数据单元，携带了到达目的地所需的必要信息
分组交换：将数据分成离散、自包含的数据块，一个数据块就是一个数据包，它们每个都携带足够的信息使得网络可以将该数据包传递到其目的地
![[Pasted image 20251223194831.png]]
在最简单的分组交换形式中，每个分组（数据包）是单独独立地进行路由的，即路由器会单独根据每个分组的信息进行分发
分组交换的简单定义：对于每个到达的分组，独立地选择其外向链路，若对应链路空闲，直接发送它；否则保留该分组，之后再使用

自路由/源路由：每个分组都包含了一个明确的路由，它指定了沿途每个数据包交换机的ID，直到目的地，源指定了路由的每一跳
![[Pasted image 20251223200511.png]]
互联网支持源路由策略，但通常会关闭它，因为它会带来安全问题
源路由的一种简单的优化方式，也是今天互联网主要采样的方式，是在每个交换机中放置少量的状态，从而告诉交换机下一跳应该将数据包发送到哪个链路
具体来说，每个交换机保留一个目的地址和下一跳的表，当它接收到一个数据包时，在表中查找地址并将数据包发送到适当的下一跳，从而使得数据包只需要携带目的地址

## 4.2 性质
分组交换具有两个很好的性质：
1. 简化转发过程：交换机可以为每个数据包做出个体化、本地化的决策，它不需要在检查数据包时保存额外的数据包中的状态；也不关心不同数据包之间的关系，即使许多数据包同为某更大的传输或协议的一部分。它们只需要转发
2. 多方能够共享链路：多个数据源或目的可以共享一条链路，例如两台电脑共享同一个无线路由器，链路尽管根据使用情况会出现速度不同，但仍然被共享

流：通信时往往不止发送一个数据包，流是属于同一**端到端通信**的数据报集合，例如：TCP连接
分组路由不需要交换机了解和保存每个流的状态，因为这会导致大量状态的难以管理和保存，性能不佳且昂贵；同时确保交换机不会因为端点出故障时影响其行为，它只负责接收和转发

数据流量是突发性的，用户可能随机地在不同时间不同地点进行数据传输，因此发送和接收数据速率并不固定，使用量会随着时间推移而跳跃、波动、升降
整体来看可能存在一些规律，例如下午高峰凌晨低峰，但从小时间尺度上看，突变通常是独立随机发生的
统计复用（异步时分多路复用）：将单一资源使用概率或统计方式分享给多个用户。具体来说，每个用户根据其他用户的使用情况，能够获得资源的统计份额，即只对需要传送数据的终端分配时隙以提高信道的利用率

# Lecture 5. 分层原则与封装原则
## 5.1 分层原则
在四层网络模型中我们看到很多次分层原则，这是一种在计算机网络出现以前就存在的设计原则

分层：将系统组织成若干个独立功能组件或层次的组织方式，每一层分层且按顺序进行通信，即只与直接上下层有通信接口，每一层向上层提供明确定义的服务，并使用下层提供的服务，具有自己的私有处理
优势：
- 模块化
- 服务定义和抽象清晰
- 可复用、可持续独立发展改进
- 关注点分离
- 能够支持**点对点通信**

> [!NOTE]
> 层次设计在计算机系统中应用很广泛，一个典型的例子是程序代码的编译（以C语言为例），代码的编辑-编译-连接-执行分属不同的层，它的好处在于各层执行功能时相互独立，所使用的工具可以替换，例如编译器选择clang或gcc都可以；然而有时候也需要牺牲分层带来的灵活性，例如在c代码中使用内联汇编进行优化，这是一种跨层优化

之后会介绍的NAT（网络地址转换）是一个非常具有代表性的例子，它是一种很有用的工具，但也让向互联网添加新的传输协议变得不可能。

## 5.2 封装原则
封装是结合了分层和分组交换之后产生的结果，我们希望将数据包分成多个分组，而每个数据包中又包含了来自多个层的数据，例如当发送TCP段时，它首先位于IP数据包中，并且又放置在以太网帧中，这是通过遵循封装原则进行信息组织实现的，封装原则使得数据包能够保持层次结构，同时内容共享

封装是让我们使用协议层并使其能够更简单地在数据包内共享存储的原则，是**分层在实际数据表示中的体现方式**
它的工作方式是每个协议层都有一些头部header，随后是有效载荷和一些页脚。
例如，IP数据包的头部保存源地址和目的地址，使用IP发送一个TCP段时，我们**将TCP段作为IP数据包的有效载荷**
```
┌─────────────────────────────────────────────────┐
│              应用层数据 (HTTP, FTP等)             │
└─────────────────────────────────────────────────┘
                        ↓ 封装
┌──────────┬──────────────────────────────────────┐
│ TCP头部  │         应用层数据（TCP的Payload）      │
└──────────┴──────────────────────────────────────┘
                  ↑ 这整个就是 TCP Segment（TCP段）
                        ↓ 封装
┌──────────┬──────────────────────────────────────┐
│ IP头部   │         TCP段（IP的Payload）           │
└──────────┴──────────────────────────────────────┘
                  ↑ 这整个就是 IP Packet（IP数据包）
                        ↓ 封装
┌──────────┬──────────────────────────────────────┬─────────┐
│ 帧头部    │       IP数据包（帧的Payload）          │ 帧尾部    │
└──────────┴──────────────────────────────────────┴─────────┘
                  ↑ 这整个就是 Frame（数据帧）
```
因此，IP数据包封装了TCP段，并且IP不需要知道它的有效负载是什么，只需要根据自己的头部将数据包传递到目的主机上，由目的主机查看有效负载，知道是一个TCP段，然后相应处理

对于更完整的使用情况也是相同的：
假设你正在使用通过wifi无线以太网连接的计算机浏览网络，网络浏览器会生成一个`HTTP GET`请求，这个`GET`请求就作为TCP段的有效载荷：**TCP封装`HTTP GET`的段成为有效载荷，随后IP数据包进一步封装了TCP段（其中包含`HTTP GET`请求），该IP数据包又是WIFI链路帧的有效载荷**

> [!NOTE]
> 
> ![[Pasted image 20251224105626.png]]
> 
> 上图中是一种绘制数据包的方式，头部在右侧，尾部在左侧，从右往左数据包的位数上升。此时向路由器或交换器传送数据包的方向也是从左到右移动，因此最右边的位先到达并离开路由器
> 软件领域则经常反过来，头部在左侧，尾部在右侧，例如IETF文档或很多协议规范。因为遵循地址从左往右递增的原则

在wireshark工具中，一个数据包看起来像是如下这样的：
![[Pasted image 20251224112332.png]]
最上方告诉我们该数据包是一个以太网帧，其中包含了下两行`Internet Protocol Version 4`开头的部分所描述的IP数据包；而IP数据包中又包含了它下一行`Transmission Contorl Protocol`开头描述的TCP段；TCP段中又包含了最下面的`HTTP`段，其中包含`HTTP GET`请求

wireshark能够将每一部分在数据包实际字节中的位置标注出来：
![[Pasted image 20251224112754.png]]

这就是非常简单的将协议封装在数据包内部的方法，网络四层模型并不是静态的，封装的过程会随着数据包的传输行为而变化，**虚拟私人网络VPN**就是一个很典型的例子：
虚拟私人网络VPN的用途是**与你信任的网络建立一个安全的连接**，例如使用**TLS传输层安全性协议**，当使用互联网发送IP数据包时，**首先将流量转发到这个VPN连接中，然后由这个私人网络正常进行路由**，从而使得网络资源像在私人网络中私有受保护一样，只需要关注一个服务的保护（VPN网关）
在VPN的例子中，假设我们正在访问公式内部的网站，我们的网络浏览器生成了一个`HTTP GET`请求，它首先被放置在TCP段中，然后嵌套在IP数据包中，**此时IP的目的是公司内部的Web服务器（受保护）**。
此时，由于需要保护私有网络的安全性，不能直接与内部web服务器通信（私人网络），而是将IP数据包放入一个TLS段中（前面提到的传输层安全性协议），该协议通过加密保护信息，TLS段也具有它自己的头
加密完成之后，这个TLS-IP-TCP-HTTP结构的数据包（TLS段）需要先被发送到VPN网关才能进入，因此外层将其放置在另一个TCP段和IP数据包中，流的目的是VPN网关。在最外层，则是放在链路层的**ETH（以太网）帧**中，然后通过链路层运输到当前路由器的下一跳中：
![[Pasted image 20251224133529.png]]

# Lecture 6. 内存、字节序和数据包格式
数据以字节形式在不同主机之间传输，因此需要对消息包含哪些字段，这些字段的字节排列格式、信息表示方法达成一致
在生成要发送的消息时，软件通常需要先在内存中创建一个消息的副本，这个副本会经过网络卡进行发送；而在接收一条消息时，网络卡将消息放在内存中，由软件之后访问它们

## 6.1 计算机内存模型
让我们从一个简单的计算机内存模型开始
![[Pasted image 20251224161444.png]]
大多数计算机以字节形式组织内存，1字节=8位，一个程序拥有自己的地址空间，从地址0开始，现代电脑的地址长度通常为64位，因此最大存储量为$2^{64}$字节
$2^{30}$字节等于1GB，在上图中计算机内存为8GB，即$2^{33}$字节。软件可以访问内存中的每一个字节或按组访问字节（例如加载一条从8个连续字节中读取64位整数的机器指令时）
多字节值，例如数字1024（0x0400占两个字节）的**字节顺序**则非常重要，0x0400和0x0004是截然不同的两个值。现代计算机中存在两种字节顺序：**小端序LSB和大端序MSB**。（数字表示中，低地址在左，高地址在右）
- LSB：最小的有效字节在地址最低的地址，例如1024的字节表示中0x00位于低地址，0x04位于高地址，即0x0004
- MSB：最大的有效字节位于最低的地址，例如1024的大端序表示就是0x0400

> [!NOTE] 不使用计算器看出一个十进制数的十六进制表示是什么字节顺序
> 本质上是看十进制和十六进制的转换，先将原十六进制数两位两位地看，对于四位

## 6.2 网络字节序
因此，若两台计算机需要互相通讯，它们的处理器使用小端序还是大端序就很重要，而且可能会不同。例如x86是小端序，而arm是大端序
我们不希望计算机关心另一边使用什么字节顺序，因此协议规范机构规定所有互联网协议使用大端序
但如果一个互联网数据包是大端序，但接收它的处理器是小端存储，会出现什么情况？
假设数据包的TCP段中的端口号是80（即HTTP端口），这个数字使用两个字节存储。这个端口号在数据包的固定偏移量处使用大端序存储，如果使用小端序主机直接读取它，那么就会读出截然不同的端口号

为了避免这种问题，C的网络库提供了主机和网络之间的顺序转换函数：
- `h2ns()`：接受一个16位的主机上的短整型short值，将这个值用符合网络字节顺序的方式输出
- `n2hs()`：将网络短整型转换为主机短整型short值
- `h2nl()` `n2hl()`：和前两个一样，只是转换32位长整型long值
所以网络程序读取数据时需要通过类似于`ntohs(packet->port)`的方式来安全地进行

**要小心地处理任何网络数据**，在进行网络数据和主机数据之间的转换时要格外小心，它会导致协议出现各种意想不到的问题

## 6.3 数据包格式
我们知道了互联网使用网络顺序（以大端序为标准）布置多字节值，接下来就可以查看各个网络协议是如何描述它们的数据包格式的了
网络协议使用纯ASCII符号文本编写，下面展示了直接摘自RFC 791的文字块：
![[Pasted image 20251225105630.png]]
它规定了IPv4的数据包规范，在顶部可以看到显示了0-31的位号，这是因为网络协议文档编写标准规定了头部字段使用4字节对齐描述
因为IPv4的数据包头至少有五行，所以其长度至少有20字节。并且可以看到IPv4数据报的Total length总长字段的长度是16位，意味着它最大可以表示65535字节，即数据包的长度不能超过65535字节；数据包的所有数据以大端序存储

在wireshark中，我们可以看到网络浏览器使用`HTTPS`协议进行安全连接，它其实就是HTTP+TLS/SSL，使用TLS或SSL协议进行加密和身份验证，然后由TCP段指定默认端口为443（记住，端口用于区分同一台计算机上的不同服务），代表HTTPS加密网络浏览服务，这个TCP段就位于IPv4头内部：
![[Pasted image 20251225114401.png]]
尽管HTTPS对数据包经过了加密，但是使用wireshark我们可以看到IPv4头内部的情况
![[Pasted image 20251225114530.png]]
这里显示Total Length为1230，在下面数据包实际字节中显示是`04 ce`，这意味着使用大端序时就是0x04ce=1230，数据包使用大端序作为字节顺序

# Lecture 7. IPv4命名和地址
互联网协议通过网络传递数据，网络底层是很多链路，它们通过地址来进行导航：路由器根据数据包的目的地址决定应该将流量转发到哪条链路上，直到目的主机。因此我们需要详细了解IPv4地址的样式、格式化和分配方法

网络协议的目的是把不同的网络集合在一起，协议需要一种独立于所在的网络，且是唯一的引用方式来引用计算机，这样一台连接了路由器或串口线的计算机就能进行通信了
实际上今天的IPv4地址由于很多特殊情况和用途并不完全唯一，但我们在这里假设它们是唯一的

## 7.1 IPv4地址、子网掩码
一个IPv4地址长度为32位，通常将每八位分离出来，成为四个八位的字节，书写形式为：
```
A.B.C.D
171.64.64.64
128.30.76.82
...
```
通过IPv4连接的设备都具有一个IPv4地址，IP层将目的为该地址的数据报传递到该设备

除了地址以外，设备通常还具有**子网掩码**
子网掩码用于告诉你哪些IP地址是**本地的**、哪些是**位于同一链路上的**、哪些是**位于同一网络上的**、哪些**需要通过IP路由器到达**，这样位于同一网络的设备能够直接进行传输，路由器也能够知道应该转发的方向

子网掩码的长度和地址相同，都是32位，它是一串从最高有效位开始连续的1值，注意1是连续的，只要出现了0之后就没有1了(?)。
例如，我们知道$(11111111)_2=2^8-1=255$，那么设备的子网掩码`255.255.255.0`就代表前24位（前三个字节）都是1，最后一个字节都是0，这意味着**一个IP地址的前24位值和该设备匹配上的设备与它在同一个网络下**
当然，并不是一个字节内的每一位都必须相同，例如`255.128.0.0`，其中$128=(1000000)_2$，就是前一个字节加一位的值都是1，匹配上这9位的设备与其在同一个网络下

计算机通过**将设备的IP地址与子网掩码进行==按位与==操作**来计算设备的**网络地址**，实际上就是**只看地址中掩码中值为1的位部分的值**。
若**网络地址相等，则两个设备在同一个网络中**；子网掩码中的**1数量越少，意味着这个网络越大（连接的设备越多）**

Linux中，可以使用`ifconfig`工具来进行网络接口信息的配置和显示

## 7.2 地址结构
### 7.2.1 早期IP地址结构
IP地址最开始被分为三个等级ABC，每个等级具有不同的规则和要求：
所有等级都将IP地址视为两部分：网络地址network+主机地址host
![[Pasted image 20251225183155.png]]
- 地址的网络部分表示一个**管理域**（或其的一部分），例如MIT/Stanford这样由同一组织或实体管理控制的网络范围，具有相同的管理、安全、路由策略
- 地址的主机部分表示**该网络上的一个特定设备**
从图中可以看到，不同类别的地址分配给网络地址和主机地址的位数不同，这就导致了每种地址的网络数和设备数各不相同，从而适合不同的应用场景

然而，这样的分类系统随着地址不断被用尽，存在地址利用率低、子网掩码固定、灵活性不足导致某类地址太少而其他地址太多、路由器的路由表会很大等问题，在1993年就被废弃了，在今天，IPv4地址通过**无类域间路由CIDR**的方式进行结构化
### 7.2.2 无类域间路由CIDR


